<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Le langage de programmation Rust</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../ferris.css">
        
        <link rel="stylesheet" href="../theme/2018-edition.css">
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="affix"><a href="title-page.html">Le langage de programmation Rust</a></li><li class="affix"><a href="foreword.html">Avant-propos</a></li><li class="affix"><a href="ch00-00-introduction.html">Introduction</a></li><li><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Le langage de programmation Rust</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
# The Rust Programming Language
-->
<h1><a class="header" href="#le-langage-de-programmation-rust" id="le-langage-de-programmation-rust">Le langage de programmation Rust</a></h1>
<!--
*by Steve Klabnik and Carol Nichols, with contributions from the Rust Community*
-->
<p><em>par Steve Klabnik et Carol Nichols, avec la participation de la Communauté
Rust</em></p>
<!--
This version of the text assumes you’re using Rust 1.31.0 or later with
`edition="2018"` in *Cargo.toml* of all projects to use Rust 2018 Edition
idioms. See the [“Installation” section of Chapter 1][install]<!-- ignore -- >
to install or update Rust, and see the new [Appendix E][editions]<!-- ignore
-- > for information on editions.
-->
<p>Cette version du document suppose que vous utilisez Rust 1.31.0 ou ultérieur
avec <code>edition=&quot;2018&quot;</code> dans <em>Cargo.toml</em> de tous les projets afin d'utiliser les
expressions idiomatiques de l'édition 2018 de Rust.
Voir la <a href="ch01-01-installation.html">section “Installation” du chapitre 1</a><!-- ignore -->
pour installer ou mettre à jour Rust, et
voir la nouvelle <a href="appendix-05-editions.html">annexe E</a><!-- ignore --> pour plus d'informations
sur les éditions.</p>
<!--
The 2018 Edition of the Rust language includes a number of improvements that
make Rust more ergonomic and easier to learn. This iteration of the book
contains a number of changes to reflect those improvements:
-->
<p>L'édition 2018 du langage Rust apporte quelques améliorations qui rendent Rust
plus ergonomique et plus facile à apprendre. Cette version du livre comprend un
certain nombre de changements pour refléter ces améliorations :</p>
<!--
- Chapter 7, “Managing Growing Projects with Packages, Crates, and Modules,”
  has been mostly rewritten. The module system and the way paths work in the
  2018 Edition were made more consistent.
- Chapter 10 has new sections titled “Traits as Parameters” and “Returning
  Types that Implement Traits” that explain the new `impl Trait` syntax.
- Chapter 11 has a new section titled “Using `Result<T, E>` in Tests” that
  shows how to write tests that use the `?` operator.
- The “Advanced Lifetimes” section in Chapter 19 was removed because compiler
  improvements have made the constructs in that section even rarer.
- The previous Appendix D, “Macros,” has been expanded to include procedural
  macros and was moved to the “Macros” section in Chapter 19.
- Appendix A, “Keywords,” also explains the new raw identifiers feature that
  enables code written in the 2015 Edition and the 2018 Edition to interoperate.
- Appendix D is now titled “Useful Development Tools” and covers recently
  released tools that help you write Rust code.
- We fixed a number of small errors and imprecise wording throughout the book.
  Thank you to the readers who reported them!
-->
<ul>
<li>Le chapitre 7 a été réécrit en grande partie. Le système de modules et le
fonctionnement des chemins dans l'édition 2018 ont été rendus plus cohérents.</li>
<li>Le chapitre 10 a deux nouvelles parties qui expliquent la nouvelle syntaxe
<code>impl Trait</code>.</li>
<li>Le chapitre 11 a une nouvelle partie qui montre comment écrire des tests qui
utilisent l'opérateur <code>?</code>.</li>
<li>La partie &quot;Durée de vie avancée&quot; du chapitre 19 a été retirée, car les
améliorations du compilateur ont rendu encore plus rare les concepts de cette
section.</li>
<li>L'ancienne Annexe D a été complétée pour couvrir les macros procédurales et a
été déplacée dans la section &quot;Macros&quot; du chapitre 19.</li>
<li>L'annexe A explique aussi la nouvelle fonctionnalité d'identificateurs bruts
qui rend du code écrit avec l'édition 2015 interopérable avec l'édition 2018.</li>
<li>L'annexe D a été renommée et couvre les nouveaux outils ajoutés récemment
pour vous aider à écrire du code Rust.</li>
<li>Nous avons corrigé quelques petites erreurs et certaines formulations floues
dans tout le livre. Merci aux lecteurs qui nous les ont signalées !</li>
</ul>
<!--
Note that any code in earlier iterations of *The Rust Programming Language*
that compiled will continue to compile without `edition="2018"` in the
project’s *Cargo.toml*, even as you update the Rust compiler version you’re
using. That’s Rust’s backward compatibility guarantees at work!
-->
<p>Veuillez noter que tout le code dans les versions précédentes du livre
<em>Le langage de programmation Rust</em> qui se compilait va continuer à compiler sans
<code>edition=&quot;2018&quot;</code> dans le <em>Cargo.toml</em> du projet, même si vous mettez à jour le
compilateur Rust que vous utilisez. C'est la garantie de la rétrocompatibilité
de Rust qui est à l'œuvre ici !</p>
<!--
The HTML format is available online at
[https://doc.rust-lang.org/stable/book/](https://doc.rust-lang.org/stable/book/)
and offline with installations of Rust made with `rustup`; run `rustup docs
--book` to open.
-->
<p>Le format HTML de la version anglaise est disponible en ligne à l'adresse
<a href="https://doc.rust-lang.org/stable/book/">https://doc.rust-lang.org/stable/book/</a>
et en hors-ligne avec l'installation de Rust qui a été effectuée avec <code>rustup</code> ;
vous pouvez lancer <code>rustup docs --book</code> pour l'ouvrir.</p>
<!--
This text is available in [paperback and ebook format from No Starch
Press][nsprust].
-->
<p>La version anglaise de ce livre est disponible
<a href="https://nostarch.com/rust">au format papier et e-book chez No Starch Press</a>.</p>
<!--
# Foreword
-->
<h1><a class="header" href="#avant-propos" id="avant-propos">Avant-propos</a></h1>
<!--
It wasn’t always so clear, but the Rust programming language is fundamentally
about *empowerment*: no matter what kind of code you are writing now, Rust
empowers you to reach farther, to program with confidence in a wider variety of
domains than you did before.
-->
<p>Cela n'a pas toujours été aussi évident, mais le langage de programmation Rust
apporte avant tout plus de <em>puissance</em> : peu importe le type de code que vous
écrivez en ce moment, Rust vous permet d'aller plus loin et de
programmer en toute confiance dans une plus grande diversité de domaines
qu'auparavant.</p>
<!--
Take, for example, “systems-level” work that deals with low-level details of
memory management, data representation, and concurrency. Traditionally, this
realm of programming is seen as arcane, accessible only to a select few who
have devoted the necessary years learning to avoid its infamous pitfalls. And
even those who practice it do so with caution, lest their code be open to
exploits, crashes, or corruption.
-->
<p>Prenez par exemple la gestion des éléments au “niveau système” qui traite de
détails bas niveau de gestion de mémoire, de modèles de données, et de
concurrence. Traditionnellement, ce domaine de la programmation est jugé
ésotérique, compréhensible uniquement par une poignée de personnes qui ont
consacré des années d'apprentissage à en déjouer les pièges infâmes.
Et même ceux qui travaillent dans ce domaine le font avec beaucoup de prudence,
de crainte que leur code soit soumis à des failles ou des plantages,
ou qu'il soit corrompu.</p>
<!--
Rust breaks down these barriers by eliminating the old pitfalls and providing a
friendly, polished set of tools to help you along the way. Programmers who need
to “dip down” into lower-level control can do so with Rust, without taking on
the customary risk of crashes or security holes, and without having to learn
the fine points of a fickle toolchain. Better yet, the language is designed to
guide you naturally towards reliable code that is efficient in terms of speed
and memory usage.
-->
<p>Rust fait tomber ces obstacles en éliminant les vieux pièges et en apportant un
ensemble d'outils soignés et conviviaux pour vous aider sur votre chemin.
Les développeurs qui ont besoin de &quot;se plonger&quot; dans le contrôle de plus
bas niveau peuvent ainsi le faire avec Rust, sans prendre le risque habituel
de plantages ou de failles de sécurité, et sans avoir à apprendre les subtilités
d'un enchevêtrement d'outils capricieux. Encore mieux, le langage est conçu pour
vous guider naturellement vers un code fiable et efficace en termes de rapidité
d'exécution et d'utilisation de la mémoire.</p>
<!--
Programmers who are already working with low-level code can use Rust to raise
their ambitions. For example, introducing parallelism in Rust is a relatively
low-risk operation: the compiler will catch the classical mistakes for you. And
you can tackle more aggressive optimizations in your code with the confidence
that you won’t accidentally introduce crashes or vulnerabilities.
-->
<p>Les développeurs qui travaillent déjà avec du code bas niveau peuvent utiliser
Rust pour accroître leurs ambitions. Par exemple, introduire du parallélisme en
Rust est une opération à faible risque : le compilateur va détecter les erreurs
classiques pour vous. Et vous pourrez vous lancer dans des améliorations plus
agressives de votre code avec la certitude que vous n'introduirez pas
accidentellement des causes de plantage ou des vulnérabilités.</p>
<!--
But Rust isn’t limited to low-level systems programming. It’s expressive and
ergonomic enough to make CLI apps, web servers, and many other kinds of code
quite pleasant to write — you’ll find simple examples of both later in the
book. Working with Rust allows you to build skills that transfer from one
domain to another; you can learn Rust by writing a web app, then apply those
same skills to target your Raspberry Pi.
-->
<p>Mais Rust n'est pas cantonné à la programmation de bas niveau. C'est un langage
suffisamment expressif et ergonomique pour rendre les applications en ligne
de commande, les serveurs web et bien d'autres types de code agréables à écrire
— vous trouverez plus tard des exemples simples de chacun dans ce livre.
Travailler avec Rust vous permet d'acquérir des compétences qui sont
transposables d'un domaine à un autre ; vous pouvez apprendre Rust en écrivant
une application web, puis appliquer les mêmes notions pour les utiliser avec
votre Raspberry Pi.</p>
<!--
This book fully embraces the potential of Rust to empower its users. It’s a
friendly and approachable text intended to help you level up not just your
knowledge of Rust, but also your reach and confidence as a programmer in
general. So dive in, get ready to learn—and welcome to the Rust community!
-->
<p>Ce livre exploite pleinement le potentiel de Rust pour permettre à ses
utilisateurs de se développer. C'est une documentation conviviale et accessible
destinée à améliorer vos connaissances en Rust, mais aussi à améliorer vos
capacités et votre assurance en tant que développeur en général. Alors foncez,
et préparez-vous à apprendre — et bienvenue dans la communauté Rust !</p>
<!--
— Nicholas Matsakis and Aaron Turon
-->
<p>— Nicholas Matsakis et Aaron Turon</p>
<!--
# Introduction
-->
<h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<!--
> Note: This edition of the book is the same as [The Rust Programming
> Language][nsprust] available in print and ebook format from [No Starch
> Press][nsp].
-->
<blockquote>
<p>Note : la version anglaise de ce livre est disponible au format papier et
ebook chez <a href="https://nostarch.com/">No Starch Press</a> à cette adresse :
<a href="https://nostarch.com/rust">The Rust Programming Language</a></p>
</blockquote>
<!--
Welcome to *The Rust Programming Language*, an introductory book about Rust.
The Rust programming language helps you write faster, more reliable software.
High-level ergonomics and low-level control are often at odds in programming
language design; Rust challenges that conflict. Through balancing powerful
technical capacity and a great developer experience, Rust gives you the option
to control low-level details (such as memory usage) without all the hassle
traditionally associated with such control.
-->
<p>Bienvenue sur <em>Le langage de programmation Rust</em>, un livre d'initiation à Rust.
Le langage de programmation Rust vous aide à écrire plus rapidement des
logiciels plus fiables. L'ergonomie de haut-niveau et la maîtrise de bas-niveau
sont souvent en opposition dans la conception des langages de programmation ;
Rust remet en cause ce conflit. Grâce à l'équilibre entre ses puissantes
capacités techniques et une bonne ergonomie de développement, Rust vous donne
la possibilité de contrôler les détails de bas-niveau (comme l'utilisation de
la mémoire) sans tous les soucis traditionnellement associés à ce genre de
pratique.</p>
<!--
## Who Rust Is For
-->
<h2><a class="header" href="#À-qui-sadresse-rust" id="À-qui-sadresse-rust">À qui s'adresse Rust</a></h2>
<!--
Rust is ideal for many people for a variety of reasons. Let’s look at a few of
the most important groups.
-->
<p>Rust est idéal pour de nombreuses personnes pour diverses raisons. Analysons
quelques-uns des groupes les plus importants.</p>
<!--
### Teams of Developers
-->
<h3><a class="header" href="#Équipes-de-développeurs" id="Équipes-de-développeurs">Équipes de développeurs</a></h3>
<!--
Rust is proving to be a productive tool for collaborating among large teams of
developers with varying levels of systems programming knowledge. Low-level code
is prone to a variety of subtle bugs, which in most other languages can be
caught only through extensive testing and careful code review by experienced
developers. In Rust, the compiler plays a gatekeeper role by refusing to
compile code with these elusive bugs, including concurrency bugs. By working
alongside the compiler, the team can spend their time focusing on the program’s
logic rather than chasing down bugs.
-->
<p>Rust se révèle être un outil productif pour la collaboration entre de grandes
équipes de développeurs ayant différents niveaux de connaissances en
programmation système. Le code de bas-niveau est sujet à une multitude de bogues
subtils, qui, dans la plupart des autres langages, ne peuvent être prévenus
qu'au moyen de campagnes de test étendues et de minutieuses revues de
code menées par des développeurs chevronnés. Avec Rust, le compilateur joue le
rôle de gardien en refusant de compiler du code qui comprend ces bogues
discrets et vicieux, y compris les bogues de concurrence. En travaillant avec
le compilateur, l'équipe peut se concentrer sur la logique du programme plutôt
que de traquer les bogues.</p>
<!--
Rust also brings contemporary developer tools to the systems programming world:
-->
<p>Rust offre aussi des outils de développement modernes au monde de la
programmation système :</p>
<!--
* Cargo, the included dependency manager and build tool, makes adding,
  compiling, and managing dependencies painless and consistent across the Rust
  ecosystem.
* Rustfmt ensures a consistent coding style across developers.
* The Rust Language Server powers Integrated Development Environment (IDE)
  integration for code completion and inline error messages.
-->
<ul>
<li>Cargo, l'outil intégré de gestion de dépendances et de compilation, qui
uniformise et facilite l'ajout, la compilation, et la gestion des dépendances
dans l'écosystème Rust.</li>
<li>Rustfmt, qui assure une cohérence de style de codage pour tous les
développeurs.</li>
<li>Le <em>Rust Langage Server</em> alimente les environnements de développement
intégrés (IDE) pour la complétion du code et l'affichage direct des messages
d'erreur.</li>
</ul>
<!--
By using these and other tools in the Rust ecosystem, developers can be
productive while writing systems-level code.
-->
<p>En utilisant ces outils ainsi que d'autres dans l'écosystème Rust, les
développeurs peuvent être plus productifs quand ils écrivent du code système.</p>
<!--
### Students
-->
<h3><a class="header" href="#Étudiants" id="Étudiants">Étudiants</a></h3>
<!--
Rust is for students and those who are interested in learning about systems
concepts. Using Rust, many people have learned about topics like operating
systems development. The community is very welcoming and happy to answer
student questions. Through efforts such as this book, the Rust teams want to
make systems concepts more accessible to more people, especially those new to
programming.
-->
<p>Rust est conçu pour les étudiants et ceux qui s'intéressent à l'apprentissage
des concepts système. En utilisant Rust, de nombreuses personnes ont appris
des domaines comme le développement de systèmes d'exploitation. La communauté
est très accueillante et répond volontiers aux questions des étudiants. Grâce à
des initiatives comme ce livre, les équipes de Rust veulent rendre les notions
système accessibles au plus grand nombre, particulièrement à ceux qui débutent
dans la programmation.</p>
<!--
### Companies
-->
<h3><a class="header" href="#entreprises" id="entreprises">Entreprises</a></h3>
<!--
Hundreds of companies, large and small, use Rust in production for a variety of
tasks. Those tasks include command line tools, web services, DevOps tooling,
embedded devices, audio and video analysis and transcoding, cryptocurrencies,
bioinformatics, search engines, Internet of Things applications, machine
learning, and even major parts of the Firefox web browser.
-->
<p>Des centaines d'entreprises, petites et grosses, utilisent Rust en production
pour différentes missions. Ils l'utilisent pour des outils en ligne de commande,
des services web, des outils DevOps, des systèmes embarqués, de l'analyse et de
la conversion audio et vidéo, des cryptomonnaies, de la bio-informatique, des
moteurs de recherche, de l'internet des objets <em>(IoT)</em>, de l'apprentissage
automatique <em>(marchine learning)</em>, et même des parties importantes du navigateur
internet Firefox.</p>
<!--
### Open Source Developers
-->
<h3><a class="header" href="#développeurs-de-logiciel-libre" id="développeurs-de-logiciel-libre">Développeurs de logiciel libre</a></h3>
<!--
Rust is for people who want to build the Rust programming language, community,
developer tools, and libraries. We’d love to have you contribute to the Rust
language.
-->
<p>Rust est ouvert aux personnes qui veulent développer le langage de programmation
Rust, la communauté, les outils de développement et les bibliothèques. Nous
serions ravis que vous contribuiez au langage Rust.</p>
<!--
### People Who Value Speed and Stability
-->
<h3><a class="header" href="#les-personnes-qui-recherchent-la-rapidité-et-la-stabilité" id="les-personnes-qui-recherchent-la-rapidité-et-la-stabilité">Les personnes qui recherchent la rapidité et la stabilité</a></h3>
<!--
Rust is for people who crave speed and stability in a language. By speed, we
mean the speed of the programs that you can create with Rust and the speed at
which Rust lets you write them. The Rust compiler’s checks ensure stability
through feature additions and refactoring. This is in contrast to the brittle
legacy code in languages without these checks, which developers are often
afraid to modify. By striving for zero-cost abstractions, higher-level features
that compile to lower-level code as fast as code written manually, Rust
endeavors to make safe code be fast code as well.
-->
<p>Rust est une solution pour les personnes qui chérissent la rapidité et la
stabilité dans un langage. Par rapidité, nous entendons la vitesse des
programmes que vous pouvez créer avec Rust et la rapidité avec laquelle Rust
vous permet de les écrire. Les vérifications du compilateur de Rust assurent la
stabilité durant l'ajout de fonctionnalités ou le remaniement du code. Cela
le démarque des langages qui ne font pas ces contrôles sur du code instable que
le programme a hérité avec le temps, et que bien souvent les développeurs ont
peur de modifier. En s'efforçant de mettre en place des abstractions sans coût,
des fonctionnalités de haut-niveau qui compilent vers du code bas-niveau aussi
rapide que s'il avait été écrit à la main, Rust fait en sorte que le
code sûr soit aussi du code rapide.</p>
<!--
The Rust language hopes to support many other users as well; those mentioned
here are merely some of the biggest stakeholders. Overall, Rust’s greatest
ambition is to eliminate the trade-offs that programmers have accepted for
decades by providing safety *and* productivity, speed *and* ergonomics. Give
Rust a try and see if its choices work for you.
-->
<p>Le langage Rust espère aider beaucoup d'autres utilisateurs ; ceux cités ici ne
font partie que d'un univers bien plus grand. Globalement, la plus grande
ambition de Rust est d'éradiquer les compromis auxquels les développeurs
se soumettaient depuis des décennies en leur apportant sécurité <em>et</em>
productivité, rapidité <em>et</em> ergonomie. Essayez Rust et vérifiez si ses décisions
vous conviennent.</p>
<!--
## Who This Book Is For
-->
<h2><a class="header" href="#À-qui-est-destiné-ce-livre" id="À-qui-est-destiné-ce-livre">À qui est destiné ce livre</a></h2>
<!--
This book assumes that you’ve written code in another programming language but
doesn’t make any assumptions about which one. We’ve tried to make the material
broadly accessible to those from a wide variety of programming backgrounds. We
don’t spend a lot of time talking about what programming *is* or how to think
about it. If you’re entirely new to programming, you would be better served by
reading a book that specifically provides an introduction to programming.
-->
<p>Ce livre suppose que vous avez écrit du code dans un autre langage de
programmation mais ne suppose pas lequel. Nous avons essayé de rendre son
contenu le plus accessible au plus grand nombre d'expériences de programmation
possible. Nous ne nous évertuons pas à nous questionner sur <em>ce qu'est</em> la
programmation ou comment l'envisager. Si vous êtes débutant en programmation,
vous seriez mieux avisé en lisant un livre qui vous initie à la programmation.</p>
<!--
## How to Use This Book
-->
<h2><a class="header" href="#comment-utiliser-ce-livre" id="comment-utiliser-ce-livre">Comment utiliser ce livre</a></h2>
<!--
In general, this book assumes that you’re reading it in sequence from front to
back. Later chapters build on concepts in earlier chapters, and earlier
chapters might not delve into details on a topic; we typically revisit the
topic in a later chapter.
-->
<p>Globalement, ce livre est prévu pour être lu dans l'ordre. Les chapitres
suivants s'appuient sur les notions abordées dans les chapitres précédents, et
lorsque les chapitres précédents ne peuvent pas approfondir un sujet, ce sera
généralement fait dans un chapitre suivant.</p>
<!--
You’ll find two kinds of chapters in this book: concept chapters and project
chapters. In concept chapters, you’ll learn about an aspect of Rust. In project
chapters, we’ll build small programs together, applying what you’ve learned so
far. Chapters 2, 12, and 20 are project chapters; the rest are concept chapters.
-->
<p>Vous allez rencontrer deux différents types de chapitres dans ce livre : les
chapitres théoriques et les chapitres de projet. Dans les chapitres théoriques,
vous allez apprendre un sujet à propos de Rust. Dans un chapitre de projet, nous
allons construire ensemble des petits programmes, pour appliquer ce que vous
avez appris précédemment. Les chapitres 2, 12 et 20 sont des chapitres de
projet ; les autres sont des chapitres théoriques.</p>
<!--
Chapter 1 explains how to install Rust, how to write a Hello, world! program,
and how to use Cargo, Rust’s package manager and build tool. Chapter 2 is a
hands-on introduction to the Rust language. Here we cover concepts at a high
level, and later chapters will provide additional detail. If you want to get
your hands dirty right away, Chapter 2 is the place for that. At first, you
might even want to skip Chapter 3, which covers Rust features similar to those
of other programming languages, and head straight to Chapter 4 to learn about
Rust’s ownership system. However, if you’re a particularly meticulous learner
who prefers to learn every detail before moving on to the next, you might want
to skip Chapter 2 and go straight to Chapter 3, returning to Chapter 2 when
you’d like to work on a project applying the details you’ve learned.
-->
<p>Le chapitre 1 explique comment installer Rust, comment écrire un programme
&quot;Hello, world!&quot; et comment utiliser Cargo, le gestionnaire de paquets et outil
de compilation. Le chapitre 2 est une initiation pratique au langage Rust. Nous
y aborderons des concepts de haut-niveau, et les chapitres suivants apporteront
plus de détails. Si vous voulez vous <em>salir les mains</em> tout de suite,
le chapitre 2 est l'endroit pour cela. Au début, vous pouvez même sauter le
chapitre 3, qui aborde les fonctionnalités de Rust semblables aux autres
langages de programmation, et passer directement au chapitre 4 pour en savoir
plus sur le système de possession <em>(ownership)</em> de Rust. Toutefois, si vous êtes
un apprenti particulièrement minutieux qui préfère apprendre chaque
particularité avant de passer à la suivante, vous pouvez sauter le chapitre 2 et
passer directement au chapitre 3, puis revenir au chapitre 2 lorsque vous
souhaitez travailler sur un projet en appliquant les notions que vous avez
apprises.</p>
<!--
Chapter 5 discusses structs and methods, and Chapter 6 covers enums, `match`
expressions, and the `if let` control flow construct. You’ll use structs and
enums to make custom types in Rust.
-->
<p>Le chapitre 5 traite des structures et des méthodes, et le chapitre 6 couvre les
énumérations, les expressions <code>match</code>, et la structure de contrôle <code>if let</code>.
Vous emploierez les structures et les énumérations pour créer des types
personnalisés avec Rust.</p>
<!--
In Chapter 7, you’ll learn about Rust’s module system and about privacy rules
for organizing your code and its public Application Programming Interface
(API). Chapter 8 discusses some common collection data structures that the
standard library provides, such as vectors, strings, and hash maps. Chapter 9
explores Rust’s error-handling philosophy and techniques.
-->
<p>Au chapitre 7, vous apprendrez le système de modules de Rust et les règles de
visibilité, afin d'organiser votre code et son interface de programmation
applicative (API) publique. Le chapitre 8 traitera des structures de collections
de données usuelles fournies par la bibliothèque standard, comme les vecteurs,
les chaînes de caractères et les tables de hachage <em>(hash maps)</em>. Le chapitre 9
explorera la philosophie et les techniques de gestion d'erreurs de Rust.</p>
<!--
Chapter 10 digs into generics, traits, and lifetimes, which give you the power
to define code that applies to multiple types. Chapter 11 is all about testing,
which even with Rust’s safety guarantees is necessary to ensure your program’s
logic is correct. In Chapter 12, we’ll build our own implementation of a subset
of functionality from the `grep` command line tool that searches for text
within files. For this, we’ll use many of the concepts we discussed in the
previous chapters.
-->
<p>Le chapitre 10 nous plongera dans la généricité, les <em>traits</em> et
les durées de vie, qui vous donneront la capacité de créer du code qui s'adapte
à différents types. Le chapitre 11 traitera des techniques de test, qui restent
nécessaires malgré les garanties de sécurité de Rust, pour s'assurer que
la logique de votre programme est valide. Au chapitre 12, nous écrirons
notre propre implémentation d'un sous-ensemble des fonctionnalités du programme
en ligne de commande <code>grep</code>, qui recherche du texte dans des fichiers.
Pour ce faire, nous utiliserons de nombreuses notions abordées dans les
chapitres précédents.</p>
<!--
Chapter 13 explores closures and iterators: features of Rust that come from
functional programming languages. In Chapter 14, we’ll examine Cargo in more
depth and talk about best practices for sharing your libraries with others.
Chapter 15 discusses smart pointers that the standard library provides and the
traits that enable their functionality.
-->
<p>Le chapitre 13 explorera les fermetures <em>(closures)</em> et itérateurs : ce sont les
fonctionnalités de Rust inspirées des langages de programmation fonctionnels.
Au chapitre 14, nous explorerons plus en profondeur Cargo et les bonnes
pratiques pour partager vos propres bibliothèques avec les autres. Le chapitre
15 parlera de pointeurs intelligents qu'apporte la bibliothèque standard et des
<em>traits</em> qui activent leurs fonctionnalités.</p>
<!--
In Chapter 16, we’ll walk through different models of concurrent programming
and talk about how Rust helps you to program in multiple threads fearlessly.
Chapter 17 looks at how Rust idioms compare to object-oriented programming
principles you might be familiar with.
-->
<p>Au chapitre 16, nous passerons en revue les différents modes de programmation
concurrente et comment Rust nous aide à développer dans des processus parallèles
sans crainte. Le chapitre 17 comparera les fonctionnalités de Rust aux
principes de programmation orientée objet, que vous connaissez peut-être.</p>
<!--
Chapter 18 is a reference on patterns and pattern matching, which are powerful
ways of expressing ideas throughout Rust programs. Chapter 19 contains a
smorgasbord of advanced topics of interest, including unsafe Rust, macros, and
more about lifetimes, traits, types, functions, and closures.
-->
<p>Le chapitre 18 est une référence sur les motifs et le filtrage de motif
<em>(pattern matching)</em>, qui sont des moyens puissants permettant de communiquer
des idées dans les programmes Rust. Le chapitre 19 contient une foultitude de
sujets avancés intéressants, comme le code Rust non sécurisé <em>(unsafe)</em>, les
macros et plus de détails sur les durées de vie, les <em>traits</em>, les types, les
fonctions et les fermetures <em>(closures)</em>.</p>
<!--
In Chapter 20, we’ll complete a project in which we’ll implement a low-level
multithreaded web server!
-->
<p>Au chapitre 20, nous terminerons un projet dans lequel nous allons
implémenter en bas-niveau un serveur web multi-processus !</p>
<!--
Finally, some appendixes contain useful information about the language in a
more reference-like format. Appendix A covers Rust’s keywords, Appendix B
covers Rust’s operators and symbols, Appendix C covers derivable traits
provided by the standard library, Appendix D covers some useful development
tools, and Appendix E explains Rust editions.
-->
<p>Et finalement, quelques annexes qui contiennent des informations utiles sur le
langage sous forme de référentiels qui renvoient à d'autres documents. L'annexe
A liste les mots-clés de Rust, l'annexe B couvre les opérateurs et symboles de
Rust, l'annexe C parle des <em>traits</em> dérivables qu'apporte la bibliothèque
standard, l'annexe D référence certains outils de développement utiles, et
l'annexe E explique les différentes éditions de Rust.</p>
<!--
There is no wrong way to read this book: if you want to skip ahead, go for it!
You might have to jump back to earlier chapters if you experience any
confusion. But do whatever works for you.
-->
<p>Il n'y a pas de mauvaise manière de lire ce livre : si vous voulez sauter des
étapes, allez-y !
Vous devrez alors peut-être revenir sur les chapitres précédents si vous
éprouvez des difficultés. Mais faites comme bon vous semble.</p>
<p><span id="ferris"></span></p>
<!--
An important part of the process of learning Rust is learning how to read the
error messages the compiler displays: these will guide you toward working code.
As such, we’ll provide many examples that don’t compile along with the error
message the compiler will show you in each situation. Know that if you enter
and run a random example, it may not compile! Make sure you read the
surrounding text to see whether the example you’re trying to run is meant to
error. Ferris will also help you distinguish code that isn’t meant to work:
-->
<p>Une composante importante du processus d'apprentissage de Rust est de comprendre
comment lire les messages d'erreur qu'affiche le compilateur : ils vous
guideront vers du code correct.
Ainsi, nous citerons de nombreux exemples qui ne compilent pas, avec le message
d'erreur que le compilateur devrait vous afficher dans chaque cas. C'est donc
normal que dans certains cas, si vous copiez et exécutez un exemple au hasard,
il ne compile pas ! Assurez-vous d'avoir lu le texte autour pour savoir si
l'exemple que vous tentez de compiler doit échouer. Ferris va aussi vous aider
à identifier du code qui ne devrait pas fonctionner :</p>
<!--
| Ferris                                                                 | Meaning                                          |
|------------------------------------------------------------------------|--------------------------------------------------|
| <img src="img/ferris/does_not_compile.svg" class="ferris-explain"/>    | This code does not compile!                      |
| <img src="img/ferris/panics.svg" class="ferris-explain"/>              | This code panics!                                |
| <img src="img/ferris/unsafe.svg" class="ferris-explain"/>              | This code block contains unsafe code.            |
| <img src="img/ferris/not_desired_behavior.svg" class="ferris-explain"/>| This code does not produce the desired behavior. |
-->
<table><thead><tr><th>Ferris</th><th>Signification</th></tr></thead><tbody>
<tr><td><img src="img/ferris/does_not_compile.svg" class="ferris-explain"/></td><td>Ce code ne compile pas !</td></tr>
<tr><td><img src="img/ferris/panics.svg" class="ferris-explain"/></td><td>Ce code panique !</td></tr>
<tr><td><img src="img/ferris/unsafe.svg" class="ferris-explain"/></td><td>Ce bloc de code contient du code non sécurisé.</td></tr>
<tr><td><img src="img/ferris/not_desired_behavior.svg" class="ferris-explain"/></td><td>Ce code ne se comporte pas comme voulu.</td></tr>
</tbody></table>
<!--
In most situations, we’ll lead you to the correct version of any code that
doesn’t compile.
-->
<p>Dans la plupart des cas, nous vous guiderons vers la version du code qui devrait
fonctionner.</p>
<!--
## Source Code
-->
<h2><a class="header" href="#code-source" id="code-source">Code source</a></h2>
<!--
The source files from which this book is generated can be found on
[GitHub][book].
-->
<p>Les fichiers du code source qui a généré ce livre en anglais sont disponibles
sur <a href="https://github.com/rust-lang/book/tree/master/src">GitHub</a>.</p>
<p>La version française est aussi disponible sur <a href="https://github.com/Jimskapt/rust-book-fr">GitHub</a>.</p>
<!--
# Getting Started
-->
<h1><a class="header" href="#prise-en-main" id="prise-en-main">Prise en main</a></h1>
<!--
Let’s start your Rust journey! There’s a lot to learn, but every journey starts
somewhere. In this chapter, we’ll discuss:
-->
<p>Démarrons notre périple avec Rust ! Il y a beaucoup à apprendre, mais chaque
aventure doit commencer quelque part. Dans ce chapitre, nous allons aborder :</p>
<!--
* Installing Rust on Linux, macOS, and Windows
* Writing a program that prints `Hello, world!`
* Using `cargo`, Rust’s package manager and build system
-->
<ul>
<li>L'installation de Rust sur Linux, macOS et Windows</li>
<li>L'écriture d'un programme qui affiche <code>Hello, world!</code></li>
<li>L'utilisation de <code>cargo</code>, le gestionnaire de paquets et système de compilation
de Rust</li>
</ul>
<!--
## Installation
-->
<h2><a class="header" href="#installation" id="installation">Installation</a></h2>
<!--
The first step is to install Rust. We’ll download Rust through `rustup`, a
command line tool for managing Rust versions and associated tools. You’ll need
an internet connection for the download.
-->
<p>La première étape consiste à installer Rust. Nous allons télécharger Rust via
<code>rustup</code>, un outil en ligne de commande conçu pour gérer les versions de Rust et
les outils qui leur sont associés. Vous allez avoir besoin d'une connexion
Internet pour le téléchargement.</p>
<!--
> Note: If you prefer not to use `rustup` for some reason, please see [the Rust
> installation page](https://www.rust-lang.org/tools/install) for other options.
-->
<blockquote>
<p>Note : si vous préférez ne pas utiliser <code>rustup</code> pour une raison ou une autre,
vous pouvez vous référer à
<a href="https://www.rust-lang.org/tools/install">la page d'installation de Rust</a>
pour d'autres méthodes d'installation.</p>
</blockquote>
<!--
The following steps install the latest stable version of the Rust compiler.
Rust’s stability guarantees ensure that all the examples in the book that
compile will continue to compile with newer Rust versions. The output might
differ slightly between versions, because Rust often improves error messages
and warnings. In other words, any newer, stable version of Rust you install
using these steps should work as expected with the content of this book.
-->
<p>L'étape suivante est d'installer la dernière version stable du compilateur Rust.
La garantie de stabilité de Rust assurera que tous les exemples dans le livre
qui se compilent bien vont continuer à se compiler avec les nouvelles versions
de Rust. La sortie peut varier légèrement d'une version à une autre, car Rust
améliore souvent les messages d'erreur et les avertissements. En résumé, toute
nouvelle version stable de Rust que vous installez de cette manière devrait
fonctionner en cohérence avec le contenu de ce livre.</p>
<!--
> ### Command Line Notation
>
> In this chapter and throughout the book, we’ll show some commands used in the
> terminal. Lines that you should enter in a terminal all start with `$`. You
> don’t need to type in the `$` character; it indicates the start of each
> command. Lines that don’t start with `$` typically show the output of the
> previous command. Additionally, PowerShell-specific examples will use `>`
> rather than `$`.
-->
<blockquote>
<h3><a class="header" href="#la-notation-en-ligne-de-commande" id="la-notation-en-ligne-de-commande">La notation en ligne de commande</a></h3>
<p>Dans ce chapitre et les suivants dans le livre, nous allons montrer quelques
commandes tapées dans le terminal. Les lignes que vous devrez écrire dans le
terminal commencent toutes par <code>$</code>. Vous n'avez pas besoin d'écrire le
caractère <code>$</code>; il marque le début de chaque commande. Les lignes qui ne
commencent pas par <code>$</code> montrent généralement le résultat de la commande
précédente. De plus, les exemples propres à PowerShell utiliseront
<code>&gt;</code> plutôt que <code>$</code>.</p>
</blockquote>
<!--
### Installing `rustup` on Linux or macOS
-->
<h3><a class="header" href="#installer-rustup-sur-linux-ou-macos" id="installer-rustup-sur-linux-ou-macos">Installer <code>rustup</code> sur Linux ou macOS</a></h3>
<!--
If you’re using Linux or macOS, open a terminal and enter the following command:
-->
<p>Si vous utilisez Linux ou macOS, ouvrez un terminal et écrivez la commande
suivante :</p>
<pre><code class="language-text">$ curl https://sh.rustup.rs -sSf | sh
</code></pre>
<!--
The command downloads a script and starts the installation of the `rustup`
tool, which installs the latest stable version of Rust. You might be prompted
for your password. If the install is successful, the following line will appear:
-->
<p>Cette commande télécharge un script et lance l'installation de l'outil <code>rustup</code>,
qui va installer la dernière version stable de Rust. Il est possible que l'on
vous demande votre mot de passe. Si l'installation se déroule bien, vous
devriez voir la ligne suivante s'afficher :</p>
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<!--
If you prefer, feel free to download the script and inspect it before running
it.
-->
<p>Si vous préférez, vous pouvez télécharger le script et l'examiner avant de le
lancer.</p>
<!--
The installation script automatically adds Rust to your system PATH after your
next login. If you want to start using Rust right away instead of restarting
your terminal, run the following command in your shell to add Rust to your
system PATH manually:
-->
<p>Le script d'installation va ajouter automatiquement Rust dans la variable
<em>PATH</em> de votre système après votre prochaine connexion utilisateur.
Si vous préférez utiliser Rust tout de suite au lieu de redémarrer votre
terminal, lancez la commande suivante dans votre terminal pour ajouter Rust dans
le <em>PATH</em> de votre système manuellement :</p>
<pre><code class="language-text">$ source $HOME/.cargo/env
</code></pre>
<!--
Alternatively, you can add the following line to your *~/.bash_profile*:
-->
<p>Vous pouvez aussi ajouter la ligne suivante dans votre <em>~/.bash_profile</em> :</p>
<pre><code class="language-text">$ export PATH=&quot;$HOME/.cargo/bin:$PATH&quot;
</code></pre>
<!--
Additionally, you’ll need a linker of some kind. It’s likely one is already
installed, but when you try to compile a Rust program and get errors indicating
that a linker could not execute, that means a linker isn’t installed on your
system and you’ll need to install one manually. C compilers usually come with
the correct linker. Check your platform’s documentation for how to install a C
compiler. Also, some common Rust packages depend on C code and will need a C
compiler. Therefore, it might be worth installing one now.
-->
<p>De plus, vous aurez peut-être besoin d'un <em>linker</em> quelconque. Il est probable
qu'il y en ait déjà un d'installé, mais si vous essayez de compiler un
programme Rust et que vous avez des erreurs qui disent que le <em>linker</em> ne peut
pas être exécuté, cela veut dire qu'il n'y a pas de <em>linker</em> d'installé sur
votre système et que vous devrez en installer un manuellement. Les
compilateurs C sont généralement livrés avec un bon <em>linker</em>. Référez-vous à la
documentation de votre plateforme pour savoir comment installer un compilateur
C. De plus, certains paquets Rust communs nécessitent du code C et auront
besoin d'un compilateur C. C'est pourquoi cela vaut la peine d'en installer un
dès maintenant.</p>
<!--
### Installing `rustup` on Windows
-->
<h3><a class="header" href="#installer-rustup-sous-windows" id="installer-rustup-sous-windows">Installer <code>rustup</code> sous Windows</a></h3>
<!--
On Windows, go to [https://www.rust-lang.org/tools/install][install] and follow
the instructions for installing Rust. At some point in the installation, you’ll
receive a message explaining that you’ll also need the C++ build tools for
Visual Studio 2013 or later. The easiest way to acquire the build tools is to
install [Build Tools for Visual Studio 2019][visualstudio]. The tools are in
the Other Tools and Frameworks section.
-->
<p>Sous Windows, il faut aller sur
<a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a> et suivre les instructions
pour installer Rust. À un moment donné durant l'installation, vous aurez un
message vous expliquant qu'il va vous falloir l'outil de compilation C++
pour Visual Studio 2013 ou plus récent. La méthode la plus facile pour obtenir
les outils de compilation est d'installer
<a href="https://www.visualstudio.com/fr/downloads/#build-tools-for-visual-studio-2019">Build Tools pour Visual Studio 2019</a>.</p>
<!--
[visualstudio]: https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2019
FR translation: the website redirects to French version, we lose the "id" link.
Fix is directly below:
-->
<!--
The rest of this book uses commands that work in both *cmd.exe* and PowerShell.
If there are specific differences, we’ll explain which to use.
-->
<p>La suite de ce livre utilisera des commandes qui fonctionnent à la fois dans
<em>cmd.exe</em> et PowerShell. S'il y a des différences particulières, nous vous
expliquerons lesquelles utiliser.</p>
<!--
### Updating and Uninstalling
-->
<h3><a class="header" href="#mettre-à-jour-et-désinstaller" id="mettre-à-jour-et-désinstaller">Mettre à jour et désinstaller</a></h3>
<!--
After you’ve installed Rust via `rustup`, updating to the latest version is
easy. From your shell, run the following update script:
-->
<p>Après avoir installé Rust avec <code>rustup</code>, la mise à jour vers la dernière version
est facile. Dans votre terminal, lancez le script de mise à jour suivant :</p>
<pre><code class="language-text">$ rustup update
</code></pre>
<!--
To uninstall Rust and `rustup`, run the following uninstall script from your
shell:
-->
<p>Pour désinstaller Rust et <code>rustup</code>, exécutez le script de désinstallation
suivant dans votre terminal :</p>
<pre><code class="language-text">$ rustup self uninstall
</code></pre>
<!--
### Troubleshooting
-->
<h3><a class="header" href="#dépannage" id="dépannage">Dépannage</a></h3>
<!--
To check whether you have Rust installed correctly, open a shell and enter this
line:
-->
<p>Pour vérifier si Rust est correctement installé, ouvrez un terminal et entrez
cette ligne :</p>
<pre><code class="language-text">$ rustc --version
</code></pre>
<!--
You should see the version number, commit hash, and commit date for the latest
stable version that has been released in the following format:
-->
<p>Vous devriez voir le numéro de version, le <em>hash</em> de <em>commit</em>,
et la date de <em>commit</em> de la dernière version stable qui a été publiée,
au format suivant :</p>
<pre><code class="language-text">rustc x.y.z (abcabcabc yyyy-mm-dd)
</code></pre>
<!--
If you see this information, you have installed Rust successfully! If you don’t
see this information and you’re on Windows, check that Rust is in your `%PATH%`
system variable. If that’s all correct and Rust still isn’t working, there are
a number of places you can get help. The easiest is the #beginners channel on
[the official Rust Discord][discord]. There, you can chat with other Rustaceans
(a silly nickname we call ourselves) who can help you out. Other great
resources include [the Users forum][users] and [Stack Overflow][stackoverflow].
-->
<p>Si vous voyez cette information, c'est que vous avez installé Rust avec succès !
Si vous ne voyez pas cette information et que vous êtes sous Windows, vérifiez
que Rust est présent dans votre variable d'environnement système <code>%PATH%</code>. Si
tout est correct et que Rust ne fonctionne toujours pas, il y a quelques
endroits où vous pourrez trouver de l'aide. Le plus accessible est le
canal #beginners sur le <a href="https://discord.gg/rust-lang">Discord officiel de Rust</a>. Là-bas, vous pouvez
dialoguer en ligne avec d'autres <em>Rustacés</em> (un surnom ridicule que nous nous
donnons entre nous) qui pourront vous aider. D'autres bonnes sources de données
sont <a href="https://users.rust-lang.org/">le forum d'utilisateurs</a> et <a href="http://stackoverflow.com/questions/tagged/rust">Stack Overflow</a>.</p>
<!--
### Local Documentation
-->
<h3><a class="header" href="#documentation-en-local" id="documentation-en-local">Documentation en local</a></h3>
<!--
The installer also includes a copy of the documentation locally, so you can
read it offline. Run `rustup doc` to open the local documentation in your
browser.
-->
<p>L'installateur embarque aussi une copie de la documentation en local pour que
vous puissiez la lire hors ligne. Lancez <code>rustup doc</code> afin
d'ouvrir la documentation locale dans votre navigateur.</p>
<!--
Any time a type or function is provided by the standard library and you’re not
sure what it does or how to use it, use the application programming interface
(API) documentation to find out!
-->
<p>À chaque fois que vous n'êtes pas sûr de ce que fait un type ou une fonction
fournie par la bibliothèque standard ou que vous ne savez pas comment
l'utiliser, utilisez cette documentation de l'interface de programmation
applicative <em>(API)</em> pour le savoir !</p>
<!--
## Hello, World!
-->
<h2><a class="header" href="#hello-world" id="hello-world">Hello, World!</a></h2>
<!--
Now that you’ve installed Rust, let’s write your first Rust program. It’s
traditional when learning a new language to write a little program that prints
the text `Hello, world!` to the screen, so we’ll do the same here!
-->
<p>Maintenant que vous avez installé Rust, écrivons notre premier programme Rust.
Lorsqu'on apprend un nouveau langage, il est de tradition d'écrire un petit
programme qui écrit le texte &quot;Hello, world!&quot; à l'écran, donc c'est ce que nous
allons faire !</p>
<!--
> Note: This book assumes basic familiarity with the command line. Rust makes
> no specific demands about your editing or tooling or where your code lives, so
> if you prefer to use an integrated development environment (IDE) instead of
> the command line, feel free to use your favorite IDE. Many IDEs now have some
> degree of Rust support; check the IDE’s documentation for details. Recently,
> the Rust team has been focusing on enabling great IDE support, and progress
> has been made rapidly on that front!
-->
<blockquote>
<p>Note : ce livre part du principe que vous êtes familier avec la ligne de
commande. Rust n'impose pas d'exigences sur votre éditeur, vos outils ou
l'endroit où vous mettez votre code, donc si vous préférez utiliser un
environnement de développement intégré (IDE) au lieu de la ligne de commande,
vous êtes libre d'utiliser votre IDE favori. De nombreux IDE prennent en
charge Rust à des degrés divers ; consultez la documentation de
l'IDE pour plus d'informations. Récemment, l'équipe Rust s'est attelée à
améliorer l'intégration dans les IDE et des progrès ont rapidement été faits
dans ce domaine !</p>
</blockquote>
<!--
### Creating a Project Directory
-->
<h3><a class="header" href="#créer-un-dossier-projet" id="créer-un-dossier-projet">Créer un dossier projet</a></h3>
<!--
You’ll start by making a directory to store your Rust code. It doesn’t matter
to Rust where your code lives, but for the exercises and projects in this book,
we suggest making a *projects* directory in your home directory and keeping all
your projects there.
-->
<p>Nous allons commencer par créer un dossier pour y ranger le code Rust. Là où
vous mettez votre code n'est pas important pour Rust, mais pour les exercices et
projets de ce livre, nous vous suggérons de créer un dossier <em>projects</em> dans
votre dossier utilisateur et de ranger tous vos projets là-dedans.</p>
<!--
Open a terminal and enter the following commands to make a *projects* directory
and a directory for the Hello, world! project within the *projects* directory.
-->
<p>Ouvrez un terminal et écrivez les commandes suivantes pour créer un
dossier <em>projects</em> et un dossier pour le projet <em>Hello, world!</em> à l'intérieur
de ce dossier <em>projects</em>.</p>
<!--
For Linux, macOS, and PowerShell on Windows, enter this:
-->
<p>Sous Linux, macOS et PowerShell sous Windows, écrivez ceci :</p>
<pre><code class="language-text">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<!--
For Windows CMD, enter this:
-->
<p>Avec CMD sous Windows, écrivez ceci :</p>
<pre><code class="language-cmd">&gt; mkdir &quot;%USERPROFILE%\projects&quot;
&gt; cd /d &quot;%USERPROFILE%\projects&quot;
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<!--
### Writing and Running a Rust Program
-->
<h3><a class="header" href="#Écrire-et-exécuter-un-programme-rust" id="Écrire-et-exécuter-un-programme-rust">Écrire et exécuter un programme Rust</a></h3>
<!--
Next, make a new source file and call it *main.rs*. Rust files always end with
the *.rs* extension. If you’re using more than one word in your filename, use
an underscore to separate them. For example, use *hello_world.rs* rather than
*helloworld.rs*.
-->
<p>Ensuite, créez un nouveau fichier source et appelez-le <em>main.rs</em>. Les fichiers
Rust se terminent toujours par l'extension <em>.rs</em>. Si vous utilisez plusieurs
mots dans votre nom de fichier, utilisez un tiret bas (<code>_</code>) pour
les séparer. Par exemple, vous devriez utiliser <em>hello_world.rs</em> au lieu de
<em>helloworld.rs</em>.</p>
<!--
Now open the *main.rs* file you just created and enter the code in Listing 1-1.
-->
<p>Maintenant, ouvrez le fichier <em>main.rs</em> que vous venez de créer et entrez le
code de l'encart 1-1.</p>
<!--
<span class="filename">Filename: main.rs</span>
-->
<p><span class="filename">Fichier : main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<!--
<span class="caption">Listing 1-1: A program that prints `Hello, world!`</span>
-->
<p><span class="caption">Encart 1-1 : Un programme qui affiche <code>Hello, world!</code>
</span></p>
<!--
Save the file and go back to your terminal window. On Linux or macOS, enter
the following commands to compile and run the file:
-->
<p>Enregistrez le fichier et retournez dans votre terminal. Sur Linux
ou macOS, écrivez les commandes suivantes pour compiler et exécuter le fichier :</p>
<pre><code class="language-text">$ rustc main.rs
$ ./main
Hello, world!
</code></pre>
<!--
On Windows, enter the command `.\main.exe` instead of `./main`:
-->
<p>Sur Windows, écrivez la commande <code>.\main.exe</code> à la place de <code>.\main</code> :</p>
<pre><code class="language-powershell">&gt; rustc main.rs
&gt; .\main.exe
Hello, world!
</code></pre>
<!--
Regardless of your operating system, the string `Hello, world!` should print to
the terminal. If you don’t see this output, refer back to the
[“Troubleshooting”][troubleshooting]<!-- ignore -- > part of the Installation
section for ways to get help.
-->
<p>Peu importe votre système d'exploitation, la chaîne de caractères
<code>Hello, world!</code> devrait s'écrire dans votre terminal. Si cela ne s'affiche pas,
référez-vous à la partie <a href="ch01-01-installation.html#troubleshooting">&quot;Dépannage&quot;</a><!-- ignore --> du
chapitre d'installation pour vous aider.</p>
<!--
If `Hello, world!` did print, congratulations! You’ve officially written a Rust
program. That makes you a Rust programmer—welcome!
-->
<p>Si <code>Hello, world!</code> s'affiche, félicitations ! Vous avez officiellement écrit un
programme Rust. Cela fait de vous un développeur Rust — bienvenue !</p>
<!--
### Anatomy of a Rust Program
-->
<h3><a class="header" href="#structure-dun-programme-rust" id="structure-dun-programme-rust">Structure d'un programme Rust</a></h3>
<!--
Let’s review in detail what just happened in your Hello, world! program.
Here’s the first piece of the puzzle:
-->
<p>Regardons en détail ce qui s'est passé dans votre programme <em>Hello, world!</em>.
Voici le premier morceau du puzzle :</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {

}
</code></pre></pre>
<!--
These lines define a function in Rust. The `main` function is special: it is
always the first code that runs in every executable Rust program. The first
line declares a function named `main` that has no parameters and returns
nothing. If there were parameters, they would go inside the parentheses, `()`.
-->
<p>Ces lignes définissent une fonction dans Rust. La fonction <code>main</code> est spéciale :
c'est toujours le premier code qui est exécuté dans tous les programmes
en Rust. La première ligne déclare une fonction qui s'appelle <code>main</code>, qui n'a
pas de paramètre et qui ne retourne aucune valeur. S'il y avait des paramètres,
ils seraient placés entre les parenthèses <code>()</code>.</p>
<!--
Also, note that the function body is wrapped in curly brackets, `{}`. Rust
requires these around all function bodies. It’s good style to place the opening
curly bracket on the same line as the function declaration, adding one space in
between.
-->
<p>À noter en outre que le corps de la fonction est placé entre des accolades
<code>{}</code>. Rust en a besoin autour du corps de chaque fonction. C'est une
bonne pratique d'insérer l'accolade ouvrante sur la même ligne que la
déclaration de la fonction, en ajoutant une espace entre les deux.</p>
<!--
At the time of this writing, an automatic formatter tool called `rustfmt` is
under development. If you want to stick to a standard style across Rust
projects, `rustfmt` will format your code in a particular style. The Rust team
plans to eventually include this tool with the standard Rust distribution, like
`rustc`. So depending on when you read this book, it might already be installed
on your computer! Check the online documentation for more details.
-->
<p>Pendant que nous écrivons ces lignes, un outil de formatage automatique de code
appelé <code>rustfmt</code> est en cours de développement.
Si vous voulez standardiser le style de votre code Rust dans vos projets,
<code>rustfmt</code> va formater votre code de manière bien définie.
L'équipe Rust envisage d'intégrer cet outil dans la distribution
standard de Rust, comme <code>rustc</code>. Donc, selon le moment où vous lirez ce livre,
il se peut qu'il soit déjà installé sur votre ordinateur ! Consultez la
documentation en ligne pour en savoir plus.</p>
<!--
Inside the `main` function is the following code:
-->
<p>À l'intérieur de la fonction <code>main</code>, nous avons le code suivant :</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    println!(&quot;Hello, world!&quot;);
#}</code></pre></pre>
<!--
This line does all the work in this little program: it prints text to the
screen. There are four important details to notice here. First, Rust style is
to indent with four spaces, not a tab.
-->
<p>Cette ligne fait tout le travail dans ce petit programme : il écrit le texte à
l'écran. Il y a quatre détails importants à noter ici. Premièrement, le style de
Rust est d'indenter avec quatre espaces, et non pas avec une tabulation.</p>
<!--
Second, `println!` calls a Rust macro. If it called a function instead, it
would be entered as `println` (without the `!`). We’ll discuss Rust macros in
more detail in Chapter 19. For now, you just need to know that using a `!`
means that you’re calling a macro instead of a normal function.
-->
<p>Deuxièmement, <code>println!</code> fait appel à une macro Rust. S'il appelait une
fonction à la place, cela serait écrit <code>println</code> (sans le <code>!</code>). Nous aborderons
les macros Rust plus en détail dans le chapitre 19. Pour l'instant, vous avez
juste à savoir qu'utiliser un <code>!</code> signifie que vous utilisez une macro plutôt
qu'une fonction classique.</p>
<!--
Third, you see the `"Hello, world!"` string. We pass this string as an argument
to `println!`, and the string is printed to the screen.
-->
<p>Troisièmement, vous voyez la chaîne de caractères <code>&quot;Hello, world!&quot;</code>. Nous
envoyons cette chaîne en argument à <code>println!</code> et cette chaîne est affichée
à l'écran.</p>
<!--
Fourth, we end the line with a semicolon (`;`), which indicates that this
expression is over and the next one is ready to begin. Most lines of Rust code
end with a semicolon.
-->
<p>Quatrièmement, nous terminons la ligne avec un point-virgule (<code>;</code>), qui indique
que cette expression est terminée et que la suivante est prête à commencer. La
plupart des lignes de Rust se terminent avec un point-virgule.</p>
<!--
### Compiling and Running Are Separate Steps
-->
<h3><a class="header" href="#la-compilation-et-lexécution-sont-des-étapes-séparées" id="la-compilation-et-lexécution-sont-des-étapes-séparées">La compilation et l'exécution sont des étapes séparées</a></h3>
<!--
You’ve just run a newly created program, so let’s examine each step in the
process.
-->
<p>Vous venez de lancer un nouveau programme fraîchement créé, donc penchons-nous
sur chaque étape du processus.</p>
<!--
Before running a Rust program, you must compile it using the Rust compiler by
entering the `rustc` command and passing it the name of your source file, like
this:
-->
<p>Avant de lancer un programme Rust, vous devez le compiler en utilisant le
compilateur Rust en entrant la commande <code>rustc</code> et en lui passant le nom de
votre fichier source, comme ceci :</p>
<pre><code class="language-text">$ rustc main.rs
</code></pre>
<!--
If you have a C or C++ background, you’ll notice that this is similar to `gcc`
or `clang`. After compiling successfully, Rust outputs a binary executable.
-->
<p>Si vous avez de l'expérience en C ou en C++, vous observerez des similarités
avec <code>gcc</code> ou <code>clang</code>.
Après avoir compilé avec succès, Rust produit un binaire exécutable.</p>
<!--
On Linux, macOS, and PowerShell on Windows, you can see the executable by
entering the `ls` command in your shell. On Linux and macOS, you’ll see two
files. With PowerShell on Windows, you’ll see the same three files that you
would see using CMD.
-->
<p>Avec Linux, macOS et PowerShell sous Windows, vous pouvez voir l'exécutable en
utilisant la commande <code>ls</code> dans votre terminal. Avec Linux et macOS,
vous devriez voir deux fichiers. Avec PowerShell sous Windows, vous devriez voir
les trois mêmes fichiers que vous verriez en utilisant CMD.</p>
<pre><code class="language-text">$ ls
main  main.rs
</code></pre>
<!--
With CMD on Windows, you would enter the following:
-->
<p>Avec CMD sous Windows, vous devez saisir la commande suivante :</p>
<!--
```cmd
> dir /B %= the /B option says to only show the file names =%
main.exe
main.pdb
main.rs
```
-->
<pre><code class="language-cmd">&gt; dir /B %= l'option /B demande à n'afficher que les noms de fichiers =%
main.exe
main.pdb
main.rs
</code></pre>
<!--
This shows the source code file with the *.rs* extension, the executable file
(*main.exe* on Windows, but *main* on all other platforms), and, when using
Windows, a file containing debugging information with the *.pdb* extension.
From here, you run the *main* or *main.exe* file, like this:
-->
<p>Ceci affiche le fichier de code source avec l'extension <em>.rs</em>, le fichier
exécutable (<em>main.exe</em> sous Windows, mais <em>main</em> sur toutes les autres
plateformes) et, quand on utilise Windows, un fichier qui contient des
informations de débogage avec l'extension <em>.pdb</em>. Dans ce dossier, vous pouvez
exécuter le fichier <em>main</em> ou <em>main.exe</em> comme ceci :</p>
<!--
```text
$ ./main # or .\main.exe on Windows
```
-->
<pre><code class="language-text">$ ./main # ou .\main.exe sous Windows
</code></pre>
<!--
If *main.rs* was your Hello, world! program, this line would print `Hello,
world!` to your terminal.
-->
<p>Si <em>main.rs</em> était votre programme <em>Hello, world!</em>, cette ligne devrait afficher
<code>Hello, world!</code> dans votre terminal.</p>
<!--
If you’re more familiar with a dynamic language, such as Ruby, Python, or
JavaScript, you might not be used to compiling and running a program as
separate steps. Rust is an *ahead-of-time compiled* language, meaning you can
compile a program and give the executable to someone else, and they can run it
even without having Rust installed. If you give someone a *.rb*, *.py*, or
*.js* file, they need to have a Ruby, Python, or JavaScript implementation
installed (respectively). But in those languages, you only need one command to
compile and run your program. Everything is a trade-off in language design.
-->
<p>Si vous connaissez un langage dynamique, comme Ruby, Python, ou JavaScript, vous
n'avez peut-être pas l'habitude de compiler puis lancer votre programme dans des
étapes séparées.
Rust est un langage à <em>compilation anticipée</em>, ce qui veut dire que
vous pouvez compiler le programme et le donner à quelqu'un d'autre, et il peut
l'exécuter sans avoir Rust d'installé. Si vous donnez à quelqu'un un fichier
<em>.rb</em>, <em>.py</em> ou <em>.js</em>, il a besoin d'avoir respectivement un interpréteur Ruby,
Python, ou Javascript d'installé. Cependant, avec ces langages, vous n'avez
besoin que d'une seule commande pour compiler et exécuter votre programme.
Dans la conception d'un langage, tout est une question de compromis.</p>
<!--
Just compiling with `rustc` is fine for simple programs, but as your project
grows, you’ll want to manage all the options and make it easy to share your
code. Next, we’ll introduce you to the Cargo tool, which will help you write
real-world Rust programs.
-->
<p>Compiler avec <code>rustc</code> peut suffire pour de petits programmes, mais au fur et à
mesure que votre programme grandit, vous allez avoir besoin de régler plus
d'options et faciliter le partage de votre code. À la page suivante, nous allons
découvrir l'outil Cargo, qui va vous aider à écrire des programmes Rust à
l'épreuve de la réalité.</p>
<!--
## Hello, Cargo!
-->
<h2><a class="header" href="#hello-cargo" id="hello-cargo">Hello, Cargo!</a></h2>
<!--
Cargo is Rust’s build system and package manager. Most Rustaceans use this tool
to manage their Rust projects because Cargo handles a lot of tasks for you,
such as building your code, downloading the libraries your code depends on, and
building those libraries. (We call libraries your code needs *dependencies*.)
-->
<p>Cargo est le système de compilation et de gestion de paquets de Rust. La plupart
des Rustacés utilisent cet outil pour gérer les projets Rust, car Cargo
s'occupe de nombreuses tâches pour vous, comme compiler votre code, télécharger
les bibliothèques dont votre code dépend, et compiler ces bibliothèques. (On
appelle <em>dépendance</em> une bibliothèque nécessaire pour votre code.)</p>
<!--
The simplest Rust programs, like the one we’ve written so far, don’t have any
dependencies. So if we had built the Hello, world! project with Cargo, it would
only use the part of Cargo that handles building your code. As you write more
complex Rust programs, you’ll add dependencies, and if you start a project
using Cargo, adding dependencies will be much easier to do.
-->
<p>Des programmes Rust très simples, comme le petit que nous avons précédemment,
n'ont pas de dépendance. Donc si nous avions compilé le projet <em>Hello, world!</em>
avec Cargo, cela n'aurait fait appel qu'à la fonctionnalité de Cargo qui
s'occupe de la compilation de votre code. Quand vous écrirez des programmes Rust
plus complexes, vous ajouterez des dépendances, et si vous créez un projet en
utilisant Cargo, l'ajout des dépendances sera plus facile à faire.</p>
<!--
Because the vast majority of Rust projects use Cargo, the rest of this book
assumes that you’re using Cargo too. Cargo comes installed with Rust if you
used the official installers discussed in the
[“Installation”][installation]<!-- ignore -- > section. If you installed Rust
through some other means, check whether Cargo is installed by entering the
following into your terminal:
-->
<p>Comme la large majorité des projets Rust utilisent Cargo, la suite de ce livre
va supposer que vous utilisez aussi Cargo. Cargo s'installe avec Rust si vous
avez utilisé l'installateur officiel présenté dans la section
<a href="ch01-01-installation.html#installation">“Installation”</a><!-- ignore -->. Si vous avez installé Rust
autrement, vérifiez que Cargo est installé en utilisant la commande suivante
dans votre terminal :</p>
<pre><code class="language-text">$ cargo --version
</code></pre>
<!--
If you see a version number, you have it! If you see an error, such as `command
not found`, look at the documentation for your method of installation to
determine how to install Cargo separately.
-->
<p>Si vous voyez un numéro de version, c'est qu'il est installé ! Si vous voyez une
erreur comme <code>Commande non trouvée</code> (ou <code>command not found</code>), alors consultez la
documentation de votre méthode d'installation pour savoir comment installer
séparément Cargo.</p>
<!--
### Creating a Project with Cargo
-->
<h3><a class="header" href="#créer-un-projet-avec-cargo" id="créer-un-projet-avec-cargo">Créer un projet avec Cargo</a></h3>
<!--
Let’s create a new project using Cargo and look at how it differs from our
original Hello, world! project. Navigate back to your *projects* directory (or
wherever you decided to store your code). Then, on any operating system, run
the following:
-->
<p>Créons un nouveau projet en utilisant Cargo et analysons les différences avec
notre projet initial <em>Hello, world!</em>. Retournez dans votre dossier <em>projects</em>
(ou là où vous avez décidé d'enregistrer votre code). Ensuite, sur n'importe
quel système d'exploitation, lancez les commandes suivantes :</p>
<pre><code class="language-text">$ cargo new hello_cargo
$ cd hello_cargo
</code></pre>
<!--
The first command creates a new directory called *hello_cargo*. We’ve named
our project *hello_cargo*, and Cargo creates its files in a directory of the
same name.
-->
<p>La première commande crée un nouveau dossier appelé <em>hello_cargo</em>. Nous avons
appelé notre projet <em>hello_cargo</em>, et Cargo crée ses fichiers dans un dossier
avec le même nom.</p>
<!--
Go into the *hello_cargo* directory and list the files. You’ll see that Cargo
has generated two files and one directory for us: a *Cargo.toml* file and a
*src* directory with a *main.rs* file inside. It has also initialized a new Git
repository along with a *.gitignore* file.
-->
<p>Rendez-vous dans le dossier <em>hello_cargo</em> et afficher la liste des fichiers.
Vous constaterez que Cargo a généré deux fichiers et un dossier pour nous : un
fichier <em>Cargo.toml</em> et un dossier <em>src</em> avec un fichier <em>main.rs</em> à
l'intérieur. Il a aussi créé un nouveau dépôt Git ainsi qu'un fichier
<em>.gitignore</em>.</p>
<!--
> Note: Git is a common version control system. You can change `cargo new` to
> use a different version control system or no version control system by using
> the `--vcs` flag. Run `cargo new --help` to see the available options.
-->
<blockquote>
<p>Note : Git est un système de gestion de versions très répandu. Vous pouvez
changer <code>cargo new</code> pour utiliser un autre système de gestion de versions
ou ne pas en utiliser du tout en écrivant le drapeau <code>--vcs</code>.
Lancez <code>cargo new --help</code> pour en savoir plus sur les options disponibles.</p>
</blockquote>
<!--
Open *Cargo.toml* in your text editor of choice. It should look similar to the
code in Listing 1-2.
-->
<p>Ouvrez <em>Cargo.toml</em> dans votre éditeur de texte favori. Son contenu devrait
être similaire au code dans l'encart 1-2.</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">Fichier : Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;hello_cargo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
edition = &quot;2018&quot;

[dependencies]
</code></pre>
<!--
<span class="caption">Listing 1-2: Contents of *Cargo.toml* generated by `cargo
new`</span>
-->
<p><span class="caption">Encart 1-2 : Contenu de <em>Cargo.toml</em> généré par <code>cargo new</code></span></p>
<!--
This file is in the [*TOML*][toml]<!-- ignore -- > (*Tom’s Obvious, Minimal
Language*) format, which is Cargo’s configuration format.
-->
<p>Ce fichier est au format <a href="https://github.com/toml-lang/toml"><em>TOML</em></a><!-- ignore --> (<em>Tom’s Obvious, Minimal
Language</em>), qui est le format de configuration de Cargo.</p>
<!--
The first line, `[package]`, is a section heading that indicates that the
following statements are configuring a package. As we add more information to
this file, we’ll add other sections.
-->
<p>La première ligne, <code>[package]</code>, est un en-tête de section qui indique que les
instructions suivantes configurent un paquet. Au fur et à mesure que nous
ajouterons plus de détails à ce fichier, nous ajouterons des sections
supplémentaires.</p>
<!--
The next four lines set the configuration information Cargo needs to compile
your program: the name, the version, who wrote it, and the edition of Rust to
use. Cargo gets your name and email information from your environment, so if
that information is not correct, fix the information now and then save the
file. We’ll talk about the `edition` key in Appendix E.
-->
<p>Les quatre lignes suivantes définissent les informations de configuration dont
Cargo a besoin pour compiler votre programme : le nom, la version, l'auteur et
l'édition de Rust à utiliser. Cargo récupère votre nom et votre courriel à
partir de votre environnement, donc si ces informations sont erronées, vous
pouvez les corriger dès maintenant et ensuite enregistrer le fichier. Nous
aborderons la clé <code>edition</code> dans l'annexe E.</p>
<!--
The last line, `[dependencies]`, is the start of a section for you to list any
of your project’s dependencies. In Rust, packages of code are referred to as
*crates*. We won’t need any other crates for this project, but we will in the
first project in Chapter 2, so we’ll use this dependencies section then.
-->
<p>La dernière ligne, <code>[dependencies]</code>, est le début d'une section qui vous permet
de lister les dépendances de votre projet. Dans Rust, les paquets de code sont
désignés sous le nom de <em>crates</em>. Nous n'allons pas utiliser de <em>crate</em> pour ce
projet, mais nous le ferons pour le premier projet au chapitre 2 ; nous
utiliserons alors cette section à ce moment-là.</p>
<!--
Now open *src/main.rs* and take a look:
-->
<p>Maintenant, ouvrez <em>src/main.rs</em> et jetez-y un coup d'œil :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<!--
Cargo has generated a Hello, world! program for you, just like the one we wrote
in Listing 1-1! So far, the differences between our previous project and the
project Cargo generates are that Cargo placed the code in the *src* directory,
and we have a *Cargo.toml* configuration file in the top directory.
-->
<p>Cargo a généré un programme <em>Hello, world!</em> pour vous, exactement comme celui
que nous avons écrit dans l'encart 1-1 ! Pour le moment, les seules différences
entre notre projet précédent et le projet que Cargo a généré sont que Cargo a
placé le code dans le dossier <em>src</em>, et que nous avons un fichier de
configuration <em>Cargo.toml</em> à la racine du dossier projet.</p>
<!--
Cargo expects your source files to live inside the *src* directory. The
top-level project directory is just for README files, license information,
configuration files, and anything else not related to your code. Using Cargo
helps you organize your projects. There’s a place for everything, and
everything is in its place.
-->
<p>Cargo prévoit de stocker vos fichiers sources dans le dossier <em>src</em>. Le dossier
parent est là uniquement pour les fichiers README, pour les informations à
propos de la licence, pour les fichiers de configuration et tout ce qui n'est
pas directement relié à votre code. Utiliser Cargo vous aide à structurer vos
projets. Il y a un endroit pour tout, et tout est à sa place.</p>
<!--
If you started a project that doesn’t use Cargo, as we did with the Hello,
world! project, you can convert it to a project that does use Cargo. Move the
project code into the *src* directory and create an appropriate *Cargo.toml*
file.
-->
<p>Si vous commencez un projet sans utiliser Cargo, comme nous l'avons fait avec
le projet <em>Hello, world!</em>, vous pouvez le transformer en projet qui
utilise Cargo. Déplacez le code de votre projet dans un dossier <em>src</em> et créez
un fichier <em>Cargo.toml</em> adéquat.</p>
<!--
### Building and Running a Cargo Project
-->
<h3><a class="header" href="#compiler-et-exécuter-un-projet-cargo" id="compiler-et-exécuter-un-projet-cargo">Compiler et exécuter un projet Cargo</a></h3>
<!--
Now let’s look at what’s different when we build and run the Hello, world!
program with Cargo! From your *hello_cargo* directory, build your project by
entering the following command:
-->
<p>Maintenant, regardons ce qu'il y a de différent quand nous compilons et
exécutons le programme <em>Hello, world!</em> avec Cargo ! À l'intérieur de votre
dossier <em>hello_cargo</em>, compilez votre projet en utilisant la commande suivante :</p>
<pre><code class="language-text">$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
</code></pre>
<!--
This command creates an executable file in *target/debug/hello_cargo* (or
*target\debug\hello_cargo.exe* on Windows) rather than in your current
directory. You can run the executable with this command:
-->
<p>Cette commande crée un fichier exécutable dans <em>target/debug/hello_cargo</em> (ou
<em>target\debug\hello_cargo.exe</em> sous Windows) plutôt que de le déposer dans votre
dossier courant. Vous pouvez lancer l'exécutable avec cette commande :</p>
<!--
```text
$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
Hello, world!
```
-->
<pre><code class="language-text">$ ./target/debug/hello_cargo # ou .\target\debug\hello_cargo.exe sous Windows
Hello, world!
</code></pre>
<!--
If all goes well, `Hello, world!` should print to the terminal. Running `cargo
build` for the first time also causes Cargo to create a new file at the top
level: *Cargo.lock*. This file keeps track of the exact versions of
dependencies in your project. This project doesn’t have dependencies, so the
file is a bit sparse. You won’t ever need to change this file manually; Cargo
manages its contents for you.
-->
<p>Si tout s'est bien passé, <code>Hello, world!</code> devrait s'afficher dans le terminal.
Lancer <code>cargo build</code> pour la première fois devrait aussi mener Cargo à créer
un nouveau fichier à la racine du dossier projet : <em>Cargo.lock</em>. Ce fichier
garde une trace des versions exactes des dépendances de votre
projet. Ce projet n'a pas de dépendance, donc le fichier est un peu vide. Vous
n'aurez jamais besoin de changer ce fichier manuellement ; Cargo va gérer son
contenu pour vous.</p>
<!--
We just built a project with `cargo build` and ran it with
`./target/debug/hello_cargo`, but we can also use `cargo run` to compile the
code and then run the resulting executable all in one command:
-->
<p>Nous venons de compiler un projet avec <code>cargo build</code> avant de l'exécuter avec
<code>./target/debug/hello_cargo</code>, mais nous pouvons aussi utiliser <code>cargo run</code> pour
compiler le code et ensuite lancer l'exécutable dans une seule et même
commande :</p>
<pre><code class="language-text">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<!--
Notice that this time we didn’t see output indicating that Cargo was compiling
`hello_cargo`. Cargo figured out that the files hadn’t changed, so it just ran
the binary. If you had modified your source code, Cargo would have rebuilt the
project before running it, and you would have seen this output:
-->
<p>Notez que cette fois-ci, nous ne voyons pas de messages indiquant que Cargo a
compilé <code>hello_cargo</code>. Cargo a détecté que les fichiers n'avaient pas changé,
donc il a juste exécuté le binaire. Si vous aviez modifié votre code source,
Cargo aurait recompilé le projet avant de le lancer, et vous auriez eu les
messages suivants :</p>
<pre><code class="language-text">$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<!--
Cargo also provides a command called `cargo check`. This command quickly checks
your code to make sure it compiles but doesn’t produce an executable:
-->
<p>Cargo fournit aussi une commande appelée <code>cargo check</code>. Elle vérifie rapidement
votre code pour s'assurer qu'il est compilable, mais ne produit pas
d'exécutable :</p>
<pre><code class="language-text">$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
<!--
Why would you not want an executable? Often, `cargo check` is much faster than
`cargo build`, because it skips the step of producing an executable. If you’re
continually checking your work while writing the code, using `cargo check` will
speed up the process! As such, many Rustaceans run `cargo check` periodically
as they write their program to make sure it compiles. Then they run `cargo
build` when they’re ready to use the executable.
-->
<p>Dans quel cas n'aurions-nous pas besoin d'un exécutable ? Parfois, <code>cargo check</code>
est bien plus rapide que <code>cargo build</code>, car il saute l'étape de création de
l'exécutable. Si vous vérifiez votre travail continuellement pendant que vous
écrivez votre code, utiliser <code>cargo check</code> accélèrera le processus ! C'est
pourquoi de nombreux Rustacés utilisent périodiquement <code>cargo check</code> quand ils
écrivent leur programme afin de s'assurer qu'il compile. Ensuite, ils lancent
<code>cargo build</code> quand ils sont prêts à utiliser l'exécutable.</p>
<!--
Let’s recap what we’ve learned so far about Cargo:
-->
<p>Récapitulons ce que nous avons appris sur Cargo :</p>
<!--
* We can build a project using `cargo build` or `cargo check`.
* We can build and run a project in one step using `cargo run`.
* Instead of saving the result of the build in the same directory as our code,
  Cargo stores it in the *target/debug* directory.
-->
<ul>
<li>Nous pouvons compiler un projet en utilisant <code>cargo build</code> ou <code>cargo check</code></li>
<li>Nous pouvons compiler puis exécuter un projet en une seule fois en utilisant
<code>cargo run</code>.</li>
<li>Au lieu d'enregistrer le résultat de la compilation dans le même dossier que
votre code, Cargo l'enregistre dans le dossier <em>target/debug</em>.</li>
</ul>
<!--
An additional advantage of using Cargo is that the commands are the same no
matter which operating system you’re working on. So, at this point, we’ll no
longer provide specific instructions for Linux and macOS versus Windows.
-->
<p>Un autre avantage d'utiliser Cargo est que les commandes sont les mêmes peu
importe le système d'exploitation que vous utilisez.
Donc à partir de maintenant, nous n'allons plus faire d'opérations spécifiques
à Linux et macOS par rapport à Windows.</p>
<!--
### Building for Release
-->
<h3><a class="header" href="#compiler-pour-diffuser" id="compiler-pour-diffuser">Compiler pour diffuser</a></h3>
<!--
When your project is finally ready for release, you can use `cargo build
--release` to compile it with optimizations. This command will create an
executable in *target/release* instead of *target/debug*. The optimizations
make your Rust code run faster, but turning them on lengthens the time it takes
for your program to compile. This is why there are two different profiles: one
for development, when you want to rebuild quickly and often, and another for
building the final program you’ll give to a user that won’t be rebuilt
repeatedly and that will run as fast as possible. If you’re benchmarking your
code’s running time, be sure to run `cargo build --release` and benchmark with
the executable in *target/release*.
-->
<p>Quand votre projet est finalement prêt à être diffusé, vous pouvez utiliser
<code>cargo build --release</code> pour le compiler en l'optimisant. Cette commande va
créer un exécutable dans <em>target/release</em> au lieu de <em>target/debug</em>. Ces
optimisations rendent votre code Rust plus rapide à exécuter, mais l'utiliser
rallonge le temps de compilation de votre programme. C'est pourquoi il y a deux
différents profils : un pour le développement, quand vous voulez recompiler
rapidement et souvent, et un autre pour compiler le programme final qui sera
livré à un utilisateur, qui n'aura pas besoin d'être recompilé à plusieurs
reprises et qui s'exécutera aussi vite que possible. Si vous évaluez le temps
d'exécution de votre code, assurez-vous de lancer <code>cargo build --release</code> et
d'utiliser l'exécutable dans <em>target/release</em> pour vos bancs de test.</p>
<!--
### Cargo as Convention
-->
<h3><a class="header" href="#cargo-comme-convention" id="cargo-comme-convention">Cargo comme convention</a></h3>
<!--
With simple projects, Cargo doesn’t provide a lot of value over just using
`rustc`, but it will prove its worth as your programs become more intricate.
With complex projects composed of multiple crates, it’s much easier to let
Cargo coordinate the build.
-->
<p>Pour des projets simples, Cargo n'apporte pas grand-chose par rapport à <code>rustc</code>,
mais il vous montrera son intérêt au fur et à mesure
que vos programmes deviendront plus complexes. Avec des projets complexes
composés de plusieurs <em>crates</em>, il est plus facile de laisser Cargo prendre en
charge la coordination de la compilation.</p>
<!--
Even though the `hello_cargo` project is simple, it now uses much of the real
tooling you’ll use in the rest of your Rust career. In fact, to work on any
existing projects, you can use the following commands to check out the code
using Git, change to that project’s directory, and build:
-->
<p>Même si le projet <code>hello_cargo</code> est simple, il utilise maintenant une grande
partie de l'outillage que vous rencontrerez dans votre carrière avec Rust. En
effet, pour travailler sur n'importe quel projet Rust existant, vous n'avez
qu'à saisir les commandes suivantes pour télécharger le code avec Git, vous
déplacer dans le dossier projet et compiler :</p>
<!--
```text
$ git clone someurl.com/someproject
$ cd someproject
$ cargo build
```
-->
<pre><code class="language-text">$ git clone example.com/projet_quelconque
$ cd projet_quelconque
$ cargo build
</code></pre>
<!--
For more information about Cargo, check out [its documentation].
-->
<p>Pour plus d'informations à propos de Cargo, vous pouvez consulter <a href="https://doc.rust-lang.org/cargo/">sa
documentation</a>.</p>
<!--
## Summary
-->
<h2><a class="header" href="#résumé" id="résumé">Résumé</a></h2>
<!--
You’re already off to a great start on your Rust journey! In this chapter,
you’ve learned how to:
-->
<p>Vous êtes déjà bien lancé dans votre périple avec Rust ! Dans ce chapitre, vous
avez appris comment :</p>
<!--
* Install the latest stable version of Rust using `rustup`
* Update to a newer Rust version
* Open locally installed documentation
* Write and run a Hello, world! program using `rustc` directly
* Create and run a new project using the conventions of Cargo
-->
<ul>
<li>Installer la dernière version stable de Rust en utilisant <code>rustup</code></li>
<li>Mettre à jour Rust vers une nouvelle version</li>
<li>Ouvrir la documentation installée en local</li>
<li>Écrire et exécuter un programme <em>Hello, world!</em> en utilisant directement
<code>rustc</code></li>
<li>Créer et exécuter un nouveau projet en utilisant les conventions de Cargo</li>
</ul>
<!--
This is a great time to build a more substantial program to get used to reading
and writing Rust code. So, in Chapter 2, we’ll build a guessing game program.
If you would rather start by learning how common programming concepts work in
Rust, see Chapter 3 and then return to Chapter 2.
-->
<p>C'est le moment idéal pour construire un programme plus ambitieux pour
s'habituer à lire et écrire du code Rust. Donc, au chapitre 2, nous allons
écrire un programme de <em>jeu de devinettes</em>.
Si vous préférez commencer par apprendre comment les principes de programmation
de base fonctionnent avec Rust, rendez-vous au chapitre 3, puis revenez au
chapitre 2.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../ferris.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
