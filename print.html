<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Le langage de programmation Rust</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../ferris.css">
        
        <link rel="stylesheet" href="../theme/2018-edition.css">
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="affix"><a href="title-page.html">Le langage de programmation Rust</a></li><li class="affix"><a href="foreword.html">Avant-propos</a></li><li class="affix"><a href="ch00-00-introduction.html">Introduction</a></li><li class="affix"><a href="translation-terms.html">Traduction des termes</a></li><li><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer un jeu de devinettes</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilité</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de données</a></li></ol></li><li><strong aria-hidden="true">4.</strong> Understanding Ownership</li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des données apparentées</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Le langage de programmation Rust</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
# The Rust Programming Language
-->
<h1><a class="header" href="#le-langage-de-programmation-rust" id="le-langage-de-programmation-rust">Le langage de programmation Rust</a></h1>
<!--
*by Steve Klabnik and Carol Nichols, with contributions from the Rust Community*
-->
<p><em>par Steve Klabnik et Carol Nichols, avec la participation de la Communauté
Rust</em></p>
<!--
This version of the text assumes you’re using Rust 1.31.0 or later with
`edition="2018"` in *Cargo.toml* of all projects to use Rust 2018 Edition
idioms. See the [“Installation” section of Chapter 1][install]<!-- ignore -- >
to install or update Rust, and see the new [Appendix E][editions]<!-- ignore
-- > for information on editions.
-->
<p>Cette version du document suppose que vous utilisez Rust 1.31.0 ou ultérieur
avec <code>edition=&quot;2018&quot;</code> dans <em>Cargo.toml</em> de tous les projets afin d'utiliser les
expressions idiomatiques de l'édition 2018 de Rust.
Voir la <a href="ch01-01-installation.html">section “Installation” du chapitre 1</a><!-- ignore -->
pour installer ou mettre à jour Rust, et
voir la nouvelle <a href="appendix-05-editions.html">annexe E</a><!-- ignore --> pour plus d'informations
sur les éditions.</p>
<!--
The 2018 Edition of the Rust language includes a number of improvements that
make Rust more ergonomic and easier to learn. This iteration of the book
contains a number of changes to reflect those improvements:
-->
<p>L'édition 2018 du langage Rust apporte quelques améliorations qui rendent Rust
plus ergonomique et plus facile à apprendre. Cette version du livre comprend un
certain nombre de changements pour refléter ces améliorations :</p>
<!--
- Chapter 7, “Managing Growing Projects with Packages, Crates, and Modules,”
  has been mostly rewritten. The module system and the way paths work in the
  2018 Edition were made more consistent.
- Chapter 10 has new sections titled “Traits as Parameters” and “Returning
  Types that Implement Traits” that explain the new `impl Trait` syntax.
- Chapter 11 has a new section titled “Using `Result<T, E>` in Tests” that
  shows how to write tests that use the `?` operator.
- The “Advanced Lifetimes” section in Chapter 19 was removed because compiler
  improvements have made the constructs in that section even rarer.
- The previous Appendix D, “Macros,” has been expanded to include procedural
  macros and was moved to the “Macros” section in Chapter 19.
- Appendix A, “Keywords,” also explains the new raw identifiers feature that
  enables code written in the 2015 Edition and the 2018 Edition to interoperate.
- Appendix D is now titled “Useful Development Tools” and covers recently
  released tools that help you write Rust code.
- We fixed a number of small errors and imprecise wording throughout the book.
  Thank you to the readers who reported them!
-->
<ul>
<li>Le chapitre 7 a été réécrit en grande partie. Le système de modules et le
fonctionnement des chemins dans l'édition 2018 ont été rendus plus cohérents.</li>
<li>Le chapitre 10 a deux nouvelles parties qui expliquent la nouvelle syntaxe
<code>impl Trait</code>.</li>
<li>Le chapitre 11 a une nouvelle partie qui montre comment écrire des tests qui
utilisent l'opérateur <code>?</code>.</li>
<li>La partie &quot;Durée de vie avancée&quot; du chapitre 19 a été retirée, car les
améliorations du compilateur ont rendu encore plus rare les concepts de cette
section.</li>
<li>L'ancienne Annexe D a été complétée pour couvrir les macros procédurales et a
été déplacée dans la section &quot;Macros&quot; du chapitre 19.</li>
<li>L'annexe A explique aussi la nouvelle fonctionnalité d'identificateurs bruts
qui rend du code écrit avec l'édition 2015 interopérable avec l'édition 2018.</li>
<li>L'annexe D a été renommée et couvre les nouveaux outils ajoutés récemment
pour vous aider à écrire du code Rust.</li>
<li>Nous avons corrigé quelques petites erreurs et certaines formulations floues
dans tout le livre. Merci aux lecteurs qui nous les ont signalées !</li>
</ul>
<!--
Note that any code in earlier iterations of *The Rust Programming Language*
that compiled will continue to compile without `edition="2018"` in the
project’s *Cargo.toml*, even as you update the Rust compiler version you’re
using. That’s Rust’s backward compatibility guarantees at work!
-->
<p>Veuillez noter que tout le code dans les versions précédentes du livre
<em>Le langage de programmation Rust</em> qui se compilait va continuer à compiler sans
<code>edition=&quot;2018&quot;</code> dans le <em>Cargo.toml</em> du projet, même si vous mettez à jour le
compilateur Rust que vous utilisez. C'est la garantie de la rétrocompatibilité
de Rust qui est à l'œuvre ici !</p>
<!--
The HTML format is available online at
[https://doc.rust-lang.org/stable/book/](https://doc.rust-lang.org/stable/book/)
and offline with installations of Rust made with `rustup`; run `rustup docs
--book` to open.
-->
<p>Le format HTML de la version anglaise est disponible en ligne à l'adresse
<a href="https://doc.rust-lang.org/stable/book/">https://doc.rust-lang.org/stable/book/</a>
et en hors-ligne avec l'installation de Rust qui a été effectuée avec <code>rustup</code> ;
vous pouvez lancer <code>rustup docs --book</code> pour l'ouvrir.</p>
<!--
This text is available in [paperback and ebook format from No Starch
Press][nsprust].
-->
<p>La version anglaise de ce livre est disponible
<a href="https://nostarch.com/rust">au format papier et e-book chez No Starch Press</a>.</p>
<!--
# Foreword
-->
<h1><a class="header" href="#avant-propos" id="avant-propos">Avant-propos</a></h1>
<!--
It wasn’t always so clear, but the Rust programming language is fundamentally
about *empowerment*: no matter what kind of code you are writing now, Rust
empowers you to reach farther, to program with confidence in a wider variety of
domains than you did before.
-->
<p>Cela n'a pas toujours été aussi évident, mais le langage de programmation Rust
apporte avant tout plus de <em>puissance</em> : peu importe le type de code que vous
écrivez en ce moment, Rust vous permet d'aller plus loin et de
programmer en toute confiance dans une plus grande diversité de domaines
qu'auparavant.</p>
<!--
Take, for example, “systems-level” work that deals with low-level details of
memory management, data representation, and concurrency. Traditionally, this
realm of programming is seen as arcane, accessible only to a select few who
have devoted the necessary years learning to avoid its infamous pitfalls. And
even those who practice it do so with caution, lest their code be open to
exploits, crashes, or corruption.
-->
<p>Prenez par exemple la gestion des éléments au “niveau système” qui traite de
détails bas niveau de gestion de mémoire, de modèles de données, et de
concurrence. Traditionnellement, ce domaine de la programmation est jugé
ésotérique, compréhensible uniquement par une poignée de personnes qui ont
consacré des années d'apprentissage à en déjouer les pièges infâmes.
Et même ceux qui travaillent dans ce domaine le font avec beaucoup de prudence,
de crainte que leur code soit soumis à des failles ou des plantages,
ou qu'il soit corrompu.</p>
<!--
Rust breaks down these barriers by eliminating the old pitfalls and providing a
friendly, polished set of tools to help you along the way. Programmers who need
to “dip down” into lower-level control can do so with Rust, without taking on
the customary risk of crashes or security holes, and without having to learn
the fine points of a fickle toolchain. Better yet, the language is designed to
guide you naturally towards reliable code that is efficient in terms of speed
and memory usage.
-->
<p>Rust fait tomber ces obstacles en éliminant les vieux pièges et en apportant un
ensemble d'outils soignés et conviviaux pour vous aider sur votre chemin.
Les développeurs qui ont besoin de &quot;se plonger&quot; dans le contrôle de plus
bas niveau peuvent ainsi le faire avec Rust, sans prendre le risque habituel
de plantages ou de failles de sécurité, et sans avoir à apprendre les subtilités
d'un enchevêtrement d'outils capricieux. Encore mieux, le langage est conçu pour
vous guider naturellement vers un code fiable et efficace en termes de rapidité
d'exécution et d'utilisation de la mémoire.</p>
<!--
Programmers who are already working with low-level code can use Rust to raise
their ambitions. For example, introducing parallelism in Rust is a relatively
low-risk operation: the compiler will catch the classical mistakes for you. And
you can tackle more aggressive optimizations in your code with the confidence
that you won’t accidentally introduce crashes or vulnerabilities.
-->
<p>Les développeurs qui travaillent déjà avec du code bas niveau peuvent utiliser
Rust pour accroître leurs ambitions. Par exemple, introduire du parallélisme en
Rust est une opération à faible risque : le compilateur va détecter les erreurs
classiques pour vous. Et vous pourrez vous lancer dans des améliorations plus
agressives de votre code avec la certitude que vous n'introduirez pas
accidentellement des causes de plantage ou des vulnérabilités.</p>
<!--
But Rust isn’t limited to low-level systems programming. It’s expressive and
ergonomic enough to make CLI apps, web servers, and many other kinds of code
quite pleasant to write — you’ll find simple examples of both later in the
book. Working with Rust allows you to build skills that transfer from one
domain to another; you can learn Rust by writing a web app, then apply those
same skills to target your Raspberry Pi.
-->
<p>Mais Rust n'est pas cantonné à la programmation de bas niveau. C'est un langage
suffisamment expressif et ergonomique pour rendre les applications en ligne
de commande, les serveurs web et bien d'autres types de code agréables à écrire
— vous trouverez plus tard des exemples simples de chacun dans ce livre.
Travailler avec Rust vous permet d'acquérir des compétences qui sont
transposables d'un domaine à un autre ; vous pouvez apprendre Rust en écrivant
une application web, puis appliquer les mêmes notions pour les utiliser avec
votre Raspberry Pi.</p>
<!--
This book fully embraces the potential of Rust to empower its users. It’s a
friendly and approachable text intended to help you level up not just your
knowledge of Rust, but also your reach and confidence as a programmer in
general. So dive in, get ready to learn—and welcome to the Rust community!
-->
<p>Ce livre exploite pleinement le potentiel de Rust pour permettre à ses
utilisateurs de se développer. C'est une documentation conviviale et accessible
destinée à améliorer vos connaissances en Rust, mais aussi à améliorer vos
capacités et votre assurance en tant que développeur en général. Alors foncez,
et préparez-vous à apprendre — et bienvenue dans la communauté Rust !</p>
<!--
— Nicholas Matsakis and Aaron Turon
-->
<p>— Nicholas Matsakis et Aaron Turon</p>
<!--
# Introduction
-->
<h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<!--
> Note: This edition of the book is the same as [The Rust Programming
> Language][nsprust] available in print and ebook format from [No Starch
> Press][nsp].
-->
<blockquote>
<p>Note : la version anglaise de ce livre est disponible au format papier et
ebook chez <a href="https://nostarch.com/">No Starch Press</a> à cette adresse :
<a href="https://nostarch.com/rust">The Rust Programming Language</a></p>
</blockquote>
<!--
Welcome to *The Rust Programming Language*, an introductory book about Rust.
The Rust programming language helps you write faster, more reliable software.
High-level ergonomics and low-level control are often at odds in programming
language design; Rust challenges that conflict. Through balancing powerful
technical capacity and a great developer experience, Rust gives you the option
to control low-level details (such as memory usage) without all the hassle
traditionally associated with such control.
-->
<p>Bienvenue sur <em>Le langage de programmation Rust</em>, un livre d'initiation à Rust.
Le langage de programmation Rust vous aide à écrire plus rapidement des
logiciels plus fiables. L'ergonomie de haut-niveau et la maîtrise de bas-niveau
sont souvent en opposition dans la conception des langages de programmation ;
Rust remet en cause ce conflit. Grâce à l'équilibre entre ses puissantes
capacités techniques et une bonne ergonomie de développement, Rust vous donne
la possibilité de contrôler les détails de bas-niveau (comme l'utilisation de
la mémoire) sans tous les soucis traditionnellement associés à ce genre de
pratique.</p>
<!--
## Who Rust Is For
-->
<h2><a class="header" href="#À-qui-sadresse-rust" id="À-qui-sadresse-rust">À qui s'adresse Rust</a></h2>
<!--
Rust is ideal for many people for a variety of reasons. Let’s look at a few of
the most important groups.
-->
<p>Rust est idéal pour de nombreuses personnes pour diverses raisons. Analysons
quelques-uns des groupes les plus importants.</p>
<!--
### Teams of Developers
-->
<h3><a class="header" href="#Équipes-de-développeurs" id="Équipes-de-développeurs">Équipes de développeurs</a></h3>
<!--
Rust is proving to be a productive tool for collaborating among large teams of
developers with varying levels of systems programming knowledge. Low-level code
is prone to a variety of subtle bugs, which in most other languages can be
caught only through extensive testing and careful code review by experienced
developers. In Rust, the compiler plays a gatekeeper role by refusing to
compile code with these elusive bugs, including concurrency bugs. By working
alongside the compiler, the team can spend their time focusing on the program’s
logic rather than chasing down bugs.
-->
<p>Rust se révèle être un outil productif pour la collaboration entre de grandes
équipes de développeurs ayant différents niveaux de connaissances en
programmation système. Le code de bas-niveau est sujet à une multitude de bogues
subtils, qui, dans la plupart des autres langages, ne peuvent être prévenus
qu'au moyen de campagnes de test étendues et de minutieuses revues de
code menées par des développeurs chevronnés. Avec Rust, le compilateur joue le
rôle de gardien en refusant de compiler du code qui comprend ces bogues
discrets et vicieux, y compris les bogues de concurrence. En travaillant avec
le compilateur, l'équipe peut se concentrer sur la logique du programme plutôt
que de traquer les bogues.</p>
<!--
Rust also brings contemporary developer tools to the systems programming world:
-->
<p>Rust offre aussi des outils de développement modernes au monde de la
programmation système :</p>
<!--
* Cargo, the included dependency manager and build tool, makes adding,
  compiling, and managing dependencies painless and consistent across the Rust
  ecosystem.
* Rustfmt ensures a consistent coding style across developers.
* The Rust Language Server powers Integrated Development Environment (IDE)
  integration for code completion and inline error messages.
-->
<ul>
<li>Cargo, l'outil intégré de gestion de dépendances et de compilation, qui
uniformise et facilite l'ajout, la compilation, et la gestion des dépendances
dans l'écosystème Rust.</li>
<li>Rustfmt, qui assure une cohérence de style de codage pour tous les
développeurs.</li>
<li>Le <em>Rust Langage Server</em> alimente les environnements de développement
intégrés (IDE) pour la complétion du code et l'affichage direct des messages
d'erreur.</li>
</ul>
<!--
By using these and other tools in the Rust ecosystem, developers can be
productive while writing systems-level code.
-->
<p>En utilisant ces outils ainsi que d'autres dans l'écosystème Rust, les
développeurs peuvent être plus productifs quand ils écrivent du code système.</p>
<!--
### Students
-->
<h3><a class="header" href="#Étudiants" id="Étudiants">Étudiants</a></h3>
<!--
Rust is for students and those who are interested in learning about systems
concepts. Using Rust, many people have learned about topics like operating
systems development. The community is very welcoming and happy to answer
student questions. Through efforts such as this book, the Rust teams want to
make systems concepts more accessible to more people, especially those new to
programming.
-->
<p>Rust est conçu pour les étudiants et ceux qui s'intéressent à l'apprentissage
des concepts système. En utilisant Rust, de nombreuses personnes ont appris
des domaines comme le développement de systèmes d'exploitation. La communauté
est très accueillante et répond volontiers aux questions des étudiants. Grâce à
des initiatives comme ce livre, les équipes de Rust veulent rendre les notions
système accessibles au plus grand nombre, particulièrement à ceux qui débutent
dans la programmation.</p>
<!--
### Companies
-->
<h3><a class="header" href="#entreprises" id="entreprises">Entreprises</a></h3>
<!--
Hundreds of companies, large and small, use Rust in production for a variety of
tasks. Those tasks include command line tools, web services, DevOps tooling,
embedded devices, audio and video analysis and transcoding, cryptocurrencies,
bioinformatics, search engines, Internet of Things applications, machine
learning, and even major parts of the Firefox web browser.
-->
<p>Des centaines d'entreprises, petites et grosses, utilisent Rust en production
pour différentes missions. Ils l'utilisent pour des outils en ligne de commande,
des services web, des outils DevOps, des systèmes embarqués, de l'analyse et de
la conversion audio et vidéo, des cryptomonnaies, de la bio-informatique, des
moteurs de recherche, de l'internet des objets <em>(IoT)</em>, de l'apprentissage
automatique <em>(marchine learning)</em>, et même des parties importantes du navigateur
internet Firefox.</p>
<!--
### Open Source Developers
-->
<h3><a class="header" href="#développeurs-de-logiciel-libre" id="développeurs-de-logiciel-libre">Développeurs de logiciel libre</a></h3>
<!--
Rust is for people who want to build the Rust programming language, community,
developer tools, and libraries. We’d love to have you contribute to the Rust
language.
-->
<p>Rust est ouvert aux personnes qui veulent développer le langage de programmation
Rust, la communauté, les outils de développement et les bibliothèques. Nous
serions ravis que vous contribuiez au langage Rust.</p>
<!--
### People Who Value Speed and Stability
-->
<h3><a class="header" href="#les-personnes-qui-recherchent-la-rapidité-et-la-stabilité" id="les-personnes-qui-recherchent-la-rapidité-et-la-stabilité">Les personnes qui recherchent la rapidité et la stabilité</a></h3>
<!--
Rust is for people who crave speed and stability in a language. By speed, we
mean the speed of the programs that you can create with Rust and the speed at
which Rust lets you write them. The Rust compiler’s checks ensure stability
through feature additions and refactoring. This is in contrast to the brittle
legacy code in languages without these checks, which developers are often
afraid to modify. By striving for zero-cost abstractions, higher-level features
that compile to lower-level code as fast as code written manually, Rust
endeavors to make safe code be fast code as well.
-->
<p>Rust est une solution pour les personnes qui chérissent la rapidité et la
stabilité dans un langage. Par rapidité, nous entendons la vitesse des
programmes que vous pouvez créer avec Rust et la rapidité avec laquelle Rust
vous permet de les écrire. Les vérifications du compilateur de Rust assurent la
stabilité durant l'ajout de fonctionnalités ou le remaniement du code. Cela
le démarque des langages qui ne font pas ces contrôles sur du code instable que
le programme a hérité avec le temps, et que bien souvent les développeurs ont
peur de modifier. En s'efforçant de mettre en place des abstractions sans coût,
des fonctionnalités de haut-niveau qui compilent vers du code bas-niveau aussi
rapide que s'il avait été écrit à la main, Rust fait en sorte que le
code sûr soit aussi du code rapide.</p>
<!--
The Rust language hopes to support many other users as well; those mentioned
here are merely some of the biggest stakeholders. Overall, Rust’s greatest
ambition is to eliminate the trade-offs that programmers have accepted for
decades by providing safety *and* productivity, speed *and* ergonomics. Give
Rust a try and see if its choices work for you.
-->
<p>Le langage Rust espère aider beaucoup d'autres utilisateurs ; ceux cités ici ne
font partie que d'un univers bien plus grand. Globalement, la plus grande
ambition de Rust est d'éradiquer les compromis auxquels les développeurs
se soumettaient depuis des décennies en leur apportant sécurité <em>et</em>
productivité, rapidité <em>et</em> ergonomie. Essayez Rust et vérifiez si ses décisions
vous conviennent.</p>
<!--
## Who This Book Is For
-->
<h2><a class="header" href="#À-qui-est-destiné-ce-livre" id="À-qui-est-destiné-ce-livre">À qui est destiné ce livre</a></h2>
<!--
This book assumes that you’ve written code in another programming language but
doesn’t make any assumptions about which one. We’ve tried to make the material
broadly accessible to those from a wide variety of programming backgrounds. We
don’t spend a lot of time talking about what programming *is* or how to think
about it. If you’re entirely new to programming, you would be better served by
reading a book that specifically provides an introduction to programming.
-->
<p>Ce livre suppose que vous avez écrit du code dans un autre langage de
programmation mais ne suppose pas lequel. Nous avons essayé de rendre son
contenu le plus accessible au plus grand nombre d'expériences de programmation
possible. Nous ne nous évertuons pas à nous questionner sur <em>ce qu'est</em> la
programmation ou comment l'envisager. Si vous êtes débutant en programmation,
vous seriez mieux avisé en lisant un livre qui vous initie à la programmation.</p>
<!--
## How to Use This Book
-->
<h2><a class="header" href="#comment-utiliser-ce-livre" id="comment-utiliser-ce-livre">Comment utiliser ce livre</a></h2>
<!--
In general, this book assumes that you’re reading it in sequence from front to
back. Later chapters build on concepts in earlier chapters, and earlier
chapters might not delve into details on a topic; we typically revisit the
topic in a later chapter.
-->
<p>Globalement, ce livre est prévu pour être lu dans l'ordre. Les chapitres
suivants s'appuient sur les notions abordées dans les chapitres précédents, et
lorsque les chapitres précédents ne peuvent pas approfondir un sujet, ce sera
généralement fait dans un chapitre suivant.</p>
<!--
You’ll find two kinds of chapters in this book: concept chapters and project
chapters. In concept chapters, you’ll learn about an aspect of Rust. In project
chapters, we’ll build small programs together, applying what you’ve learned so
far. Chapters 2, 12, and 20 are project chapters; the rest are concept chapters.
-->
<p>Vous allez rencontrer deux différents types de chapitres dans ce livre : les
chapitres théoriques et les chapitres de projet. Dans les chapitres théoriques,
vous allez apprendre un sujet à propos de Rust. Dans un chapitre de projet, nous
allons construire ensemble des petits programmes, pour appliquer ce que vous
avez appris précédemment. Les chapitres 2, 12 et 20 sont des chapitres de
projet ; les autres sont des chapitres théoriques.</p>
<!--
Chapter 1 explains how to install Rust, how to write a Hello, world! program,
and how to use Cargo, Rust’s package manager and build tool. Chapter 2 is a
hands-on introduction to the Rust language. Here we cover concepts at a high
level, and later chapters will provide additional detail. If you want to get
your hands dirty right away, Chapter 2 is the place for that. At first, you
might even want to skip Chapter 3, which covers Rust features similar to those
of other programming languages, and head straight to Chapter 4 to learn about
Rust’s ownership system. However, if you’re a particularly meticulous learner
who prefers to learn every detail before moving on to the next, you might want
to skip Chapter 2 and go straight to Chapter 3, returning to Chapter 2 when
you’d like to work on a project applying the details you’ve learned.
-->
<p>Le chapitre 1 explique comment installer Rust, comment écrire un programme
&quot;Hello, world!&quot; et comment utiliser Cargo, le gestionnaire de paquets et outil
de compilation. Le chapitre 2 est une initiation pratique au langage Rust. Nous
y aborderons des concepts de haut-niveau, et les chapitres suivants apporteront
plus de détails. Si vous voulez vous <em>salir les mains</em> tout de suite,
le chapitre 2 est l'endroit pour cela. Au début, vous pouvez même sauter le
chapitre 3, qui aborde les fonctionnalités de Rust semblables aux autres
langages de programmation, et passer directement au chapitre 4 pour en savoir
plus sur le système de possession <em>(ownership)</em> de Rust. Toutefois, si vous êtes
un apprenti particulièrement minutieux qui préfère apprendre chaque
particularité avant de passer à la suivante, vous pouvez sauter le chapitre 2 et
passer directement au chapitre 3, puis revenir au chapitre 2 lorsque vous
souhaitez travailler sur un projet en appliquant les notions que vous avez
apprises.</p>
<!--
Chapter 5 discusses structs and methods, and Chapter 6 covers enums, `match`
expressions, and the `if let` control flow construct. You’ll use structs and
enums to make custom types in Rust.
-->
<p>Le chapitre 5 traite des structures et des méthodes, et le chapitre 6 couvre les
énumérations, les expressions <code>match</code>, et la structure de contrôle <code>if let</code>.
Vous emploierez les structures et les énumérations pour créer des types
personnalisés avec Rust.</p>
<!--
In Chapter 7, you’ll learn about Rust’s module system and about privacy rules
for organizing your code and its public Application Programming Interface
(API). Chapter 8 discusses some common collection data structures that the
standard library provides, such as vectors, strings, and hash maps. Chapter 9
explores Rust’s error-handling philosophy and techniques.
-->
<p>Au chapitre 7, vous apprendrez le système de modules de Rust et les règles de
visibilité, afin d'organiser votre code et son interface de programmation
applicative (API) publique. Le chapitre 8 traitera des structures de collections
de données usuelles fournies par la bibliothèque standard, comme les vecteurs,
les chaînes de caractères et les tables de hachage <em>(hash maps)</em>. Le chapitre 9
explorera la philosophie et les techniques de gestion d'erreurs de Rust.</p>
<!--
Chapter 10 digs into generics, traits, and lifetimes, which give you the power
to define code that applies to multiple types. Chapter 11 is all about testing,
which even with Rust’s safety guarantees is necessary to ensure your program’s
logic is correct. In Chapter 12, we’ll build our own implementation of a subset
of functionality from the `grep` command line tool that searches for text
within files. For this, we’ll use many of the concepts we discussed in the
previous chapters.
-->
<p>Le chapitre 10 nous plongera dans la généricité, les <em>traits</em> et
les durées de vie, qui vous donneront la capacité de créer du code qui s'adapte
à différents types. Le chapitre 11 traitera des techniques de test, qui restent
nécessaires malgré les garanties de sécurité de Rust, pour s'assurer que
la logique de votre programme est valide. Au chapitre 12, nous écrirons
notre propre implémentation d'un sous-ensemble des fonctionnalités du programme
en ligne de commande <code>grep</code>, qui recherche du texte dans des fichiers.
Pour ce faire, nous utiliserons de nombreuses notions abordées dans les
chapitres précédents.</p>
<!--
Chapter 13 explores closures and iterators: features of Rust that come from
functional programming languages. In Chapter 14, we’ll examine Cargo in more
depth and talk about best practices for sharing your libraries with others.
Chapter 15 discusses smart pointers that the standard library provides and the
traits that enable their functionality.
-->
<p>Le chapitre 13 explorera les fermetures <em>(closures)</em> et itérateurs : ce sont les
fonctionnalités de Rust inspirées des langages de programmation fonctionnels.
Au chapitre 14, nous explorerons plus en profondeur Cargo et les bonnes
pratiques pour partager vos propres bibliothèques avec les autres. Le chapitre
15 parlera de pointeurs intelligents qu'apporte la bibliothèque standard et des
<em>traits</em> qui activent leurs fonctionnalités.</p>
<!--
In Chapter 16, we’ll walk through different models of concurrent programming
and talk about how Rust helps you to program in multiple threads fearlessly.
Chapter 17 looks at how Rust idioms compare to object-oriented programming
principles you might be familiar with.
-->
<p>Au chapitre 16, nous passerons en revue les différents modes de programmation
concurrente et comment Rust nous aide à développer dans des processus parallèles
sans crainte. Le chapitre 17 comparera les fonctionnalités de Rust aux
principes de programmation orientée objet, que vous connaissez peut-être.</p>
<!--
Chapter 18 is a reference on patterns and pattern matching, which are powerful
ways of expressing ideas throughout Rust programs. Chapter 19 contains a
smorgasbord of advanced topics of interest, including unsafe Rust, macros, and
more about lifetimes, traits, types, functions, and closures.
-->
<p>Le chapitre 18 est une référence sur les motifs et le filtrage de motif
<em>(pattern matching)</em>, qui sont des moyens puissants permettant de communiquer
des idées dans les programmes Rust. Le chapitre 19 contient une foultitude de
sujets avancés intéressants, comme le code Rust non sécurisé <em>(unsafe)</em>, les
macros et plus de détails sur les durées de vie, les <em>traits</em>, les types, les
fonctions et les fermetures <em>(closures)</em>.</p>
<!--
In Chapter 20, we’ll complete a project in which we’ll implement a low-level
multithreaded web server!
-->
<p>Au chapitre 20, nous terminerons un projet dans lequel nous allons
implémenter en bas-niveau un serveur web multi-processus !</p>
<!--
Finally, some appendixes contain useful information about the language in a
more reference-like format. Appendix A covers Rust’s keywords, Appendix B
covers Rust’s operators and symbols, Appendix C covers derivable traits
provided by the standard library, Appendix D covers some useful development
tools, and Appendix E explains Rust editions.
-->
<p>Et finalement, quelques annexes qui contiennent des informations utiles sur le
langage sous forme de référentiels qui renvoient à d'autres documents. L'annexe
A liste les mots-clés de Rust, l'annexe B couvre les opérateurs et symboles de
Rust, l'annexe C parle des <em>traits</em> dérivables qu'apporte la bibliothèque
standard, l'annexe D référence certains outils de développement utiles, et
l'annexe E explique les différentes éditions de Rust.</p>
<!--
There is no wrong way to read this book: if you want to skip ahead, go for it!
You might have to jump back to earlier chapters if you experience any
confusion. But do whatever works for you.
-->
<p>Il n'y a pas de mauvaise manière de lire ce livre : si vous voulez sauter des
étapes, allez-y !
Vous devrez alors peut-être revenir sur les chapitres précédents si vous
éprouvez des difficultés. Mais faites comme bon vous semble.</p>
<p><span id="ferris"></span></p>
<!--
An important part of the process of learning Rust is learning how to read the
error messages the compiler displays: these will guide you toward working code.
As such, we’ll provide many examples that don’t compile along with the error
message the compiler will show you in each situation. Know that if you enter
and run a random example, it may not compile! Make sure you read the
surrounding text to see whether the example you’re trying to run is meant to
error. Ferris will also help you distinguish code that isn’t meant to work:
-->
<p>Une composante importante du processus d'apprentissage de Rust est de comprendre
comment lire les messages d'erreur qu'affiche le compilateur : ils vous
guideront vers du code correct.
Ainsi, nous citerons de nombreux exemples qui ne compilent pas, avec le message
d'erreur que le compilateur devrait vous afficher dans chaque cas. C'est donc
normal que dans certains cas, si vous copiez et exécutez un exemple au hasard,
il ne compile pas ! Assurez-vous d'avoir lu le texte autour pour savoir si
l'exemple que vous tentez de compiler doit échouer. Ferris va aussi vous aider
à identifier du code qui ne devrait pas fonctionner :</p>
<!--
| Ferris                                                                 | Meaning                                          |
|------------------------------------------------------------------------|--------------------------------------------------|
| <img src="img/ferris/does_not_compile.svg" class="ferris-explain"/>    | This code does not compile!                      |
| <img src="img/ferris/panics.svg" class="ferris-explain"/>              | This code panics!                                |
| <img src="img/ferris/unsafe.svg" class="ferris-explain"/>              | This code block contains unsafe code.            |
| <img src="img/ferris/not_desired_behavior.svg" class="ferris-explain"/>| This code does not produce the desired behavior. |
-->
<table><thead><tr><th>Ferris</th><th>Signification</th></tr></thead><tbody>
<tr><td><img src="img/ferris/does_not_compile.svg" class="ferris-explain"/></td><td>Ce code ne compile pas !</td></tr>
<tr><td><img src="img/ferris/panics.svg" class="ferris-explain"/></td><td>Ce code panique !</td></tr>
<tr><td><img src="img/ferris/unsafe.svg" class="ferris-explain"/></td><td>Ce bloc de code contient du code non sécurisé.</td></tr>
<tr><td><img src="img/ferris/not_desired_behavior.svg" class="ferris-explain"/></td><td>Ce code ne se comporte pas comme voulu.</td></tr>
</tbody></table>
<!--
In most situations, we’ll lead you to the correct version of any code that
doesn’t compile.
-->
<p>Dans la plupart des cas, nous vous guiderons vers la version du code qui devrait
fonctionner.</p>
<!--
## Source Code
-->
<h2><a class="header" href="#code-source" id="code-source">Code source</a></h2>
<!--
The source files from which this book is generated can be found on
[GitHub][book].
-->
<p>Les fichiers du code source qui a généré ce livre en anglais sont disponibles
sur <a href="https://github.com/rust-lang/book/tree/master/src">GitHub</a>.</p>
<p>La version française est aussi disponible sur <a href="https://github.com/Jimskapt/rust-book-fr">GitHub</a>.</p>
<h1><a class="header" href="#traduction-des-termes" id="traduction-des-termes">Traduction des termes</a></h1>
<p>Voici les principaux termes techniques qui ont été traduits de l'anglais vers le
français.</p>
<table><thead><tr><th>Anglais</th><th>Français</th><th>Remarques</th></tr></thead><tbody>
<tr><td>ahead-of-time compilation</td><td>compilation anticipée</td><td>sigle : AOT</td></tr>
<tr><td>allocated</td><td>alloué</td><td>-</td></tr>
<tr><td>annotate</td><td>indiquer</td><td>-</td></tr>
<tr><td>Appendix</td><td>annexe</td><td>tout en minuscule (sauf en début de phrase)</td></tr>
<tr><td>Application Programming Interface (API)</td><td>interface de programmation applicative (API)</td><td>-</td></tr>
<tr><td>argument</td><td>argument / paramètre</td><td>-</td></tr>
<tr><td>arm</td><td>branche</td><td>dans une expression <code>match</code></td></tr>
<tr><td>array</td><td>tableau</td><td>-</td></tr>
<tr><td>artifact</td><td>artéfact</td><td>-</td></tr>
<tr><td>associated function</td><td>fonction associée</td><td>-</td></tr>
<tr><td>attributes</td><td>attributs</td><td>-</td></tr>
<tr><td>binary crate</td><td>crate binaire</td><td>s'utilise au féminin</td></tr>
<tr><td><em>n</em>-bit number</td><td>nombre encodé sur <em>n</em> bits</td><td>-</td></tr>
<tr><td>boolean</td><td>booléen</td><td>-</td></tr>
<tr><td>borrow</td><td>emprunt(er)</td><td>-</td></tr>
<tr><td>bug</td><td>bogue</td><td>-</td></tr>
<tr><td>build system</td><td>système de compilation</td><td>-</td></tr>
<tr><td>byte</td><td>octet</td><td>-</td></tr>
<tr><td>Cargo</td><td>Cargo</td><td>-</td></tr>
<tr><td>catchall value</td><td>valeur passe-partout</td><td>-</td></tr>
<tr><td>Chapter</td><td>chapitre</td><td>tout en minuscule (sauf en début de phrase)</td></tr>
<tr><td>closure</td><td>fermeture</td><td>-</td></tr>
<tr><td>code review</td><td>revue de code</td><td>-</td></tr>
<tr><td>collection</td><td>collection</td><td>-</td></tr>
<tr><td>command</td><td>commande</td><td>dans un terminal</td></tr>
<tr><td>commit</td><td>commit</td><td>-</td></tr>
<tr><td>compound</td><td>composé</td><td>-</td></tr>
<tr><td>concept chapter</td><td>chapitre théorique</td><td>-</td></tr>
<tr><td>concurrency</td><td>concurrence</td><td>-</td></tr>
<tr><td>concurrent</td><td>concurrent</td><td>-</td></tr>
<tr><td>conditional</td><td>structure conditionnelle</td><td>-</td></tr>
<tr><td>constant</td><td>constant / constante</td><td>-</td></tr>
<tr><td>control flow construct</td><td>structure de contrôle</td><td>-</td></tr>
<tr><td>core of the error</td><td>message d'erreur</td><td>-</td></tr>
<tr><td>corruption</td><td>corruption / être corrompu</td><td>-</td></tr>
<tr><td>CPU</td><td>processeur</td><td>-</td></tr>
<tr><td>crash</td><td>plantage</td><td>-</td></tr>
<tr><td>crate</td><td>crate</td><td>nom féminin (une <em>crate</em>)</td></tr>
<tr><td>curly bracket</td><td>accolade</td><td>-</td></tr>
<tr><td>data representation</td><td>modèle de données</td><td>-</td></tr>
<tr><td>debug</td><td>déboguer</td><td>-</td></tr>
<tr><td>debugging</td><td>débogage</td><td>-</td></tr>
<tr><td>dependency</td><td>dépendance</td><td>-</td></tr>
<tr><td>destructure</td><td>déstructurer</td><td>-</td></tr>
<tr><td>DevOps</td><td>DevOps</td><td>-</td></tr>
<tr><td>dot notation</td><td>la notation avec un point</td><td>-</td></tr>
<tr><td>enum</td><td>énumération</td><td>-</td></tr>
<tr><td>enumeration</td><td>énumération</td><td>-</td></tr>
<tr><td>enum’s variant</td><td>variante d'énumération</td><td>-</td></tr>
<tr><td>exploit</td><td>faille</td><td>-</td></tr>
<tr><td>expression</td><td>expression</td><td>-</td></tr>
<tr><td>field</td><td>champ</td><td>d'une structure</td></tr>
<tr><td>flag</td><td>drapeau</td><td>pour les programmes en ligne de commande</td></tr>
<tr><td>float</td><td>nombre à virgule flottante</td><td>-</td></tr>
<tr><td>floating-point number</td><td>nombre à virgule flottante</td><td>-</td></tr>
<tr><td>function</td><td>fonction</td><td>-</td></tr>
<tr><td>functional programming</td><td>programmation fonctionnelle</td><td>-</td></tr>
<tr><td>generics</td><td>génériques / généricité</td><td>-</td></tr>
<tr><td>global scope</td><td>portée globale</td><td>-</td></tr>
<tr><td>guessing game</td><td>jeu de devinettes</td><td>-</td></tr>
<tr><td>handle</td><td>référence abstraite</td><td>-</td></tr>
<tr><td>hash</td><td>hash / relatif au hachage</td><td>-</td></tr>
<tr><td>hash map</td><td>table de hachage</td><td>-</td></tr>
<tr><td>heap</td><td>tas</td><td>-</td></tr>
<tr><td>Hello, world!</td><td>Hello, world!</td><td>-</td></tr>
<tr><td>high-level</td><td>haut niveau</td><td>-</td></tr>
<tr><td>identifier</td><td>identificateur</td><td>-</td></tr>
<tr><td>immutability</td><td>immuabilité</td><td>-</td></tr>
<tr><td>immutable</td><td>immuable</td><td>-</td></tr>
<tr><td>index</td><td>indice</td><td>-</td></tr>
<tr><td>indexing</td><td>indexation</td><td>-</td></tr>
<tr><td>input/output</td><td>entrée/sortie</td><td>sigle : IO</td></tr>
<tr><td>instance</td><td>instance</td><td>-</td></tr>
<tr><td>instantiate</td><td>instancier</td><td>créer une instance</td></tr>
<tr><td>integer literal</td><td>littéral d'entiers</td><td>-</td></tr>
<tr><td>integer overflow</td><td>dépassement d'entier</td><td>-</td></tr>
<tr><td>Integrated Development Environment (IDE)</td><td>environnement de développement intégré (IDE)</td><td>-</td></tr>
<tr><td>IOT</td><td>internet des objets (IOT)</td><td>-</td></tr>
<tr><td>iterator</td><td>itérateur</td><td>-</td></tr>
<tr><td>just-in-time compilation</td><td>compilation à la volée</td><td>sigle : JIT</td></tr>
<tr><td>keyword</td><td>mot-clé</td><td>-</td></tr>
<tr><td>legacy code</td><td>code instable que le programme a hérité avec le temps</td><td>-</td></tr>
<tr><td>library</td><td>bibliothèque</td><td>-</td></tr>
<tr><td>library crate</td><td>crate de bibliothèque</td><td>s'utilise au féminin</td></tr>
<tr><td>lifetime</td><td>durée de vie</td><td>-</td></tr>
<tr><td>linker</td><td>linker</td><td>-</td></tr>
<tr><td>Listing</td><td>encart</td><td>tout en minuscule (sauf en début de phrase)</td></tr>
<tr><td>low-level</td><td>bas niveau</td><td>-</td></tr>
<tr><td>machine learning</td><td>apprentissage automatique</td><td>-</td></tr>
<tr><td>macro</td><td>macro</td><td>-</td></tr>
<tr><td>main</td><td>main</td><td>-</td></tr>
<tr><td>memory management</td><td>gestion de mémoire</td><td>-</td></tr>
<tr><td>method</td><td>méthode</td><td>-</td></tr>
<tr><td>modern</td><td>récent</td><td>-</td></tr>
<tr><td>module</td><td>module</td><td>-</td></tr>
<tr><td>mutability</td><td>mutabilité</td><td>-</td></tr>
<tr><td>mutable</td><td>mutable</td><td>modifiable</td></tr>
<tr><td>mutate</td><td>muter</td><td>-</td></tr>
<tr><td>Note</td><td>remarque</td><td>tout en minuscule (sauf en début de phrase)</td></tr>
<tr><td>numerical characters</td><td>chiffres</td><td>-</td></tr>
<tr><td>object-oriented language</td><td>langage orienté objet</td><td>-</td></tr>
<tr><td>operating system</td><td>système d'exploitation</td><td>-</td></tr>
<tr><td>ownership</td><td>possession</td><td>-</td></tr>
<tr><td>package manager</td><td>système de gestion de paquets</td><td>-</td></tr>
<tr><td>panic</td><td>panique(r)</td><td>-</td></tr>
<tr><td>parallelism</td><td>parallélisme</td><td>-</td></tr>
<tr><td>PATH</td><td>PATH</td><td>-</td></tr>
<tr><td>pattern</td><td>motif</td><td>-</td></tr>
<tr><td>pattern-matching</td><td>filtrage par motif</td><td>-</td></tr>
<tr><td>placeholder</td><td>espace réservé</td><td><code>{}</code> pour <code>fmt</code></td></tr>
<tr><td>prelude</td><td>étape préliminaire</td><td>-</td></tr>
<tr><td>procedural macro</td><td>macro procédurale</td><td>-</td></tr>
<tr><td>project chapter</td><td>chapitre de projet</td><td>-</td></tr>
<tr><td>raw identifier</td><td>identificateur brut</td><td>-</td></tr>
<tr><td>README</td><td>README</td><td>-</td></tr>
<tr><td>refactoring</td><td>remaniement</td><td>-</td></tr>
<tr><td>reference</td><td>référence</td><td>-</td></tr>
<tr><td>registry</td><td>registre</td><td>-</td></tr>
<tr><td>regression</td><td>régression</td><td>-</td></tr>
<tr><td>remainder</td><td>modulo</td><td>opération <code>%</code></td></tr>
<tr><td>reproducible build</td><td>compilation reproductible</td><td>-</td></tr>
<tr><td>return</td><td>retourner</td><td>-</td></tr>
<tr><td>run</td><td>exécuter</td><td>pour les programmes</td></tr>
<tr><td>Rustacean</td><td>Rustacé</td><td>-</td></tr>
<tr><td>section header</td><td>entête de section</td><td>-</td></tr>
<tr><td>semantic version</td><td>version sémantique</td><td>-</td></tr>
<tr><td>scalar</td><td>scalaire</td><td>-</td></tr>
<tr><td>scope</td><td>portée</td><td>-</td></tr>
<tr><td>script</td><td>script</td><td>-</td></tr>
<tr><td>section header</td><td>en-tête de section</td><td>-</td></tr>
<tr><td>semantic version</td><td>version sémantique</td><td>-</td></tr>
<tr><td>semantic versioning</td><td>versionnage sémantique</td><td>abréviation : SemVer</td></tr>
<tr><td>shadow</td><td>masquer</td><td>remplacer une variable par une autre de même nom</td></tr>
<tr><td>shadowing</td><td>masquage</td><td>-</td></tr>
<tr><td>shell</td><td>terminal / invite de commande</td><td>-</td></tr>
<tr><td>shorthand</td><td>abréviation</td><td>-</td></tr>
<tr><td>sidebar</td><td>barre latérale</td><td>-</td></tr>
<tr><td>signature</td><td>signature</td><td>d'une fonction</td></tr>
<tr><td>signed</td><td>signé</td><td>-</td></tr>
<tr><td>smart pointer</td><td>pointeur intelligent</td><td>-</td></tr>
<tr><td>snip</td><td>code inchangé masqué ici</td><td>dans un encart</td></tr>
<tr><td>space</td><td>espace</td><td>ce mot est féminin quand on parle du caractère typographique</td></tr>
<tr><td>square brackets</td><td>crochets</td><td>-</td></tr>
<tr><td>stack</td><td>pile</td><td>-</td></tr>
<tr><td>standard</td><td>standard <em>(adj. inv.)</em> / norme <em>(n.f.)</em></td><td>-</td></tr>
<tr><td>standard error</td><td>erreur standard</td><td>-</td></tr>
<tr><td>standard input</td><td>entrée standard</td><td>-</td></tr>
<tr><td>standard library</td><td>bibliothèque standard</td><td>-</td></tr>
<tr><td>standard output</td><td>sortie standard</td><td>-</td></tr>
<tr><td>statement</td><td>instruction</td><td>-</td></tr>
<tr><td>statically typed</td><td>statiquement typé</td><td>-</td></tr>
<tr><td>string</td><td>chaîne de caractères</td><td>-</td></tr>
<tr><td><code>String</code></td><td><code>String</code></td><td>nom féminin (une <code>String</code>)</td></tr>
<tr><td>struct</td><td>structure</td><td>-</td></tr>
<tr><td>submodule</td><td>sous-module</td><td>-</td></tr>
<tr><td>systems concept</td><td>notion système</td><td>-</td></tr>
<tr><td>systems-level</td><td>niveau système</td><td>-</td></tr>
<tr><td>systems-level code</td><td>code système</td><td>-</td></tr>
<tr><td>terminal</td><td>terminal</td><td>-</td></tr>
<tr><td>trait</td><td>trait</td><td>-</td></tr>
<tr><td>troubleshooting</td><td>dépannage</td><td>-</td></tr>
<tr><td>tuple</td><td>tuple</td><td>-</td></tr>
<tr><td>tuple struct</td><td>structure tuple</td><td>-</td></tr>
<tr><td>type</td><td>type</td><td>-</td></tr>
<tr><td>type annotation</td><td>annotation de type</td><td>-</td></tr>
<tr><td>type inference</td><td>inférence de types</td><td>-</td></tr>
<tr><td>two’s complement</td><td>complément à deux</td><td>-</td></tr>
<tr><td>two’s complement wrapping</td><td>rebouclage du complément à deux</td><td>-</td></tr>
<tr><td>underlying operating system</td><td>système d'exploitation sous-jacent</td><td>-</td></tr>
<tr><td>underscore</td><td>tiret bas</td><td>le caractère <code>_</code></td></tr>
<tr><td>unit-like struct</td><td>structure unitaire</td><td>-</td></tr>
<tr><td>unit type</td><td>type unité</td><td>-</td></tr>
<tr><td>unit value</td><td>valeur unité</td><td>-</td></tr>
<tr><td>unsafe</td><td>non sécurisé</td><td>-</td></tr>
<tr><td>unsigned</td><td>sans signe (toujours positif)</td><td>-</td></tr>
<tr><td>unsigned</td><td>non signé</td><td>-</td></tr>
<tr><td>user input</td><td>saisie utilisateur</td><td>-</td></tr>
<tr><td>variable</td><td>variable</td><td>-</td></tr>
<tr><td>variant</td><td>variante</td><td>d'une énumération</td></tr>
<tr><td>vector</td><td>vecteur</td><td>-</td></tr>
<tr><td>version control system (VCS)</td><td>système de gestion de versions (VCS)</td><td>-</td></tr>
<tr><td>warning</td><td>avertissement</td><td>-</td></tr>
<tr><td>zero-cost abstraction</td><td>abstraction sans coût</td><td>-</td></tr>
</tbody></table>
<!--
# Getting Started
-->
<h1><a class="header" href="#prise-en-main" id="prise-en-main">Prise en main</a></h1>
<!--
Let’s start your Rust journey! There’s a lot to learn, but every journey starts
somewhere. In this chapter, we’ll discuss:
-->
<p>Démarrons notre périple avec Rust ! Il y a beaucoup à apprendre, mais chaque
aventure doit commencer quelque part. Dans ce chapitre, nous allons aborder :</p>
<!--
* Installing Rust on Linux, macOS, and Windows
* Writing a program that prints `Hello, world!`
* Using `cargo`, Rust’s package manager and build system
-->
<ul>
<li>L'installation de Rust sur Linux, macOS et Windows</li>
<li>L'écriture d'un programme qui affiche <code>Hello, world!</code></li>
<li>L'utilisation de <code>cargo</code>, le gestionnaire de paquets et système de compilation
de Rust</li>
</ul>
<!--
## Installation
-->
<h2><a class="header" href="#installation" id="installation">Installation</a></h2>
<!--
The first step is to install Rust. We’ll download Rust through `rustup`, a
command line tool for managing Rust versions and associated tools. You’ll need
an internet connection for the download.
-->
<p>La première étape consiste à installer Rust. Nous allons télécharger Rust via
<code>rustup</code>, un outil en ligne de commande conçu pour gérer les versions de Rust et
les outils qui leur sont associés. Vous allez avoir besoin d'une connexion
Internet pour le téléchargement.</p>
<!--
> Note: If you prefer not to use `rustup` for some reason, please see [the Rust
> installation page](https://www.rust-lang.org/tools/install) for other options.
-->
<blockquote>
<p>Note : si vous préférez ne pas utiliser <code>rustup</code> pour une raison ou une autre,
vous pouvez vous référer à
<a href="https://www.rust-lang.org/tools/install">la page d'installation de Rust</a>
pour d'autres méthodes d'installation.</p>
</blockquote>
<!--
The following steps install the latest stable version of the Rust compiler.
Rust’s stability guarantees ensure that all the examples in the book that
compile will continue to compile with newer Rust versions. The output might
differ slightly between versions, because Rust often improves error messages
and warnings. In other words, any newer, stable version of Rust you install
using these steps should work as expected with the content of this book.
-->
<p>L'étape suivante est d'installer la dernière version stable du compilateur Rust.
La garantie de stabilité de Rust assurera que tous les exemples dans le livre
qui se compilent bien vont continuer à se compiler avec les nouvelles versions
de Rust. La sortie peut varier légèrement d'une version à une autre, car Rust
améliore souvent les messages d'erreur et les avertissements. En résumé, toute
nouvelle version stable de Rust que vous installez de cette manière devrait
fonctionner en cohérence avec le contenu de ce livre.</p>
<!--
> ### Command Line Notation
>
> In this chapter and throughout the book, we’ll show some commands used in the
> terminal. Lines that you should enter in a terminal all start with `$`. You
> don’t need to type in the `$` character; it indicates the start of each
> command. Lines that don’t start with `$` typically show the output of the
> previous command. Additionally, PowerShell-specific examples will use `>`
> rather than `$`.
-->
<blockquote>
<h3><a class="header" href="#la-notation-en-ligne-de-commande" id="la-notation-en-ligne-de-commande">La notation en ligne de commande</a></h3>
<p>Dans ce chapitre et les suivants dans le livre, nous allons montrer quelques
commandes tapées dans le terminal. Les lignes que vous devrez écrire dans le
terminal commencent toutes par <code>$</code>. Vous n'avez pas besoin d'écrire le
caractère <code>$</code>; il marque le début de chaque commande. Les lignes qui ne
commencent pas par <code>$</code> montrent généralement le résultat de la commande
précédente. De plus, les exemples propres à PowerShell utiliseront
<code>&gt;</code> plutôt que <code>$</code>.</p>
</blockquote>
<!--
### Installing `rustup` on Linux or macOS
-->
<h3><a class="header" href="#installer-rustup-sur-linux-ou-macos" id="installer-rustup-sur-linux-ou-macos">Installer <code>rustup</code> sur Linux ou macOS</a></h3>
<!--
If you’re using Linux or macOS, open a terminal and enter the following command:
-->
<p>Si vous utilisez Linux ou macOS, ouvrez un terminal et écrivez la commande
suivante :</p>
<pre><code class="language-text">$ curl https://sh.rustup.rs -sSf | sh
</code></pre>
<!--
The command downloads a script and starts the installation of the `rustup`
tool, which installs the latest stable version of Rust. You might be prompted
for your password. If the install is successful, the following line will appear:
-->
<p>Cette commande télécharge un script et lance l'installation de l'outil <code>rustup</code>,
qui va installer la dernière version stable de Rust. Il est possible que l'on
vous demande votre mot de passe. Si l'installation se déroule bien, vous
devriez voir la ligne suivante s'afficher :</p>
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<!--
If you prefer, feel free to download the script and inspect it before running
it.
-->
<p>Si vous préférez, vous pouvez télécharger le script et l'examiner avant de le
lancer.</p>
<!--
The installation script automatically adds Rust to your system PATH after your
next login. If you want to start using Rust right away instead of restarting
your terminal, run the following command in your shell to add Rust to your
system PATH manually:
-->
<p>Le script d'installation va ajouter automatiquement Rust dans la variable
<em>PATH</em> de votre système après votre prochaine connexion utilisateur.
Si vous préférez utiliser Rust tout de suite au lieu de redémarrer votre
terminal, lancez la commande suivante dans votre terminal pour ajouter Rust dans
le <em>PATH</em> de votre système manuellement :</p>
<pre><code class="language-text">$ source $HOME/.cargo/env
</code></pre>
<!--
Alternatively, you can add the following line to your *~/.bash_profile*:
-->
<p>Vous pouvez aussi ajouter la ligne suivante dans votre <em>~/.bash_profile</em> :</p>
<pre><code class="language-text">$ export PATH=&quot;$HOME/.cargo/bin:$PATH&quot;
</code></pre>
<!--
Additionally, you’ll need a linker of some kind. It’s likely one is already
installed, but when you try to compile a Rust program and get errors indicating
that a linker could not execute, that means a linker isn’t installed on your
system and you’ll need to install one manually. C compilers usually come with
the correct linker. Check your platform’s documentation for how to install a C
compiler. Also, some common Rust packages depend on C code and will need a C
compiler. Therefore, it might be worth installing one now.
-->
<p>De plus, vous aurez peut-être besoin d'un <em>linker</em> quelconque. Il est probable
qu'il y en ait déjà un d'installé, mais si vous essayez de compiler un
programme Rust et que vous avez des erreurs qui disent que le <em>linker</em> ne peut
pas être exécuté, cela veut dire qu'il n'y a pas de <em>linker</em> d'installé sur
votre système et que vous devrez en installer un manuellement. Les
compilateurs C sont généralement livrés avec un bon <em>linker</em>. Référez-vous à la
documentation de votre plateforme pour savoir comment installer un compilateur
C. De plus, certains paquets Rust communs nécessitent du code C et auront
besoin d'un compilateur C. C'est pourquoi cela vaut la peine d'en installer un
dès maintenant.</p>
<!--
### Installing `rustup` on Windows
-->
<h3><a class="header" href="#installer-rustup-sous-windows" id="installer-rustup-sous-windows">Installer <code>rustup</code> sous Windows</a></h3>
<!--
On Windows, go to [https://www.rust-lang.org/tools/install][install] and follow
the instructions for installing Rust. At some point in the installation, you’ll
receive a message explaining that you’ll also need the C++ build tools for
Visual Studio 2013 or later. The easiest way to acquire the build tools is to
install [Build Tools for Visual Studio 2019][visualstudio]. The tools are in
the Other Tools and Frameworks section.
-->
<p>Sous Windows, il faut aller sur
<a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a> et suivre les instructions
pour installer Rust. À un moment donné durant l'installation, vous aurez un
message vous expliquant qu'il va vous falloir l'outil de compilation C++
pour Visual Studio 2013 ou plus récent. La méthode la plus facile pour obtenir
les outils de compilation est d'installer
<a href="https://www.visualstudio.com/fr/downloads/#build-tools-for-visual-studio-2019">Build Tools pour Visual Studio 2019</a>.</p>
<!--
[visualstudio]: https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2019
FR translation: the website redirects to French version, we lose the "id" link.
Fix is directly below:
-->
<!--
The rest of this book uses commands that work in both *cmd.exe* and PowerShell.
If there are specific differences, we’ll explain which to use.
-->
<p>La suite de ce livre utilisera des commandes qui fonctionnent à la fois dans
<em>cmd.exe</em> et PowerShell. S'il y a des différences particulières, nous vous
expliquerons lesquelles utiliser.</p>
<!--
### Updating and Uninstalling
-->
<h3><a class="header" href="#mettre-à-jour-et-désinstaller" id="mettre-à-jour-et-désinstaller">Mettre à jour et désinstaller</a></h3>
<!--
After you’ve installed Rust via `rustup`, updating to the latest version is
easy. From your shell, run the following update script:
-->
<p>Après avoir installé Rust avec <code>rustup</code>, la mise à jour vers la dernière version
est facile. Dans votre terminal, lancez le script de mise à jour suivant :</p>
<pre><code class="language-text">$ rustup update
</code></pre>
<!--
To uninstall Rust and `rustup`, run the following uninstall script from your
shell:
-->
<p>Pour désinstaller Rust et <code>rustup</code>, exécutez le script de désinstallation
suivant dans votre terminal :</p>
<pre><code class="language-text">$ rustup self uninstall
</code></pre>
<!--
### Troubleshooting
-->
<h3><a class="header" href="#dépannage" id="dépannage">Dépannage</a></h3>
<!--
To check whether you have Rust installed correctly, open a shell and enter this
line:
-->
<p>Pour vérifier si Rust est correctement installé, ouvrez un terminal et entrez
cette ligne :</p>
<pre><code class="language-text">$ rustc --version
</code></pre>
<!--
You should see the version number, commit hash, and commit date for the latest
stable version that has been released in the following format:
-->
<p>Vous devriez voir le numéro de version, le <em>hash</em> de <em>commit</em>,
et la date de <em>commit</em> de la dernière version stable qui a été publiée,
au format suivant :</p>
<pre><code class="language-text">rustc x.y.z (abcabcabc yyyy-mm-dd)
</code></pre>
<!--
If you see this information, you have installed Rust successfully! If you don’t
see this information and you’re on Windows, check that Rust is in your `%PATH%`
system variable. If that’s all correct and Rust still isn’t working, there are
a number of places you can get help. The easiest is the #beginners channel on
[the official Rust Discord][discord]. There, you can chat with other Rustaceans
(a silly nickname we call ourselves) who can help you out. Other great
resources include [the Users forum][users] and [Stack Overflow][stackoverflow].
-->
<p>Si vous voyez cette information, c'est que vous avez installé Rust avec succès !
Si vous ne voyez pas cette information et que vous êtes sous Windows, vérifiez
que Rust est présent dans votre variable d'environnement système <code>%PATH%</code>. Si
tout est correct et que Rust ne fonctionne toujours pas, il y a quelques
endroits où vous pourrez trouver de l'aide. Le plus accessible est le
canal #beginners sur le <a href="https://discord.gg/rust-lang">Discord officiel de Rust</a>. Là-bas, vous pouvez
dialoguer en ligne avec d'autres <em>Rustacés</em> (un surnom ridicule que nous nous
donnons entre nous) qui pourront vous aider. D'autres bonnes sources de données
sont <a href="https://users.rust-lang.org/">le forum d'utilisateurs</a> et <a href="http://stackoverflow.com/questions/tagged/rust">Stack Overflow</a>.</p>
<!--
### Local Documentation
-->
<h3><a class="header" href="#documentation-en-local" id="documentation-en-local">Documentation en local</a></h3>
<!--
The installer also includes a copy of the documentation locally, so you can
read it offline. Run `rustup doc` to open the local documentation in your
browser.
-->
<p>L'installateur embarque aussi une copie de la documentation en local pour que
vous puissiez la lire hors ligne. Lancez <code>rustup doc</code> afin
d'ouvrir la documentation locale dans votre navigateur.</p>
<!--
Any time a type or function is provided by the standard library and you’re not
sure what it does or how to use it, use the application programming interface
(API) documentation to find out!
-->
<p>À chaque fois que vous n'êtes pas sûr de ce que fait un type ou une fonction
fournie par la bibliothèque standard ou que vous ne savez pas comment
l'utiliser, utilisez cette documentation de l'interface de programmation
applicative <em>(API)</em> pour le savoir !</p>
<!--
## Hello, World!
-->
<h2><a class="header" href="#hello-world" id="hello-world">Hello, World!</a></h2>
<!--
Now that you’ve installed Rust, let’s write your first Rust program. It’s
traditional when learning a new language to write a little program that prints
the text `Hello, world!` to the screen, so we’ll do the same here!
-->
<p>Maintenant que vous avez installé Rust, écrivons notre premier programme Rust.
Lorsqu'on apprend un nouveau langage, il est de tradition d'écrire un petit
programme qui écrit le texte &quot;Hello, world!&quot; à l'écran, donc c'est ce que nous
allons faire !</p>
<!--
> Note: This book assumes basic familiarity with the command line. Rust makes
> no specific demands about your editing or tooling or where your code lives, so
> if you prefer to use an integrated development environment (IDE) instead of
> the command line, feel free to use your favorite IDE. Many IDEs now have some
> degree of Rust support; check the IDE’s documentation for details. Recently,
> the Rust team has been focusing on enabling great IDE support, and progress
> has been made rapidly on that front!
-->
<blockquote>
<p>Note : ce livre part du principe que vous êtes familier avec la ligne de
commande. Rust n'impose pas d'exigences sur votre éditeur, vos outils ou
l'endroit où vous mettez votre code, donc si vous préférez utiliser un
environnement de développement intégré (IDE) au lieu de la ligne de commande,
vous êtes libre d'utiliser votre IDE favori. De nombreux IDE prennent en
charge Rust à des degrés divers ; consultez la documentation de
l'IDE pour plus d'informations. Récemment, l'équipe Rust s'est attelée à
améliorer l'intégration dans les IDE et des progrès ont rapidement été faits
dans ce domaine !</p>
</blockquote>
<!--
### Creating a Project Directory
-->
<h3><a class="header" href="#créer-un-dossier-projet" id="créer-un-dossier-projet">Créer un dossier projet</a></h3>
<!--
You’ll start by making a directory to store your Rust code. It doesn’t matter
to Rust where your code lives, but for the exercises and projects in this book,
we suggest making a *projects* directory in your home directory and keeping all
your projects there.
-->
<p>Nous allons commencer par créer un dossier pour y ranger le code Rust. Là où
vous mettez votre code n'est pas important pour Rust, mais pour les exercices et
projets de ce livre, nous vous suggérons de créer un dossier <em>projects</em> dans
votre dossier utilisateur et de ranger tous vos projets là-dedans.</p>
<!--
Open a terminal and enter the following commands to make a *projects* directory
and a directory for the Hello, world! project within the *projects* directory.
-->
<p>Ouvrez un terminal et écrivez les commandes suivantes pour créer un
dossier <em>projects</em> et un dossier pour le projet <em>Hello, world!</em> à l'intérieur
de ce dossier <em>projects</em>.</p>
<!--
For Linux, macOS, and PowerShell on Windows, enter this:
-->
<p>Sous Linux, macOS et PowerShell sous Windows, écrivez ceci :</p>
<pre><code class="language-text">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<!--
For Windows CMD, enter this:
-->
<p>Avec CMD sous Windows, écrivez ceci :</p>
<pre><code class="language-cmd">&gt; mkdir &quot;%USERPROFILE%\projects&quot;
&gt; cd /d &quot;%USERPROFILE%\projects&quot;
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<!--
### Writing and Running a Rust Program
-->
<h3><a class="header" href="#Écrire-et-exécuter-un-programme-rust" id="Écrire-et-exécuter-un-programme-rust">Écrire et exécuter un programme Rust</a></h3>
<!--
Next, make a new source file and call it *main.rs*. Rust files always end with
the *.rs* extension. If you’re using more than one word in your filename, use
an underscore to separate them. For example, use *hello_world.rs* rather than
*helloworld.rs*.
-->
<p>Ensuite, créez un nouveau fichier source et appelez-le <em>main.rs</em>. Les fichiers
Rust se terminent toujours par l'extension <em>.rs</em>. Si vous utilisez plusieurs
mots dans votre nom de fichier, utilisez un tiret bas (<code>_</code>) pour
les séparer. Par exemple, vous devriez utiliser <em>hello_world.rs</em> au lieu de
<em>helloworld.rs</em>.</p>
<!--
Now open the *main.rs* file you just created and enter the code in Listing 1-1.
-->
<p>Maintenant, ouvrez le fichier <em>main.rs</em> que vous venez de créer et entrez le
code de l'encart 1-1.</p>
<!--
<span class="filename">Filename: main.rs</span>
-->
<p><span class="filename">Fichier : main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<!--
<span class="caption">Listing 1-1: A program that prints `Hello, world!`</span>
-->
<p><span class="caption">Encart 1-1 : Un programme qui affiche <code>Hello, world!</code>
</span></p>
<!--
Save the file and go back to your terminal window. On Linux or macOS, enter
the following commands to compile and run the file:
-->
<p>Enregistrez le fichier et retournez dans votre terminal. Sur Linux
ou macOS, écrivez les commandes suivantes pour compiler et exécuter le fichier :</p>
<pre><code class="language-text">$ rustc main.rs
$ ./main
Hello, world!
</code></pre>
<!--
On Windows, enter the command `.\main.exe` instead of `./main`:
-->
<p>Sur Windows, écrivez la commande <code>.\main.exe</code> à la place de <code>.\main</code> :</p>
<pre><code class="language-powershell">&gt; rustc main.rs
&gt; .\main.exe
Hello, world!
</code></pre>
<!--
Regardless of your operating system, the string `Hello, world!` should print to
the terminal. If you don’t see this output, refer back to the
[“Troubleshooting”][troubleshooting]<!-- ignore -- > part of the Installation
section for ways to get help.
-->
<p>Peu importe votre système d'exploitation, la chaîne de caractères
<code>Hello, world!</code> devrait s'écrire dans votre terminal. Si cela ne s'affiche pas,
référez-vous à la partie <a href="ch01-01-installation.html#troubleshooting">&quot;Dépannage&quot;</a><!-- ignore --> du
chapitre d'installation pour vous aider.</p>
<!--
If `Hello, world!` did print, congratulations! You’ve officially written a Rust
program. That makes you a Rust programmer—welcome!
-->
<p>Si <code>Hello, world!</code> s'affiche, félicitations ! Vous avez officiellement écrit un
programme Rust. Cela fait de vous un développeur Rust — bienvenue !</p>
<!--
### Anatomy of a Rust Program
-->
<h3><a class="header" href="#structure-dun-programme-rust" id="structure-dun-programme-rust">Structure d'un programme Rust</a></h3>
<!--
Let’s review in detail what just happened in your Hello, world! program.
Here’s the first piece of the puzzle:
-->
<p>Regardons en détail ce qui s'est passé dans votre programme <em>Hello, world!</em>.
Voici le premier morceau du puzzle :</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {

}
</code></pre></pre>
<!--
These lines define a function in Rust. The `main` function is special: it is
always the first code that runs in every executable Rust program. The first
line declares a function named `main` that has no parameters and returns
nothing. If there were parameters, they would go inside the parentheses, `()`.
-->
<p>Ces lignes définissent une fonction dans Rust. La fonction <code>main</code> est spéciale :
c'est toujours le premier code qui est exécuté dans tous les programmes
en Rust. La première ligne déclare une fonction qui s'appelle <code>main</code>, qui n'a
pas de paramètre et qui ne retourne aucune valeur. S'il y avait des paramètres,
ils seraient placés entre les parenthèses <code>()</code>.</p>
<!--
Also, note that the function body is wrapped in curly brackets, `{}`. Rust
requires these around all function bodies. It’s good style to place the opening
curly bracket on the same line as the function declaration, adding one space in
between.
-->
<p>À noter en outre que le corps de la fonction est placé entre des accolades
<code>{}</code>. Rust en a besoin autour du corps de chaque fonction. C'est une
bonne pratique d'insérer l'accolade ouvrante sur la même ligne que la
déclaration de la fonction, en ajoutant une espace entre les deux.</p>
<!--
At the time of this writing, an automatic formatter tool called `rustfmt` is
under development. If you want to stick to a standard style across Rust
projects, `rustfmt` will format your code in a particular style. The Rust team
plans to eventually include this tool with the standard Rust distribution, like
`rustc`. So depending on when you read this book, it might already be installed
on your computer! Check the online documentation for more details.
-->
<p>Pendant que nous écrivons ces lignes, un outil de formatage automatique de code
appelé <code>rustfmt</code> est en cours de développement.
Si vous voulez standardiser le style de votre code Rust dans vos projets,
<code>rustfmt</code> va formater votre code de manière bien définie.
L'équipe Rust envisage d'intégrer cet outil dans la distribution
standard de Rust, comme <code>rustc</code>. Donc, selon le moment où vous lirez ce livre,
il se peut qu'il soit déjà installé sur votre ordinateur ! Consultez la
documentation en ligne pour en savoir plus.</p>
<!--
Inside the `main` function is the following code:
-->
<p>À l'intérieur de la fonction <code>main</code>, nous avons le code suivant :</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    println!(&quot;Hello, world!&quot;);
#}</code></pre></pre>
<!--
This line does all the work in this little program: it prints text to the
screen. There are four important details to notice here. First, Rust style is
to indent with four spaces, not a tab.
-->
<p>Cette ligne fait tout le travail dans ce petit programme : il écrit le texte à
l'écran. Il y a quatre détails importants à noter ici. Premièrement, le style de
Rust est d'indenter avec quatre espaces, et non pas avec une tabulation.</p>
<!--
Second, `println!` calls a Rust macro. If it called a function instead, it
would be entered as `println` (without the `!`). We’ll discuss Rust macros in
more detail in Chapter 19. For now, you just need to know that using a `!`
means that you’re calling a macro instead of a normal function.
-->
<p>Deuxièmement, <code>println!</code> fait appel à une macro Rust. S'il appelait une
fonction à la place, cela serait écrit <code>println</code> (sans le <code>!</code>). Nous aborderons
les macros Rust plus en détail dans le chapitre 19. Pour l'instant, vous avez
juste à savoir qu'utiliser un <code>!</code> signifie que vous utilisez une macro plutôt
qu'une fonction classique.</p>
<!--
Third, you see the `"Hello, world!"` string. We pass this string as an argument
to `println!`, and the string is printed to the screen.
-->
<p>Troisièmement, vous voyez la chaîne de caractères <code>&quot;Hello, world!&quot;</code>. Nous
envoyons cette chaîne en argument à <code>println!</code> et cette chaîne est affichée
à l'écran.</p>
<!--
Fourth, we end the line with a semicolon (`;`), which indicates that this
expression is over and the next one is ready to begin. Most lines of Rust code
end with a semicolon.
-->
<p>Quatrièmement, nous terminons la ligne avec un point-virgule (<code>;</code>), qui indique
que cette expression est terminée et que la suivante est prête à commencer. La
plupart des lignes de Rust se terminent avec un point-virgule.</p>
<!--
### Compiling and Running Are Separate Steps
-->
<h3><a class="header" href="#la-compilation-et-lexécution-sont-des-étapes-séparées" id="la-compilation-et-lexécution-sont-des-étapes-séparées">La compilation et l'exécution sont des étapes séparées</a></h3>
<!--
You’ve just run a newly created program, so let’s examine each step in the
process.
-->
<p>Vous venez de lancer un nouveau programme fraîchement créé, donc penchons-nous
sur chaque étape du processus.</p>
<!--
Before running a Rust program, you must compile it using the Rust compiler by
entering the `rustc` command and passing it the name of your source file, like
this:
-->
<p>Avant de lancer un programme Rust, vous devez le compiler en utilisant le
compilateur Rust en entrant la commande <code>rustc</code> et en lui passant le nom de
votre fichier source, comme ceci :</p>
<pre><code class="language-text">$ rustc main.rs
</code></pre>
<!--
If you have a C or C++ background, you’ll notice that this is similar to `gcc`
or `clang`. After compiling successfully, Rust outputs a binary executable.
-->
<p>Si vous avez de l'expérience en C ou en C++, vous observerez des similarités
avec <code>gcc</code> ou <code>clang</code>.
Après avoir compilé avec succès, Rust produit un binaire exécutable.</p>
<!--
On Linux, macOS, and PowerShell on Windows, you can see the executable by
entering the `ls` command in your shell. On Linux and macOS, you’ll see two
files. With PowerShell on Windows, you’ll see the same three files that you
would see using CMD.
-->
<p>Avec Linux, macOS et PowerShell sous Windows, vous pouvez voir l'exécutable en
utilisant la commande <code>ls</code> dans votre terminal. Avec Linux et macOS,
vous devriez voir deux fichiers. Avec PowerShell sous Windows, vous devriez voir
les trois mêmes fichiers que vous verriez en utilisant CMD.</p>
<pre><code class="language-text">$ ls
main  main.rs
</code></pre>
<!--
With CMD on Windows, you would enter the following:
-->
<p>Avec CMD sous Windows, vous devez saisir la commande suivante :</p>
<!--
```cmd
> dir /B %= the /B option says to only show the file names =%
main.exe
main.pdb
main.rs
```
-->
<pre><code class="language-cmd">&gt; dir /B %= l'option /B demande à n'afficher que les noms de fichiers =%
main.exe
main.pdb
main.rs
</code></pre>
<!--
This shows the source code file with the *.rs* extension, the executable file
(*main.exe* on Windows, but *main* on all other platforms), and, when using
Windows, a file containing debugging information with the *.pdb* extension.
From here, you run the *main* or *main.exe* file, like this:
-->
<p>Ceci affiche le fichier de code source avec l'extension <em>.rs</em>, le fichier
exécutable (<em>main.exe</em> sous Windows, mais <em>main</em> sur toutes les autres
plateformes) et, quand on utilise Windows, un fichier qui contient des
informations de débogage avec l'extension <em>.pdb</em>. Dans ce dossier, vous pouvez
exécuter le fichier <em>main</em> ou <em>main.exe</em> comme ceci :</p>
<!--
```text
$ ./main # or .\main.exe on Windows
```
-->
<pre><code class="language-text">$ ./main # ou .\main.exe sous Windows
</code></pre>
<!--
If *main.rs* was your Hello, world! program, this line would print `Hello,
world!` to your terminal.
-->
<p>Si <em>main.rs</em> était votre programme <em>Hello, world!</em>, cette ligne devrait afficher
<code>Hello, world!</code> dans votre terminal.</p>
<!--
If you’re more familiar with a dynamic language, such as Ruby, Python, or
JavaScript, you might not be used to compiling and running a program as
separate steps. Rust is an *ahead-of-time compiled* language, meaning you can
compile a program and give the executable to someone else, and they can run it
even without having Rust installed. If you give someone a *.rb*, *.py*, or
*.js* file, they need to have a Ruby, Python, or JavaScript implementation
installed (respectively). But in those languages, you only need one command to
compile and run your program. Everything is a trade-off in language design.
-->
<p>Si vous connaissez un langage dynamique, comme Ruby, Python, ou JavaScript, vous
n'avez peut-être pas l'habitude de compiler puis lancer votre programme dans des
étapes séparées.
Rust est un langage à <em>compilation anticipée</em>, ce qui veut dire que
vous pouvez compiler le programme et le donner à quelqu'un d'autre, et il peut
l'exécuter sans avoir Rust d'installé. Si vous donnez à quelqu'un un fichier
<em>.rb</em>, <em>.py</em> ou <em>.js</em>, il a besoin d'avoir respectivement un interpréteur Ruby,
Python, ou Javascript d'installé. Cependant, avec ces langages, vous n'avez
besoin que d'une seule commande pour compiler et exécuter votre programme.
Dans la conception d'un langage, tout est une question de compromis.</p>
<!--
Just compiling with `rustc` is fine for simple programs, but as your project
grows, you’ll want to manage all the options and make it easy to share your
code. Next, we’ll introduce you to the Cargo tool, which will help you write
real-world Rust programs.
-->
<p>Compiler avec <code>rustc</code> peut suffire pour de petits programmes, mais au fur et à
mesure que votre programme grandit, vous allez avoir besoin de régler plus
d'options et faciliter le partage de votre code. À la page suivante, nous allons
découvrir l'outil Cargo, qui va vous aider à écrire des programmes Rust à
l'épreuve de la réalité.</p>
<!--
## Hello, Cargo!
-->
<h2><a class="header" href="#hello-cargo" id="hello-cargo">Hello, Cargo!</a></h2>
<!--
Cargo is Rust’s build system and package manager. Most Rustaceans use this tool
to manage their Rust projects because Cargo handles a lot of tasks for you,
such as building your code, downloading the libraries your code depends on, and
building those libraries. (We call libraries your code needs *dependencies*.)
-->
<p>Cargo est le système de compilation et de gestion de paquets de Rust. La plupart
des Rustacés utilisent cet outil pour gérer les projets Rust, car Cargo
s'occupe de nombreuses tâches pour vous, comme compiler votre code, télécharger
les bibliothèques dont votre code dépend, et compiler ces bibliothèques. (On
appelle <em>dépendance</em> une bibliothèque nécessaire pour votre code.)</p>
<!--
The simplest Rust programs, like the one we’ve written so far, don’t have any
dependencies. So if we had built the Hello, world! project with Cargo, it would
only use the part of Cargo that handles building your code. As you write more
complex Rust programs, you’ll add dependencies, and if you start a project
using Cargo, adding dependencies will be much easier to do.
-->
<p>Des programmes Rust très simples, comme le petit que nous avons précédemment,
n'ont pas de dépendance. Donc si nous avions compilé le projet <em>Hello, world!</em>
avec Cargo, cela n'aurait fait appel qu'à la fonctionnalité de Cargo qui
s'occupe de la compilation de votre code. Quand vous écrirez des programmes Rust
plus complexes, vous ajouterez des dépendances, et si vous créez un projet en
utilisant Cargo, l'ajout des dépendances sera plus facile à faire.</p>
<!--
Because the vast majority of Rust projects use Cargo, the rest of this book
assumes that you’re using Cargo too. Cargo comes installed with Rust if you
used the official installers discussed in the
[“Installation”][installation]<!-- ignore -- > section. If you installed Rust
through some other means, check whether Cargo is installed by entering the
following into your terminal:
-->
<p>Comme la large majorité des projets Rust utilisent Cargo, la suite de ce livre
va supposer que vous utilisez aussi Cargo. Cargo s'installe avec Rust si vous
avez utilisé l'installateur officiel présenté dans la section
<a href="ch01-01-installation.html#installation">“Installation”</a><!-- ignore -->. Si vous avez installé Rust
autrement, vérifiez que Cargo est installé en utilisant la commande suivante
dans votre terminal :</p>
<pre><code class="language-text">$ cargo --version
</code></pre>
<!--
If you see a version number, you have it! If you see an error, such as `command
not found`, look at the documentation for your method of installation to
determine how to install Cargo separately.
-->
<p>Si vous voyez un numéro de version, c'est qu'il est installé ! Si vous voyez une
erreur comme <code>Commande non trouvée</code> (ou <code>command not found</code>), alors consultez la
documentation de votre méthode d'installation pour savoir comment installer
séparément Cargo.</p>
<!--
### Creating a Project with Cargo
-->
<h3><a class="header" href="#créer-un-projet-avec-cargo" id="créer-un-projet-avec-cargo">Créer un projet avec Cargo</a></h3>
<!--
Let’s create a new project using Cargo and look at how it differs from our
original Hello, world! project. Navigate back to your *projects* directory (or
wherever you decided to store your code). Then, on any operating system, run
the following:
-->
<p>Créons un nouveau projet en utilisant Cargo et analysons les différences avec
notre projet initial <em>Hello, world!</em>. Retournez dans votre dossier <em>projects</em>
(ou là où vous avez décidé d'enregistrer votre code). Ensuite, sur n'importe
quel système d'exploitation, lancez les commandes suivantes :</p>
<pre><code class="language-text">$ cargo new hello_cargo
$ cd hello_cargo
</code></pre>
<!--
The first command creates a new directory called *hello_cargo*. We’ve named
our project *hello_cargo*, and Cargo creates its files in a directory of the
same name.
-->
<p>La première commande crée un nouveau dossier appelé <em>hello_cargo</em>. Nous avons
appelé notre projet <em>hello_cargo</em>, et Cargo crée ses fichiers dans un dossier
avec le même nom.</p>
<!--
Go into the *hello_cargo* directory and list the files. You’ll see that Cargo
has generated two files and one directory for us: a *Cargo.toml* file and a
*src* directory with a *main.rs* file inside. It has also initialized a new Git
repository along with a *.gitignore* file.
-->
<p>Rendez-vous dans le dossier <em>hello_cargo</em> et afficher la liste des fichiers.
Vous constaterez que Cargo a généré deux fichiers et un dossier pour nous : un
fichier <em>Cargo.toml</em> et un dossier <em>src</em> avec un fichier <em>main.rs</em> à
l'intérieur. Il a aussi créé un nouveau dépôt Git ainsi qu'un fichier
<em>.gitignore</em>.</p>
<!--
> Note: Git is a common version control system. You can change `cargo new` to
> use a different version control system or no version control system by using
> the `--vcs` flag. Run `cargo new --help` to see the available options.
-->
<blockquote>
<p>Note : Git est un système de gestion de versions très répandu. Vous pouvez
changer <code>cargo new</code> pour utiliser un autre système de gestion de versions
ou ne pas en utiliser du tout en écrivant le drapeau <code>--vcs</code>.
Lancez <code>cargo new --help</code> pour en savoir plus sur les options disponibles.</p>
</blockquote>
<!--
Open *Cargo.toml* in your text editor of choice. It should look similar to the
code in Listing 1-2.
-->
<p>Ouvrez <em>Cargo.toml</em> dans votre éditeur de texte favori. Son contenu devrait
être similaire au code dans l'encart 1-2.</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">Fichier : Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;hello_cargo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
edition = &quot;2018&quot;

[dependencies]
</code></pre>
<!--
<span class="caption">Listing 1-2: Contents of *Cargo.toml* generated by `cargo
new`</span>
-->
<p><span class="caption">Encart 1-2 : Contenu de <em>Cargo.toml</em> généré par <code>cargo new</code></span></p>
<!--
This file is in the [*TOML*][toml]<!-- ignore -- > (*Tom’s Obvious, Minimal
Language*) format, which is Cargo’s configuration format.
-->
<p>Ce fichier est au format <a href="https://github.com/toml-lang/toml"><em>TOML</em></a><!-- ignore --> (<em>Tom’s Obvious, Minimal
Language</em>), qui est le format de configuration de Cargo.</p>
<!--
The first line, `[package]`, is a section heading that indicates that the
following statements are configuring a package. As we add more information to
this file, we’ll add other sections.
-->
<p>La première ligne, <code>[package]</code>, est un en-tête de section qui indique que les
instructions suivantes configurent un paquet. Au fur et à mesure que nous
ajouterons plus de détails à ce fichier, nous ajouterons des sections
supplémentaires.</p>
<!--
The next four lines set the configuration information Cargo needs to compile
your program: the name, the version, who wrote it, and the edition of Rust to
use. Cargo gets your name and email information from your environment, so if
that information is not correct, fix the information now and then save the
file. We’ll talk about the `edition` key in Appendix E.
-->
<p>Les quatre lignes suivantes définissent les informations de configuration dont
Cargo a besoin pour compiler votre programme : le nom, la version, l'auteur et
l'édition de Rust à utiliser. Cargo récupère votre nom et votre courriel à
partir de votre environnement, donc si ces informations sont erronées, vous
pouvez les corriger dès maintenant et ensuite enregistrer le fichier. Nous
aborderons la clé <code>edition</code> dans l'annexe E.</p>
<!--
The last line, `[dependencies]`, is the start of a section for you to list any
of your project’s dependencies. In Rust, packages of code are referred to as
*crates*. We won’t need any other crates for this project, but we will in the
first project in Chapter 2, so we’ll use this dependencies section then.
-->
<p>La dernière ligne, <code>[dependencies]</code>, est le début d'une section qui vous permet
de lister les dépendances de votre projet. Dans Rust, les paquets de code sont
désignés sous le nom de <em>crates</em>. Nous n'allons pas utiliser de <em>crate</em> pour ce
projet, mais nous le ferons pour le premier projet au chapitre 2 ; nous
utiliserons alors cette section à ce moment-là.</p>
<!--
Now open *src/main.rs* and take a look:
-->
<p>Maintenant, ouvrez <em>src/main.rs</em> et jetez-y un coup d'œil :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<!--
Cargo has generated a Hello, world! program for you, just like the one we wrote
in Listing 1-1! So far, the differences between our previous project and the
project Cargo generates are that Cargo placed the code in the *src* directory,
and we have a *Cargo.toml* configuration file in the top directory.
-->
<p>Cargo a généré un programme <em>Hello, world!</em> pour vous, exactement comme celui
que nous avons écrit dans l'encart 1-1 ! Pour le moment, les seules différences
entre notre projet précédent et le projet que Cargo a généré sont que Cargo a
placé le code dans le dossier <em>src</em>, et que nous avons un fichier de
configuration <em>Cargo.toml</em> à la racine du dossier projet.</p>
<!--
Cargo expects your source files to live inside the *src* directory. The
top-level project directory is just for README files, license information,
configuration files, and anything else not related to your code. Using Cargo
helps you organize your projects. There’s a place for everything, and
everything is in its place.
-->
<p>Cargo prévoit de stocker vos fichiers sources dans le dossier <em>src</em>. Le dossier
parent est là uniquement pour les fichiers README, pour les informations à
propos de la licence, pour les fichiers de configuration et tout ce qui n'est
pas directement relié à votre code. Utiliser Cargo vous aide à structurer vos
projets. Il y a un endroit pour tout, et tout est à sa place.</p>
<!--
If you started a project that doesn’t use Cargo, as we did with the Hello,
world! project, you can convert it to a project that does use Cargo. Move the
project code into the *src* directory and create an appropriate *Cargo.toml*
file.
-->
<p>Si vous commencez un projet sans utiliser Cargo, comme nous l'avons fait avec
le projet <em>Hello, world!</em>, vous pouvez le transformer en projet qui
utilise Cargo. Déplacez le code de votre projet dans un dossier <em>src</em> et créez
un fichier <em>Cargo.toml</em> adéquat.</p>
<!--
### Building and Running a Cargo Project
-->
<h3><a class="header" href="#compiler-et-exécuter-un-projet-cargo" id="compiler-et-exécuter-un-projet-cargo">Compiler et exécuter un projet Cargo</a></h3>
<!--
Now let’s look at what’s different when we build and run the Hello, world!
program with Cargo! From your *hello_cargo* directory, build your project by
entering the following command:
-->
<p>Maintenant, regardons ce qu'il y a de différent quand nous compilons et
exécutons le programme <em>Hello, world!</em> avec Cargo ! À l'intérieur de votre
dossier <em>hello_cargo</em>, compilez votre projet en utilisant la commande suivante :</p>
<pre><code class="language-text">$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
</code></pre>
<!--
This command creates an executable file in *target/debug/hello_cargo* (or
*target\debug\hello_cargo.exe* on Windows) rather than in your current
directory. You can run the executable with this command:
-->
<p>Cette commande crée un fichier exécutable dans <em>target/debug/hello_cargo</em> (ou
<em>target\debug\hello_cargo.exe</em> sous Windows) plutôt que de le déposer dans votre
dossier courant. Vous pouvez lancer l'exécutable avec cette commande :</p>
<!--
```text
$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
Hello, world!
```
-->
<pre><code class="language-text">$ ./target/debug/hello_cargo # ou .\target\debug\hello_cargo.exe sous Windows
Hello, world!
</code></pre>
<!--
If all goes well, `Hello, world!` should print to the terminal. Running `cargo
build` for the first time also causes Cargo to create a new file at the top
level: *Cargo.lock*. This file keeps track of the exact versions of
dependencies in your project. This project doesn’t have dependencies, so the
file is a bit sparse. You won’t ever need to change this file manually; Cargo
manages its contents for you.
-->
<p>Si tout s'est bien passé, <code>Hello, world!</code> devrait s'afficher dans le terminal.
Lancer <code>cargo build</code> pour la première fois devrait aussi mener Cargo à créer
un nouveau fichier à la racine du dossier projet : <em>Cargo.lock</em>. Ce fichier
garde une trace des versions exactes des dépendances de votre
projet. Ce projet n'a pas de dépendance, donc le fichier est un peu vide. Vous
n'aurez jamais besoin de changer ce fichier manuellement ; Cargo va gérer son
contenu pour vous.</p>
<!--
We just built a project with `cargo build` and ran it with
`./target/debug/hello_cargo`, but we can also use `cargo run` to compile the
code and then run the resulting executable all in one command:
-->
<p>Nous venons de compiler un projet avec <code>cargo build</code> avant de l'exécuter avec
<code>./target/debug/hello_cargo</code>, mais nous pouvons aussi utiliser <code>cargo run</code> pour
compiler le code et ensuite lancer l'exécutable dans une seule et même
commande :</p>
<pre><code class="language-text">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<!--
Notice that this time we didn’t see output indicating that Cargo was compiling
`hello_cargo`. Cargo figured out that the files hadn’t changed, so it just ran
the binary. If you had modified your source code, Cargo would have rebuilt the
project before running it, and you would have seen this output:
-->
<p>Notez que cette fois-ci, nous ne voyons pas de messages indiquant que Cargo a
compilé <code>hello_cargo</code>. Cargo a détecté que les fichiers n'avaient pas changé,
donc il a juste exécuté le binaire. Si vous aviez modifié votre code source,
Cargo aurait recompilé le projet avant de le lancer, et vous auriez eu les
messages suivants :</p>
<pre><code class="language-text">$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<!--
Cargo also provides a command called `cargo check`. This command quickly checks
your code to make sure it compiles but doesn’t produce an executable:
-->
<p>Cargo fournit aussi une commande appelée <code>cargo check</code>. Elle vérifie rapidement
votre code pour s'assurer qu'il est compilable, mais ne produit pas
d'exécutable :</p>
<pre><code class="language-text">$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
<!--
Why would you not want an executable? Often, `cargo check` is much faster than
`cargo build`, because it skips the step of producing an executable. If you’re
continually checking your work while writing the code, using `cargo check` will
speed up the process! As such, many Rustaceans run `cargo check` periodically
as they write their program to make sure it compiles. Then they run `cargo
build` when they’re ready to use the executable.
-->
<p>Dans quel cas n'aurions-nous pas besoin d'un exécutable ? Parfois, <code>cargo check</code>
est bien plus rapide que <code>cargo build</code>, car il saute l'étape de création de
l'exécutable. Si vous vérifiez votre travail continuellement pendant que vous
écrivez votre code, utiliser <code>cargo check</code> accélèrera le processus ! C'est
pourquoi de nombreux Rustacés utilisent périodiquement <code>cargo check</code> quand ils
écrivent leur programme afin de s'assurer qu'il compile. Ensuite, ils lancent
<code>cargo build</code> quand ils sont prêts à utiliser l'exécutable.</p>
<!--
Let’s recap what we’ve learned so far about Cargo:
-->
<p>Récapitulons ce que nous avons appris sur Cargo :</p>
<!--
* We can build a project using `cargo build` or `cargo check`.
* We can build and run a project in one step using `cargo run`.
* Instead of saving the result of the build in the same directory as our code,
  Cargo stores it in the *target/debug* directory.
-->
<ul>
<li>Nous pouvons compiler un projet en utilisant <code>cargo build</code> ou <code>cargo check</code></li>
<li>Nous pouvons compiler puis exécuter un projet en une seule fois en utilisant
<code>cargo run</code>.</li>
<li>Au lieu d'enregistrer le résultat de la compilation dans le même dossier que
votre code, Cargo l'enregistre dans le dossier <em>target/debug</em>.</li>
</ul>
<!--
An additional advantage of using Cargo is that the commands are the same no
matter which operating system you’re working on. So, at this point, we’ll no
longer provide specific instructions for Linux and macOS versus Windows.
-->
<p>Un autre avantage d'utiliser Cargo est que les commandes sont les mêmes peu
importe le système d'exploitation que vous utilisez.
Donc à partir de maintenant, nous n'allons plus faire d'opérations spécifiques
à Linux et macOS par rapport à Windows.</p>
<!--
### Building for Release
-->
<h3><a class="header" href="#compiler-pour-diffuser" id="compiler-pour-diffuser">Compiler pour diffuser</a></h3>
<!--
When your project is finally ready for release, you can use `cargo build
--release` to compile it with optimizations. This command will create an
executable in *target/release* instead of *target/debug*. The optimizations
make your Rust code run faster, but turning them on lengthens the time it takes
for your program to compile. This is why there are two different profiles: one
for development, when you want to rebuild quickly and often, and another for
building the final program you’ll give to a user that won’t be rebuilt
repeatedly and that will run as fast as possible. If you’re benchmarking your
code’s running time, be sure to run `cargo build --release` and benchmark with
the executable in *target/release*.
-->
<p>Quand votre projet est finalement prêt à être diffusé, vous pouvez utiliser
<code>cargo build --release</code> pour le compiler en l'optimisant. Cette commande va
créer un exécutable dans <em>target/release</em> au lieu de <em>target/debug</em>. Ces
optimisations rendent votre code Rust plus rapide à exécuter, mais l'utiliser
rallonge le temps de compilation de votre programme. C'est pourquoi il y a deux
différents profils : un pour le développement, quand vous voulez recompiler
rapidement et souvent, et un autre pour compiler le programme final qui sera
livré à un utilisateur, qui n'aura pas besoin d'être recompilé à plusieurs
reprises et qui s'exécutera aussi vite que possible. Si vous évaluez le temps
d'exécution de votre code, assurez-vous de lancer <code>cargo build --release</code> et
d'utiliser l'exécutable dans <em>target/release</em> pour vos bancs de test.</p>
<!--
### Cargo as Convention
-->
<h3><a class="header" href="#cargo-comme-convention" id="cargo-comme-convention">Cargo comme convention</a></h3>
<!--
With simple projects, Cargo doesn’t provide a lot of value over just using
`rustc`, but it will prove its worth as your programs become more intricate.
With complex projects composed of multiple crates, it’s much easier to let
Cargo coordinate the build.
-->
<p>Pour des projets simples, Cargo n'apporte pas grand-chose par rapport à <code>rustc</code>,
mais il vous montrera son intérêt au fur et à mesure
que vos programmes deviendront plus complexes. Avec des projets complexes
composés de plusieurs <em>crates</em>, il est plus facile de laisser Cargo prendre en
charge la coordination de la compilation.</p>
<!--
Even though the `hello_cargo` project is simple, it now uses much of the real
tooling you’ll use in the rest of your Rust career. In fact, to work on any
existing projects, you can use the following commands to check out the code
using Git, change to that project’s directory, and build:
-->
<p>Même si le projet <code>hello_cargo</code> est simple, il utilise maintenant une grande
partie de l'outillage que vous rencontrerez dans votre carrière avec Rust. En
effet, pour travailler sur n'importe quel projet Rust existant, vous n'avez
qu'à saisir les commandes suivantes pour télécharger le code avec Git, vous
déplacer dans le dossier projet et compiler :</p>
<!--
```text
$ git clone someurl.com/someproject
$ cd someproject
$ cargo build
```
-->
<pre><code class="language-text">$ git clone example.com/projet_quelconque
$ cd projet_quelconque
$ cargo build
</code></pre>
<!--
For more information about Cargo, check out [its documentation].
-->
<p>Pour plus d'informations à propos de Cargo, vous pouvez consulter <a href="https://doc.rust-lang.org/cargo/">sa
documentation</a>.</p>
<!--
## Summary
-->
<h2><a class="header" href="#résumé" id="résumé">Résumé</a></h2>
<!--
You’re already off to a great start on your Rust journey! In this chapter,
you’ve learned how to:
-->
<p>Vous êtes déjà bien lancé dans votre périple avec Rust ! Dans ce chapitre, vous
avez appris comment :</p>
<!--
* Install the latest stable version of Rust using `rustup`
* Update to a newer Rust version
* Open locally installed documentation
* Write and run a Hello, world! program using `rustc` directly
* Create and run a new project using the conventions of Cargo
-->
<ul>
<li>Installer la dernière version stable de Rust en utilisant <code>rustup</code></li>
<li>Mettre à jour Rust vers une nouvelle version</li>
<li>Ouvrir la documentation installée en local</li>
<li>Écrire et exécuter un programme <em>Hello, world!</em> en utilisant directement
<code>rustc</code></li>
<li>Créer et exécuter un nouveau projet en utilisant les conventions de Cargo</li>
</ul>
<!--
This is a great time to build a more substantial program to get used to reading
and writing Rust code. So, in Chapter 2, we’ll build a guessing game program.
If you would rather start by learning how common programming concepts work in
Rust, see Chapter 3 and then return to Chapter 2.
-->
<p>C'est le moment idéal pour construire un programme plus ambitieux pour
s'habituer à lire et écrire du code Rust. Donc, au chapitre 2, nous allons
écrire un programme de <em>jeu de devinettes</em>.
Si vous préférez commencer par apprendre comment les principes de programmation
de base fonctionnent avec Rust, rendez-vous au chapitre 3, puis revenez au
chapitre 2.</p>
<!--
# Programming a Guessing Game
-->
<h1><a class="header" href="#programmer-un-jeu-de-devinettes" id="programmer-un-jeu-de-devinettes">Programmer un jeu de devinettes</a></h1>
<!--
Let’s jump into Rust by working through a hands-on project together! This
chapter introduces you to a few common Rust concepts by showing you how to use
them in a real program. You’ll learn about `let`, `match`, methods, associated
functions, using external crates, and more! The following chapters will explore
these ideas in more detail. In this chapter, you’ll practice the fundamentals.
-->
<p>Entrons dans le vif du sujet en travaillant ensemble sur un projet concret !
Ce chapitre présente quelques concepts couramment utilisés en Rust en vous
montrant comment les utiliser dans un véritable programme. Nous aborderons
notamment les instructions <code>let</code> et <code>match</code>, les méthodes et fonctions
associées, l'utilisation des <em>crates</em>, et bien plus encore ! Dans les chapitres
suivants, nous approfondirons ces notions. Dans ce chapitre, vous n'allez
exercer que les principes de base.</p>
<!--
We’ll implement a classic beginner programming problem: a guessing game. Here’s
how it works: the program will generate a random integer between 1 and 100. It
will then prompt the player to enter a guess. After a guess is entered, the
program will indicate whether the guess is too low or too high. If the guess is
correct, the game will print a congratulatory message and exit.
-->
<p>Nous allons coder un programme fréquemment réalisé par les débutants en
programmation : un jeu de devinettes. Le principe de ce jeu est le suivant :
le programme va tirer au sort un nombre entre 1 et 100. Il invitera ensuite le
joueur à saisir un nombre qu'il pense deviner. Après la saisie, le programme
indiquera si le nombre saisi par le joueur est trop grand ou trop petit. Si le
nombre saisi est le bon, le jeu affichera un message de félicitations et se
fermera.</p>
<!--
## Setting Up a New Project
-->
<h2><a class="header" href="#mise-en-place-dun-nouveau-projet" id="mise-en-place-dun-nouveau-projet">Mise en place d'un nouveau projet</a></h2>
<!--
To set up a new project, go to the *projects* directory that you created in
Chapter 1 and make a new project using Cargo, like so:
-->
<p>Pour créer un nouveau projet, rendez-vous dans le dossier <em>projects</em> que
vous avez créé au chapitre 1 et utilisez Cargo pour créer votre projet, comme
ceci :</p>
<pre><code class="language-text">$ cargo new guessing_game
$ cd guessing_game
</code></pre>
<!--
The first command, `cargo new`, takes the name of the project (`guessing_game`)
as the first argument. The second command changes to the new project’s
directory.
-->
<p>La première commande, <code>cargo new</code>, prend comme premier argument le nom de notre
projet (<code>guessing_game</code>). La seconde commande nous déplace dans le dossier de
notre nouveau projet créé par Cargo.</p>
<!--
Look at the generated *Cargo.toml* file:
-->
<p>Regardons le fichier <em>Cargo.toml</em> qui a été généré :</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">Fichier : Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
edition = &quot;2018&quot;

[dependencies]
</code></pre>
<!--
If the author information that Cargo obtained from your environment is not
correct, fix that in the file and save it again.
-->
<p>Si le nom de l'auteur que Cargo a déduit de votre environnement est incorrect,
vous pouvez le changer dans ce fichier et le sauvegarder.</p>
<!--
As you saw in Chapter 1, `cargo new` generates a “Hello, world!” program for
you. Check out the *src/main.rs* file:
-->
<p>Comme vous l'avez expérimenté dans le chapitre 1, <code>cargo new</code> génère un
programme <em>“Hello, world!”</em> pour vous. Ouvrez le fichier <em>src/main.rs</em> :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<!--
Now let’s compile this “Hello, world!” program and run it in the same step
using the `cargo run` command:
-->
<p>Maintenant, lançons la compilation de ce programme “Hello, world!” et
son exécution en une seule commande avec <code>cargo run</code> :</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50 secs
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
<!--
The `run` command comes in handy when you need to rapidly iterate on a project,
as we’ll do in this game, quickly testing each iteration before moving on to
the next one.
-->
<p>Cette commande <code>run</code> est très pratique lorsqu'on souhaite itérer rapidement
sur un projet, comme c'est le cas ici, pour tester rapidement chaque
modification avant de passer à la suivante.</p>
<!--
Reopen the *src/main.rs* file. You’ll be writing all the code in this file.
-->
<p>Ouvrez à nouveau le fichier <em>src/main.rs</em>. C'est dans ce fichier que nous
écrirons la totalité de notre code.</p>
<!--
## Processing a Guess
-->
<h2><a class="header" href="#traitement-dun-nombre-saisi" id="traitement-dun-nombre-saisi">Traitement d'un nombre saisi</a></h2>
<!--
The first part of the guessing game program will ask for user input, process
that input, and check that the input is in the expected form. To start, we’ll
allow the player to input a guess. Enter the code in Listing 2-1 into
*src/main.rs*.
-->
<p>La première partie du programme consiste à demander au joueur de saisir du
texte, à traiter cette saisie, et à vérifier que la saisie correspond au format
attendu.
Commençons par permettre au joueur de saisir son nombre. Entrez le
code de l'encart 2-1 dans le fichier <em>src/main.rs</em>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
use std::io;

fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin().read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
```
-->
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!(&quot;Devinez le nombre !&quot;);

    println!(&quot;Veuillez entrer un nombre.&quot;);

    let mut supposition = String::new();

    io::stdin().read_line(&amp;mut supposition)
        .expect(&quot;Échec de la lecture de l'entrée utilisateur&quot;);

    println!(&quot;Votre nombre : {}&quot;, supposition);
}
</code></pre>
<!--
<span class="caption">Listing 2-1: Code that gets a guess from the user and
prints it</span>
-->
<p><span class="caption">Encart 2-1 : Code permettant de récupérer une saisie
utilisateur et de l'afficher</span></p>
<!--
This code contains a lot of information, so let’s go over it line by line. To
obtain user input and then print the result as output, we need to bring the
`io` (input/output) library into scope. The `io` library comes from the
standard library (which is known as `std`):
-->
<p>Ce code contient beaucoup d'informations, nous allons donc l'analyser petit
à petit. Pour obtenir la saisie utilisateur et ensuite l'afficher, nous avons
besoin d'importer la bibliothèque <code>io</code> (pour <em>input/output</em>, entrée/sortie) afin
de pouvoir l'utiliser. La bibliothèque <code>io</code> provient de la bibliothèque standard
(qui est aussi connue sous le nom de <code>std</code>).</p>
<pre><code class="language-rust ignore">use std::io;
</code></pre>
<!--
By default, Rust brings only a few types into the scope of every program in
[the *prelude*][prelude]<!-- ignore -- >. If a type you want to use isn’t in the
prelude, you have to bring that type into scope explicitly with a `use`
statement. Using the `std::io` library provides you with a number of useful
features, including the ability to accept user input.
-->
<p>Par défaut, Rust n'importe que très peu de types dans les programmes, qui sont
présents dans <a href="https://doc.rust-lang.org/std/prelude/index.html"><em>l'étape préliminaire (the prelude)</em></a><!-- ignore -->. Si
vous voulez utiliser un type qui ne s'y trouve pas, vous devrez l'importer
explicitement avec l'instruction <code>use</code>. L'utilisation de la bibliothèque
<code>std::io</code> vous apporte de nombreuses fonctionnalités utiles, comme ici la
possibilité de récupérer une saisie utilisateur.</p>
<!-- [prelude]: ../std/prelude/index.html -->
<!--
As you saw in Chapter 1, the `main` function is the entry point into the
program:
-->
<p>Comme vous l'avez vu au chapitre 1, la fonction <code>main</code> est le point d'entrée
du programme :</p>
<pre><code class="language-rust ignore">fn main() {
</code></pre>
<!--
The `fn` syntax declares a new function, the parentheses, `()`, indicate there
are no parameters, and the curly bracket, `{`, starts the body of the function.
-->
<p>Le mot clé <code>fn</code> déclare une nouvelle fonction, les parenthèses <code>()</code> indiquent
que cette fonction n'accepte aucun paramètre, et l'accolade ouvrante <code>{</code> marque
le début du corps de la fonction.</p>
<!--
As you also learned in Chapter 1, `println!` is a macro that prints a string to
the screen:
-->
<p>Comme vous l'avez également appris au chapitre 1, <code>println!</code> est une macro qui
affiche une chaîne de caractères à l'écran :</p>
<!--
```rust,ignore
println!("Guess the number!");

println!("Please input your guess.");
```
-->
<pre><code class="language-rust ignore">println!(&quot;Devinez le nombre !&quot;);

println!(&quot;Veuillez entrer un nombre.&quot;);
</code></pre>
<!--
This code is printing a prompt stating what the game is and requesting input
from the user.
-->
<p>Ce code affiche du texte qui indique le titre de notre jeu, et un autre qui
demande au joueur d'entrer un nombre.</p>
<!--
### Storing Values with Variables
-->
<h3><a class="header" href="#enregistrer-des-données-dans-des-variables" id="enregistrer-des-données-dans-des-variables">Enregistrer des données dans des variables</a></h3>
<!--
Next, we’ll create a place to store the user input, like this:
-->
<p>Ensuite, on crée un endroit où stocker la saisie de l'utilisateur, comme ceci :</p>
<!--
```rust,ignore
let mut guess = String::new();
```
-->
<pre><code class="language-rust ignore">let mut supposition = String::new();
</code></pre>
<!--
Now the program is getting interesting! There’s a lot going on in this little
line. Notice that this is a `let` statement, which is used to create a
*variable*. Here’s another example:
-->
<p>Le programme commence à devenir intéressant ! Il se passe beaucoup de choses
dans cette petite ligne. Vous remarquerez qu'elle commence par le mot-clé <code>let</code>,
qui sert à créer une <em>variable</em>. Voici un autre exemple :</p>
<pre><code class="language-rust ignore">let foo = bar;
</code></pre>
<!--
This line creates a new variable named `foo` and binds it to the value of the
`bar` variable. In Rust, variables are immutable by default. We’ll be
discussing this concept in detail in the [“Variables and
Mutability”][variables-and-mutability]<!-- ignore -- > section in Chapter 3.
The following example shows how to use `mut` before the variable name to make
a variable mutable:
-->
<p>Cette ligne permet de créer une nouvelle variable nommée <code>foo</code> et à lui
assigner la valeur de <code>bar</code>. Par défaut en Rust, les variables sont immuables.
Nous aborderons plus en détail cette notion dans la section <a href="ch03-01-variables-and-mutability.html">“Variables et
Mutabilité”</a><!-- ignore --> au chapitre 3. L'exemple
suivant montre comment utiliser le mot-clé <code>mut</code> avant le nom de la variable
pour rendre une variable mutable <em>(c'est-à-dire modifiable)</em> :</p>
<!--
```rust,ignore
let foo = 5; // immutable
let mut bar = 5; // mutable
```
-->
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let foo = 5; // immuable
let mut bar = 5; // mutable, modifiable
#}</code></pre></pre>
<!--
> Note: The `//` syntax starts a comment that continues until the end of the
> line. Rust ignores everything in comments, which are discussed in more detail
> in Chapter 3.
-->
<blockquote>
<p>Remarque : La syntaxe <code>//</code> permet de commencer un commentaire qui s'étend
jusqu'à la fin de la ligne. Rust ignore tout ce qu'il y a dans un commentaire,
ceci sera développé plus en détail dans le chapitre 3.</p>
</blockquote>
<!--
Let’s return to the guessing game program. You now know that `let mut guess`
will introduce a mutable variable named `guess`. On the other side of the equal
sign (`=`) is the value that `guess` is bound to, which is the result of
calling `String::new`, a function that returns a new instance of a `String`.
[`String`][string]<!-- ignore -- > is a string type provided by the standard
library that is a growable, UTF-8 encoded bit of text.
-->
<p>Mais revenons à notre jeu de devinettes. Vous comprenez donc maintenant que la
ligne <code>let mut supposition</code> permet de créer une variable mutable nommée
<code>supposition</code>. De l'autre côté du signe égal (<code>=</code>) se trouve la valeur de cette
variable, et il s'agit ici du résultat de l'utilisation de <code>String::new</code>, qui
est une fonction qui retourne une nouvelle instance de <code>String</code>.
<a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a><!-- ignore --> est un type de chaîne de caractères fourni
par la bibliothèque standard, qui est une portion de texte encodée en UTF-8 et
dont la longueur peut augmenter.</p>
<!-- [string]: ../std/string/struct.String.html -->
<!--
The `::` syntax in the `::new` line indicates that `new` is an *associated
function* of the `String` type. An associated function is implemented on a type,
in this case `String`, rather than on a particular instance of a `String`. Some
languages call this a *static method*.
-->
<p>La syntaxe <code>::</code> dans <code>String::new()</code> indique que <code>new</code> est une
<em>fonction associée</em> au type <code>String</code>. Une fonction associée est implémentée sur
un type, ici <code>String</code>, plutôt que sur une instance de <code>String</code>. Ce concept est
parfois appelé une <em>méthode statique</em> dans d'autres langages.</p>
<!--
This `new` function creates a new, empty string. You’ll find a `new` function
on many types, because it’s a common name for a function that makes a new value
of some kind.
-->
<p>Cette fonction <code>new</code> crée une nouvelle chaîne de caractères vide, une nouvelle
<code>String</code>. Vous trouverez fréquemment une fonction <code>new</code> sur d'autres types, car
c'est un nom souvent donné à une fonction qui crée une nouvelle valeur ou
instance d'un type.</p>
<!--
To summarize, the `let mut guess = String::new();` line has created a mutable
variable that is currently bound to a new, empty instance of a `String`. Whew!
-->
<p>Pour résumer, la ligne <code>let mut supposition = String::new();</code> crée une nouvelle
variable mutable qui contient une nouvelle chaîne de caractères vide, une
instance de <code>String</code>. Ouf !</p>
<!--
Recall that we included the input/output functionality from the standard
library with `use std::io;` on the first line of the program. Now we’ll call
the `stdin` function from the `io` module:
-->
<p>Rappelez-vous que nous avons importé les fonctionnalités d'entrée/sortie de la
bibliothèque standard avec <code>use std::io;</code> à la première ligne de notre
programme. Nous allons maintenant appeler la fonction <code>stdin</code> du
module <code>io</code> :</p>
<!--
```rust,ignore
io::stdin().read_line(&mut guess)
    .expect("Failed to read line");
```
-->
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut supposition)
    .expect(&quot;Échec de la lecture de l'entrée utilisateur&quot;);
</code></pre>
<!--
If we hadn’t listed the `use std::io` line at the beginning of the program, we
could have written this function call as `std::io::stdin`. The `stdin` function
returns an instance of [`std::io::Stdin`][iostdin]<!-- ignore -- >, which is a
type that represents a handle to the standard input for your terminal.
-->
<p>Si la ligne <code>use std::io</code> n'était pas présente au début du programme, on aurait
dû écrire l'appel à la fonction de cette manière : <code>std::io::stdin</code>. La fonction
<code>stdin</code> retourne une instance de <a href="https://doc.rust-lang.org/std/io/struct.Stdin.html"><code>std::io::Stdin</code></a><!-- ignore -->, qui
est un type qui représente une référence abstraite <em>(handle)</em> vers l'entrée
standard du terminal dans lequel vous avez lancé le programme.</p>
<!-- [iostdin]: ../std/io/struct.Stdin.html -->
<!--
The next part of the code, `.read_line(&mut guess)`, calls the
[`read_line`][read_line]<!-- ignore -- > method on the standard input handle to
get input from the user. We’re also passing one argument to `read_line`: `&mut
guess`.
-->
<p>La partie suivante du code, <code>.read_line(&amp;mut supposition)</code>, appelle la méthode
<a href="https://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a><!-- ignore --> sur l'entrée standard afin d'obtenir
la saisie utilisateur. De plus, on passe à cette méthode l'argument
<code>&amp;mut supposition</code>.</p>
<!-- [read_line]: ../std/io/struct.Stdin.html#method.read_line -->
<!--
The job of `read_line` is to take whatever the user types into standard input
and place that into a string, so it takes that string as an argument. The
string argument needs to be mutable so the method can change the string’s
content by adding the user input.
-->
<p>Le rôle de <code>read_line</code> est de récupérer tout ce que l'utilisateur écrit dans
l'entrée standard et de le stocker dans une chaîne de caractères ; c'est
pourquoi cette méthode prend une <code>String</code> comme argument. Cet argument doit être
mutable pour que <code>read_line</code> puisse en modifier le contenu en y ajoutant
la saisie de l'utilisateur.</p>
<!--
The `&` indicates that this argument is a *reference*, which gives you a way to
let multiple parts of your code access one piece of data without needing to
copy that data into memory multiple times. References are a complex feature,
and one of Rust’s major advantages is how safe and easy it is to use
references. You don’t need to know a lot of those details to finish this
program. For now, all you need to know is that like variables, references are
immutable by default. Hence, you need to write `&mut guess` rather than
`&guess` to make it mutable. (Chapter 4 will explain references more
thoroughly.)
-->
<p>Le <code>&amp;</code> indique que cet argument est une <em>référence</em>, ce qui permet de laisser
plusieurs morceaux de votre code accéder à une même donnée sans avoir besoin
de copier ces données dans la mémoire plusieurs fois. Les références sont une
fonctionnalité complexe, et un des avantages majeurs de Rust est qu'il rend sûr
et simple l'utilisation des références. Il n'est pas nécessaire de trop
s'apesantir sur les références pour terminer ce programme.
Pour l'instant, tout ce que vous devez savoir est que comme les variables, les
références sont immuables par défaut.
D'où la nécessité d'écrire <code>&amp;mut supposition</code> au lieu de <code>&amp;supposition</code> pour la
rendre mutable. (Le chapitre 4 expliquera plus en détail les références.)</p>
<!--
### Handling Potential Failure with the `Result` Type
-->
<h3><a class="header" href="#gérer-les-erreurs-potentielles-avec-le-type-result" id="gérer-les-erreurs-potentielles-avec-le-type-result">Gérer les erreurs potentielles avec le type <code>Result</code></a></h3>
<!--
We’re not quite done with this line of code. Although what we’ve discussed so
far is a single line of text, it’s only the first part of the single logical
line of code. The second part is this method:
-->
<p>Nous n'en avons pas tout à fait fini avec cette ligne de code.
Nous avons abordé jusqu'ici une seule ligne de texte, mais ce n'est que la
première partie de la ligne de code.
La deuxième partie est cette méthode :</p>
<!--
```rust,ignore
.expect("Failed to read line");
```
-->
<pre><code class="language-rust ignore">.expect(&quot;Échec de la lecture de l'entrée utilisateur&quot;);
</code></pre>
<!--
When you call a method with the `.foo()` syntax, it’s often wise to introduce a
newline and other whitespace to help break up long lines. We could have
written this code as:
-->
<p>Lorsque l'on appelle une méthode avec la syntaxe <code>.foo()</code>, il est généralement
préférable d'ajouter un retour à la ligne puis d'indenter à l'aide d'espaces
pour décomposer les longues lignes de code.
Nous aurions pu écrire ce code de cette manière :</p>
<!--
```rust,ignore
io::stdin().read_line(&mut guess).expect("Failed to read line");
```
-->
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut supposition).expect(&quot;Échec de la lecture de l'entrée utilisateur&quot;);
</code></pre>
<!--
However, one long line is difficult to read, so it’s best to divide it: two
lines for two method calls. Now let’s discuss what this line does.
-->
<p>Cependant, une longue ligne de code n'est pas toujours facile à lire, c'est donc
une bonne pratique de la diviser : deux lignes de texte pour deux appels de
méthodes. Mais maintenant, voyons à quoi sert cette ligne.</p>
<!--
As mentioned earlier, `read_line` puts what the user types into the string
we’re passing it, but it also returns a value—in this case, an
[`io::Result`][ioresult]<!-- ignore -- >. Rust has a number of types named
`Result` in its standard library: a generic [`Result`][result]<!-- ignore -- >
as well as specific versions for submodules, such as `io::Result`.
-->
<p>Comme expliqué précédemment, <code>read_line</code> stocke ce que l'utilisateur a saisi
dans la variable qu'on lui passe en argument, mais cette fonction retourne
aussi une valeur − dans notre cas, de type
<a href="https://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a><!-- ignore -->. Il existe plusieurs types nommés
<code>Result</code> dans la bibliothèque standard de Rust : un type générique
<a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a><!-- ignore --> ainsi que des déclinaisons spécifiques à
des sous-modules, comme <code>io::Result</code>.</p>
<!-- [ioresult]: ../std/io/type.Result.html -->
<!-- [result]: ../std/result/enum.Result.html -->
<!--
The `Result` types are [*enumerations*][enums]<!-- ignore -- >, often referred
to as *enums*. An enumeration is a type that can have a fixed set of values,
and those values are called the enum’s *variants*. Chapter 6 will cover enums
in more detail.
-->
<p>Les types <code>Result</code> sont des <a href="ch06-00-enums.html"><em>énumérations</em></a><!-- ignore -->, aussi
appelées <em>enums</em>. Une énumération est un type qui peut avoir un certain nombre
de valeurs prédéfinies, et ces valeurs sont appelées des <em>variantes</em>
d'énumération. Le chapitre 6 explorera les énumérations plus en détail.</p>
<!--
For `Result`, the variants are `Ok` or `Err`. The `Ok` variant indicates the
operation was successful, and inside `Ok` is the successfully generated value.
The `Err` variant means the operation failed, and `Err` contains information
about how or why the operation failed.
-->
<p>Avec <code>Result</code>, les variantes sont <code>Ok</code> ou <code>Err</code>. La variante <code>Ok</code> signifie que
l'opération a fonctionné, et à l'intérieur de <code>Ok</code> se trouve la valeur générée
avec succès. La variante <code>Err</code> signifie que l'opération a échoué, et <code>Err</code>
contient les informations décrivant comment ou pourquoi l'opération a échoué.</p>
<!--
The purpose of these `Result` types is to encode error-handling information.
Values of the `Result` type, like values of any type, have methods defined on
them. An instance of `io::Result` has an [`expect` method][expect]<!-- ignore
-- > that you can call. If this instance of `io::Result` is an `Err` value,
`expect` will cause the program to crash and display the message that you
passed as an argument to `expect`. If the `read_line` method returns an `Err`,
it would likely be the result of an error coming from the underlying operating
system. If this instance of `io::Result` is an `Ok` value, `expect` will take
the return value that `Ok` is holding and return just that value to you so you
can use it. In this case, that value is the number of bytes in what the user
entered into standard input.
-->
<p>L'objectif de ces types <code>Result</code> est d'encoder des informations utiles à la
gestion des erreurs.
Les valeurs du type <code>Result</code>, comme pour tous les types, ont des méthodes
qui leur sont associées. Par exemple, une instance de <code>io::Result</code> a une
<a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.expect">méthode <code>expect</code></a><!-- ignore --> que vous pouvez utiliser. Si cette
instance de <code>io::Result</code> a pour valeur la variante <code>Err</code>, l'appel à <code>expect</code>
fera planter le programme et affichera le message que vous avez passé en
argument de <code>expect</code>. Si l'appel à <code>read_line</code> retourne une variante <code>Err</code>, ce
sera probablement dû à une erreur du système d'exploitation. Si en revanche
<code>read_line</code> a pour valeur la variante <code>Ok</code>, <code>expect</code> récupèrera le
contenu du <code>Ok</code>, qui est le résultat de l'opération, et vous le retournera afin
que vous puissiez l'utiliser. Dans notre exemple, ce résultat est le nombre
d'octets que l'utilisateur a saisi dans l'entrée standard.</p>
<!-- [expect]: ../std/result/enum.Result.html#method.expect -->
<!--
If you don’t call `expect`, the program will compile, but you’ll get a warning:
-->
<p>Si on n'appelle pas <code>expect</code>, le programme compilera, mais avec un
avertissement :</p>
<!--
```text
$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `std::result::Result` which must be used
  -- > src/main.rs:10:5
   |
10 |     io::stdin().read_line(&mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: #[warn(unused_must_use)] on by default
```
-->
<pre><code class="language-text">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `std::result::Result` which must be used
  -- &gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut supposition);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: #[warn(unused_must_use)] on by default
</code></pre>
<!--
Rust warns that you haven’t used the `Result` value returned from `read_line`,
indicating that the program hasn’t handled a possible error.
-->
<p>Rust nous prévient que l'on ne fait rien du <code>Result</code> que nous fournit
<code>read_line</code>, et que par conséquent notre programme ne gère pas une erreur
potentielle.</p>
<!--
The right way to suppress the warning is to actually write error handling, but
because you just want to crash this program when a problem occurs, you can use
`expect`. You’ll learn about recovering from errors in Chapter 9.
-->
<p>La meilleure façon de masquer cet avertissement est de réellement écrire le
code permettant de gérer l'erreur, mais dans notre cas on a seulement besoin de
faire planter le programme si un problème survient, on utilise donc <code>expect</code>.
Nous verrons dans le chapitre 9 comment gérer correctement les erreurs.</p>
<!--
### Printing Values with `println!` Placeholders
-->
<h3><a class="header" href="#afficher-des-valeurs-grâce-aux-espaces-réservés-de-println" id="afficher-des-valeurs-grâce-aux-espaces-réservés-de-println">Afficher des valeurs grâce aux espaces réservés de <code>println!</code></a></h3>
<!--
Aside from the closing curly brackets, there’s only one more line to discuss in
the code added so far, which is the following:
-->
<p>Mis à part l'accolade fermante, il ne nous reste plus qu'une seule ligne à
étudier dans le code que nous avons pour l'instant :</p>
<!--
```rust,ignore
println!("You guessed: {}", guess);
```
-->
<pre><code class="language-rust ignore">println!(&quot;Votre nombre : {}&quot;, supposition);
</code></pre>
<!--
This line prints the string we saved the user’s input in. The set of curly
brackets, `{}`, is a placeholder: think of `{}` as little crab pincers that
hold a value in place. You can print more than one value using curly brackets:
the first set of curly brackets holds the first value listed after the format
string, the second set holds the second value, and so on. Printing multiple
values in one call to `println!` would look like this:
-->
<p>Cette ligne affiche la chaîne de caractères où est stocké ce que l'utilisateur
a saisi. La paire d'accolades <code>{}</code> représente un espace réservé : imaginez
qu'il s'agit de pinces de crabes qui gardent la place d'une valeur. Vous pouvez
afficher plusieurs valeurs en utilisant des accolades : la première paire
d'accolades affichera la première valeur listée après la chaîne de formatage,
la deuxième paire d'accolades affichera la deuxième valeur, et ainsi de suite.
Pour afficher plusieurs valeurs en appelant <code>println!</code> une seule fois, on ferait
comme ceci :</p>
<!--
```rust
let x = 5;
let y = 10;

println!("x = {} and y = {}", x, y);
```
-->
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = 10;

println!(&quot;x = {} et y = {}&quot;, x, y);
#}</code></pre></pre>
<!--
This code would print `x = 5 and y = 10`.
-->
<p>Ce code afficherait <code>x = 5 et y = 10</code>.</p>
<!--
### Testing the First Part
-->
<h3><a class="header" href="#test-de-la-première-partie" id="test-de-la-première-partie">Test de la première partie</a></h3>
<!--
Let’s test the first part of the guessing game. Run it using `cargo run`:
-->
<p>Pour tester notre début de programme, lançons-le à l'aide de la commande
<code>cargo run</code> :</p>
<!--
```text
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
```
-->
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
     Running `target/debug/guessing_game`
Devinez le nombre !
Veuillez entrer un nombre.
6
Votre nombre : 6
</code></pre>
<!--
At this point, the first part of the game is done: we’re getting input from the
keyboard and then printing it.
-->
<p>À ce stade, la première partie de notre programme est terminée : nous avons
récupéré la saisie du clavier et nous l'affichons à l'écran.</p>
<!--
## Generating a Secret Number
-->
<h2><a class="header" href="#générer-le-nombre-secret" id="générer-le-nombre-secret">Générer le nombre secret</a></h2>
<!--
Next, we need to generate a secret number that the user will try to guess. The
secret number should be different every time so the game is fun to play more
than once. Let’s use a random number between 1 and 100 so the game isn’t too
difficult. Rust doesn’t yet include random number functionality in its standard
library. However, the Rust team does provide a [`rand` crate][randcrate].
-->
<p>Maintenant, il nous faut générer un nombre secret que notre joueur va devoir
deviner. Ce nombre devra être différent à chaque fois pour qu'on puisse
s'amuser à y jouer plusieurs fois. Tirons au sort un nombre compris entre
1 et 100 pour que le jeu ne soit pas trop difficile. Rust n'embarque pas pour
l'instant de fonctionnalité de génération de nombres aléatoires dans sa
bibliothèque standard. Cependant, l'équipe de Rust propose une
<a href="https://crates.io/crates/rand"><em>crate</em> <code>rand</code></a>.</p>
<!--
### Using a Crate to Get More Functionality
-->
<h3><a class="header" href="#Étendre-les-fonctionnalités-de-rust-avec-une-crate" id="Étendre-les-fonctionnalités-de-rust-avec-une-crate">Étendre les fonctionnalités de Rust avec une <em>crate</em></a></h3>
<!--
Remember that a crate is a collection of Rust source code files.
The project we’ve been building is a *binary crate*, which is an executable.
The `rand` crate is a *library crate*, which contains code intended to be
used in other programs.
-->
<p>Souvenez-vous, une <em>crate</em> est un ensemble de fichiers de code source Rust.
Le projet sur lequel nous travaillons est une <em>crate</em> binaire, qui est un
programme exécutable.
La <em>crate</em> <code>rand</code> est une <em>crate de bibliothèque</em>, qui contient du
code qui peut être utilisé dans d'autres programmes.</p>
<!--
Cargo’s use of external crates is where it really shines. Before we can write
code that uses `rand`, we need to modify the *Cargo.toml* file to include the
`rand` crate as a dependency. Open that file now and add the following line to
the bottom beneath the `[dependencies]` section header that Cargo created for
you:
-->
<p>L'utilisation des <em>crates</em> externes est un domaine dans lequel Cargo excelle.
Avant d'écrire le code qui utilisera <code>rand</code>, il nous faut éditer le fichier
<em>Cargo.toml</em> pour y spécifier <code>rand</code> en tant que dépendance. Ouvrez donc
maintenant ce fichier et ajoutez la ligne suivante à la fin, en dessous de
l'en-tête de section <code>[dependencies]</code> que Cargo a créé pour vous :</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">Fichier : Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.3.14&quot;
</code></pre>
<!--
In the *Cargo.toml* file, everything that follows a header is part of a section
that continues until another section starts. The `[dependencies]` section is
where you tell Cargo which external crates your project depends on and which
versions of those crates you require. In this case, we’ll specify the `rand`
crate with the semantic version specifier `0.3.14`. Cargo understands [Semantic
Versioning][semver]<!-- ignore -- > (sometimes called *SemVer*), which is a
standard for writing version numbers. The number `0.3.14` is actually shorthand
for `^0.3.14`, which means “any version that has a public API compatible with
version 0.3.14.”
-->
<p>Dans le fichier <em>Cargo.toml</em>, tout ce qui suit une en-tête fait partie de cette
section, et ce jusqu'à ce qu'une autre section débute. La section
<code>[dependencies]</code> permet d'indiquer à Cargo de quelles <em>crates</em> externes votre
projet dépend, et de quelle version de ces <em>crates</em> vous avez besoin.
Dans notre cas, on ajoute comme dépendance la crate <code>rand</code> avec la version
sémantique <code>0.3.14</code>. Cargo arrive à interpréter le
<a href="http://semver.org">versionnage sémantique</a><!-- ignore --> (aussi appelé <em>SemVer</em>), qui
est une convention d'écriture de numéros de version. En réalité, <code>0.3.14</code> est
une abréviation pour <code>^0.3.14</code>, ce qui signifie “toute version qui propose une
API publique compatible avec la version 0.3.14”.</p>
<!--
Now, without changing any of the code, let’s build the project, as shown in
Listing 2-2.
-->
<p>Maintenant, sans apporter le moindre changement au code, lançons une compilation
du projet, comme dans l'encart 2-2 :</p>
<pre><code class="language-text">$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading rand v0.3.14
 Downloading libc v0.2.14
   Compiling libc v0.2.14
   Compiling rand v0.3.14
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<!--
<span class="caption">Listing 2-2: The output from running `cargo build` after
adding the rand crate as a dependency</span>
-->
<p><span class="caption">Encart 2-2 : Résultat du lancement de <code>cargo build</code> après
avoir ajouté la <em>crate</em> <code>rand</code> comme dépendance</span></p>
<!--
You may see different version numbers (but they will all be compatible with
the code, thanks to SemVer!), and the lines may be in a different order.
-->
<p>Il est possible que vous ne voyiez pas exactement les mêmes numéros de version,
(mais ils seront compatibles avec votre code, grâce au <em>versionnage
sémantique</em> !), et les lignes ne seront pas forcément affichées dans le même
ordre.</p>
<!--
Now that we have an external dependency, Cargo fetches the latest versions of
everything from the *registry*, which is a copy of data from
[Crates.io][cratesio]. Crates.io is where people in the Rust ecosystem post
their open source Rust projects for others to use.
-->
<p>Maintenant que nous avons une dépendance externe, Cargo récupère la dernière
version de tout ce qui nous faut depuis le <em>registre</em>, qui est une copie des
données de <a href="https://crates.io/">Crates.io</a>. Crates.io est là où les développeurs de
l'écosystème Rust publient leurs projets open source afin de les rendre
disponibles aux autres.</p>
<!--
After updating the registry, Cargo checks the `[dependencies]` section and
downloads any crates you don’t have yet. In this case, although we only listed
`rand` as a dependency, Cargo also grabbed a copy of `libc`, because `rand`
depends on `libc` to work. After downloading the crates, Rust compiles them and
then compiles the project with the dependencies available.
-->
<p>Une fois le registre mis à jour, Cargo lit la section <code>[dependencies]</code> et se
charge de télécharger les <em>crates</em> que vous n'avez pas encore. Dans notre cas,
bien que nous n'ayons spécifié qu'une seule dépendance, <code>rand</code>, Cargo a aussi
téléchargé la <em>crate</em> <code>libc</code>, car <code>rand</code> dépend de <code>libc</code> pour fonctionner. Une
fois le téléchargement terminé des <em>crates</em>, Rust les compile, puis compile
notre projet avec les dépendances disponibles.</p>
<!--
If you immediately run `cargo build` again without making any changes, you
won’t get any output aside from the `Finished` line. Cargo knows it has already
downloaded and compiled the dependencies, and you haven’t changed anything
about them in your *Cargo.toml* file. Cargo also knows that you haven’t changed
anything about your code, so it doesn’t recompile that either. With nothing to
do, it simply exits.
-->
<p>Si vous relancez tout de suite <code>cargo build</code> sans changer quoi que ce soit, vous
n'obtiendrez rien d'autre que la ligne <code>Finished</code>. Cargo sait qu'il a déjà
téléchargé et compilé les dépendances, et que vous n'avez rien changé dans votre
fichier <em>Cargo.toml</em>. Cargo sait aussi que vous n'avez rien changé dans votre
code, donc il ne le recompile pas non plus. Étant donné qu'il n'a rien à faire,
Cargo se termine tout simplement.</p>
<!--
If you open up the *src/main.rs* file, make a trivial change, and then save it
and build again, you’ll only see two lines of output:
-->
<p>Si vous ouvrez le fichier <em>src/main.rs</em>, faites un changement très simple,
enregistrez le fichier, et relancez la compilation, vous verrez s'afficher
uniquement deux lignes :</p>
<pre><code class="language-text">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<!--
These lines show Cargo only updates the build with your tiny change to the
*src/main.rs* file. Your dependencies haven’t changed, so Cargo knows it can
reuse what it has already downloaded and compiled for those. It just rebuilds
your part of the code.
-->
<p>Ces lignes nous informent que Cargo a recompilé uniquement à cause de notre
petit changement dans le fichier <em>src/main.rs</em>. Les dépendances n'ayant pas
changé, Cargo sait qu'il peut simplement réutiliser ce qu'il a déjà téléchargé
et compilé précédemment. Il se contente donc de ne recompiler que notre partie
du code.</p>
<!--
#### Ensuring Reproducible Builds with the *Cargo.lock* File
-->
<h4><a class="header" href="#assurer-la-reproductibilité-des-compilations-avec-le-fichier-cargolock" id="assurer-la-reproductibilité-des-compilations-avec-le-fichier-cargolock">Assurer la reproductibilité des compilations avec le fichier <em>Cargo.lock</em></a></h4>
<!--
Cargo has a mechanism that ensures you can rebuild the same artifact every time
you or anyone else builds your code: Cargo will use only the versions of the
dependencies you specified until you indicate otherwise. For example, what
happens if next week version 0.3.15 of the `rand` crate comes out and
contains an important bug fix but also contains a regression that will break
your code?
-->
<p>Cargo embarque une fonctionnalité qui garantie que vous pouvez recompiler le
même artéfact à chaque fois que vous ou quelqu'un d'autre compile votre code :
Cargo va utiliser uniquement les versions de dépendances que vous avez
utilisées jusqu'à ce que vous indiquiez le contraire.
Par exemple, que se passe-t-il si la semaine prochaine, la version 0.3.15 de la
<em>crate</em> <code>rand</code> est publiée et qu'elle apporte une correction importante, mais
aussi qu'elle produit une régression qui va casser votre code ?</p>
<!--
The answer to this problem is the *Cargo.lock* file, which was created the
first time you ran `cargo build` and is now in your *guessing_game* directory.
When you build a project for the first time, Cargo figures out all the
versions of the dependencies that fit the criteria and then writes them to
the *Cargo.lock* file. When you build your project in the future, Cargo will
see that the *Cargo.lock* file exists and use the versions specified there
rather than doing all the work of figuring out versions again. This lets you
have a reproducible build automatically. In other words, your project will
remain at `0.3.14` until you explicitly upgrade, thanks to the *Cargo.lock*
file.
-->
<p>La réponse à ce problème est le fichier <em>Cargo.lock</em>, qui a été créé la première
fois que vous avez utilisé <code>cargo build</code> et qui se trouve désormais dans votre
dossier <em>guessing_game</em>. Quand vous compilez un projet pour la première fois,
Cargo détermine toutes les versions de dépendances qui correspondent à vos
critères et les écrit dans le fichier <em>Cargo.lock</em>.
Quand vous recompilerez votre projet plus tard, Cargo verra que le fichier
<em>Cargo.lock</em> existe et utilisera les versions précisées à l'intérieur au lieu
de recommencer à déterminer toutes les versions demandées.
Ceci vous permet d'avoir automatiquement des compilations reproductibles.
En d'autres termes, votre projet va rester sur la version <code>0.3.14</code> jusqu'à ce
que vous le mettiez à jour explicitement, grâce au fichier <em>Cargo.lock</em>.</p>
<!--
#### Updating a Crate to Get a New Version
-->
<h4><a class="header" href="#mettre-à-jour-une-crate-vers-sa-nouvelle-version" id="mettre-à-jour-une-crate-vers-sa-nouvelle-version">Mettre à jour une <em>crate</em> vers sa nouvelle version</a></h4>
<!--
When you *do* want to update a crate, Cargo provides another command, `update`,
which will ignore the *Cargo.lock* file and figure out all the latest versions
that fit your specifications in *Cargo.toml*. If that works, Cargo will write
those versions to the *Cargo.lock* file.
-->
<p>Lorsque vous souhaitez réellement mettre à jour une <em>crate</em>, Cargo vous fournit
une autre commande, <code>update</code>, qui va ignorer le fichier <em>Cargo.lock</em> et va
rechercher toutes les versions qui correspondent à vos critères dans
<em>Cargo.toml</em>. Si cela se passe bien, Cargo va écrire ces versions dans le
fichier <em>Cargo.lock</em>.</p>
<!--
But by default, Cargo will only look for versions greater than `0.3.0` and less
than `0.4.0`. If the `rand` crate has released two new versions, `0.3.15` and
`0.4.0`, you would see the following if you ran `cargo update`:
-->
<p>Mais par défaut, Cargo va rechercher uniquement les versions plus grandes que
<code>0.3.0</code> et inférieures à <code>0.4.0</code>. Si la <em>crate</em> <code>rand</code> a été publiée en deux
nouvelles versions, <code>0.3.15</code> et <code>0.4.0</code>, alors vous verrez ceci si vous
lancez <code>cargo update</code> :</p>
<pre><code class="language-text">$ cargo update
    Updating registry `https://github.com/rust-lang/crates.io-index`
    Updating rand v0.3.14 -&gt; v0.3.15
</code></pre>
<!--
At this point, you would also notice a change in your *Cargo.lock* file noting
that the version of the `rand` crate you are now using is `0.3.15`.
-->
<p>À partir de ce moment, vous pouvez aussi constater un changement dans le fichier
<em>Cargo.lock</em> indiquant que la version de la <em>crate</em> <code>rand</code> que vous utilisez
maintenant est la <code>0.3.15</code>.</p>
<!--
If you wanted to use `rand` version `0.4.0` or any version in the `0.4.x`
series, you’d have to update the *Cargo.toml* file to look like this instead:
-->
<p>Si vous vouliez utiliser <code>rand</code> en version <code>0.4.0</code> ou toute autre version dans
la série des <code>0.4.x</code>, il vous faut mettre à jour le fichier <em>Cargo.toml</em> comme
ceci :</p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.4.0&quot;
</code></pre>
<!--
The next time you run `cargo build`, Cargo will update the registry of crates
available and reevaluate your `rand` requirements according to the new version
you have specified.
-->
<p>La prochaine fois que vous lancerez <code>cargo build</code>, Cargo mettra à jour son
registre de <em>crates</em> disponibles et réévaluera vos exigences vis-à-vis de <code>rand</code>
selon la nouvelle version que vous avez spécifiée.</p>
<!--
There’s a lot more to say about [Cargo][doccargo]<!-- ignore -- > and [its
ecosystem][doccratesio]<!-- ignore -- > which we’ll discuss in Chapter 14, but
for now, that’s all you need to know. Cargo makes it very easy to reuse
libraries, so Rustaceans are able to write smaller projects that are assembled
from a number of packages.
-->
<p>Il y a encore plus à dire à propos de <a href="http://doc.crates.io">Cargo</a><!-- ignore --> et de
<a href="http://doc.crates.io/crates-io.html">son écosystème</a><!-- ignore --> que nous aborderons au chapitre 14,
mais pour l'instant, c'est tout ce qu'il vous faut savoir. Cargo
facilite la réutilisation des bibliothèques, pour que les Rustacés soient
capables d'écrire des petits projets issus d'un assemblage d'un certain
nombre de paquets.</p>
<!--
### Generating a Random Number
-->
<h3><a class="header" href="#générer-un-nombre-aléatoire" id="générer-un-nombre-aléatoire">Générer un nombre aléatoire</a></h3>
<!--
Now that you’ve added the `rand` crate to *Cargo.toml*, let’s start using
`rand`. The next step is to update *src/main.rs*, as shown in Listing 2-3.
-->
<p>Maintenant que vous avez ajouté la <em>crate</em> <code>rand</code> dans <em>Cargo.toml</em>, commençons
à utiliser <code>rand</code>. La prochaine étape est de modifier <em>src/main.rs</em> comme dans
l'encart 2-3.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
use std::io;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!("The secret number is: {}", secret_number);

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin().read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
```
-->
<pre><code class="language-rust ignore">use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Devinez le nombre !&quot;);

    let nombre_secret = rand::thread_rng().gen_range(1, 101);

    println!(&quot;Le nombre secret est : {}&quot;, nombre_secret);

    println!(&quot;Veuillez entrer un nombre.&quot;);

    let mut supposition = String::new();

    io::stdin().read_line(&amp;mut supposition)
        .expect(&quot;Échec de la lecture de l'entrée utilisateur&quot;);

    println!(&quot;Votre nombre : {}&quot;, supposition);
}
</code></pre>
<!--
<span class="caption">Listing 2-3: Adding code to generate a random
number</span>
-->
<p><span class="caption">Encart 2-3 : Ajout du code pour générer un nombre
aléatoire</span></p>
<!--
First, we add a `use` line: `use rand::Rng`. The `Rng` trait defines
methods that random number generators implement, and this trait must be in
scope for us to use those methods. Chapter 10 will cover traits in detail.
-->
<p>D'abord, nous avons ajouté une ligne <code>use</code> : <code>use rand::Rng</code>. Le <em>trait</em>
<code>Rng</code> définit les méthodes implémentées par les générateurs de nombres
aléatoires, et ce <em>trait</em> doit être accessible à notre code pour qu'on puisse
utiliser ces méthodes. Le chapitre 10 expliquera plus en détail les <em>traits</em>.</p>
<!--
Next, we’re adding two lines in the middle. The `rand::thread_rng` function
will give us the particular random number generator that we’re going to use:
one that is local to the current thread of execution and seeded by the
operating system. Then we call the `gen_range` method on the random number
generator. This method is defined by the `Rng` trait that we brought into
scope with the `use rand::Rng` statement. The `gen_range` method takes two
numbers as arguments and generates a random number between them. It’s inclusive
on the lower bound but exclusive on the upper bound, so we need to specify `1`
and `101` to request a number between 1 and 100.
-->
<p>Ensuite, nous ajoutons deux lignes au milieu. La fonction <code>rand::thread_rng</code>
nous fournit le générateur de nombres aléatoires particulier que nous allons
utiliser : il est propre au fil d'exécution courant et généré par le
système d'exploitation. Ensuite, nous appelons la méthode <code>gen_range</code> sur le
générateur de nombres aléatoires. Cette méthode est définie par le <em>trait</em> <code>Rng</code>
que nous avons importé avec l'instruction <code>use rand::Rng</code>. La méthode
<code>gen_range</code> prend deux nombres en paramètres et génère un nombre aléatoire entre
ces deux bornes. Elle inclut la borne inférieure mais exclut la borne
supérieure, nous avons donc besoin de préciser <code>1</code> et <code>101</code> pour demander un
nombre entre 1 et 100.</p>
<!--
> Note: You won’t just know which traits to use and which methods and functions
> to call from a crate. Instructions for using a crate are in each crate’s
> documentation. Another neat feature of Cargo is that you can run the `cargo
> doc --open` command, which will build documentation provided by all of your
> dependencies locally and open it in your browser. If you’re interested in
> other functionality in the `rand` crate, for example, run `cargo doc --open`
> and click `rand` in the sidebar on the left.
-->
<blockquote>
<p>Remarque : vous ne pourrez pas deviner quels <em>traits</em>, méthodes et
fonctions utiliser avec une <em>crate</em>. Les instructions pour l'utilisation
d'une <em>crate</em> se trouvent dans la documentation propre à chaque <em>crate</em>. Une
autre fonctionnalité intéressante de Cargo est que vous pouvez utiliser la
commande <code>cargo doc --open</code>, qui va construire localement la documentation
intégrée par toutes vos dépendances et va l'ouvrir dans votre navigateur.
Si vous vous intéressez à d'autres fonctionnalités de la <em>crate</em> <code>rand</code>,
par exemple, vous pouvez lancer <code>cargo doc --open</code> et cliquer sur <code>rand</code>
dans la barre latérale sur la gauche.</p>
</blockquote>
<!--
The second line that we added to the middle of the code prints the secret
number. This is useful while we’re developing the program to be able to test
it, but we’ll delete it from the final version. It’s not much of a game if the
program prints the answer as soon as it starts!
-->
<p>La seconde ligne que nous avons ajoutée au milieu du code affiche le nombre
secret. C'est pratique lors du développement pour pouvoir le tester, mais nous
l'enlèverons dans la version finale. Ce n'est pas vraiment un jeu si le
programme affiche la réponse dès qu'il démarre !</p>
<!--
Try running the program a few times:
-->
<p>Essayez de lancer le programme plusieurs fois :</p>
<!--
```text
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4
$ cargo run
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
```
-->
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
     Running `target/debug/guessing_game`
Devinez le nombre !
Le nombre secret est : 7
Veuillez entrer un nombre.
4
Votre nombre : 4
$ cargo run
     Running `target/debug/guessing_game`
Devinez le nombre !
Le nombre secret est : 83
Veuillez entrer un nombre.
5
Votre nombre : 5
</code></pre>
<!--
You should get different random numbers, and they should all be numbers between
1 and 100. Great job!
-->
<p>Vous devriez obtenir des nombres aléatoires différents, et ils devraient être
tous compris entre 1 et 100. Beau travail !</p>
<!--
## Comparing the Guess to the Secret Number
-->
<h2><a class="header" href="#comparer-le-nombre-saisi-au-nombre-secret" id="comparer-le-nombre-saisi-au-nombre-secret">Comparer le nombre saisi au nombre secret</a></h2>
<!--
Now that we have user input and a random number, we can compare them. That step
is shown in Listing 2-4. Note that this code won’t compile quite yet, as we
will explain.
-->
<p>Maintenant que nous avons une saisie utilisateur et un nombre aléatoire, nous
pouvons les comparer. Cette étape est écrite dans l'encart 2-4. Sachez toutefois
que le code ne se compile pas encore, nous allons l'expliquer par la suite.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {

    // ---snip---

    println!("You guessed: {}", guess);

    match guess.cmp(&secret_number) {
        Ordering::Less => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal => println!("You win!"),
    }
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {

    // --- code inchangé masqué ici ---

    println!(&quot;Votre nombre : {}&quot;, supposition);

    match supposition.cmp(&amp;nombre_secret) {
        Ordering::Less =&gt; println!(&quot;C'est plus !&quot;),
        Ordering::Greater =&gt; println!(&quot;C'est moins !&quot;),
        Ordering::Equal =&gt; println!(&quot;Vous avez gagné !&quot;),
    }
}
</code></pre>
<!--
<span class="caption">Listing 2-4: Handling the possible return values of
comparing two numbers</span>
-->
<p><span class="caption">Encart 2-4 : Traitement des valeurs possibles saisies en
comparant les deux nombres</span></p>
<!--
The first new bit here is another `use` statement, bringing a type called
`std::cmp::Ordering` into scope from the standard library. Like `Result`,
`Ordering` is another enum, but the variants for `Ordering` are `Less`,
`Greater`, and `Equal`. These are the three outcomes that are possible when you
compare two values.
-->
<p>La première nouveauté ici est une nouvelle utilisation de l'instruction <code>use</code>,
qui importe <code>std::cmp::Ordering</code> à portée de notre code depuis la
bibliothèque standard. Comme <code>Result</code>, <code>Ordering</code> est une autre énumération,
mais les variantes pour <code>Ordering</code> sont <code>Less</code> <em>(inférieur)</em>, <code>Greater</code>
<em>(supérieur)</em> et <code>Equal</code> <em>(égal)</em>.
Ce sont les trois issues possibles lorsqu'on compare deux valeurs.</p>
<!--
Then we add five new lines at the bottom that use the `Ordering` type. The
`cmp` method compares two values and can be called on anything that can be
compared. It takes a reference to whatever you want to compare with: here it’s
comparing the `guess` to the `secret_number`. Then it returns a variant of the
`Ordering` enum we brought into scope with the `use` statement. We use a
[`match`][match]<!-- ignore -- > expression to decide what to do next based on
which variant of `Ordering` was returned from the call to `cmp` with the values
in `guess` and `secret_number`.
-->
<p>Ensuite, nous ajoutons cinq nouvelles lignes à la fin qui utilisent le type
<code>Ordering</code>. La méthode <code>cmp</code> compare deux valeurs et peut être appelée sur
tout ce qui peut être comparé. Elle prend en paramètre une référence de ce qu'on
veut comparer : ici, nous voulons comparer <code>supposition</code> et <code>nombre_secret</code>.
Ensuite, cela retourne une variante de l'énumération <code>Ordering</code> que nous avons
importée avec l'instruction <code>use</code>. Nous utilisons une expression
<a href="ch06-02-match.html"><code>match</code></a><!-- ignore --> pour décider quoi faire ensuite en fonction de
quelle variante de <code>Ordering</code> a été retournée à l'appel de <code>cmp</code> avec
<code>supposition</code> et <code>nombre_secret</code>.</p>
<!--
A `match` expression is made up of *arms*. An arm consists of a *pattern* and
the code that should be run if the value given to the beginning of the `match`
expression fits that arm’s pattern. Rust takes the value given to `match` and
looks through each arm’s pattern in turn. The `match` construct and patterns
are powerful features in Rust that let you express a variety of situations your
code might encounter and make sure that you handle them all. These features
will be covered in detail in Chapter 6 and Chapter 18, respectively.
-->
<p>Une expression <code>match</code> est composée de <em>branches</em>. Une branche est constituée
d'un <em>motif (pattern)</em> et du code qui sera exécuté si la valeur donnée
au début de l'expression <code>match</code> correspond bien au motif de cette
branche. Rust prend la valeur donnée à <code>match</code> et la compare au motif de
chaque branche à tour de rôle.
La structure de contrôle <code>match</code> et les motifs sont des
fonctionnalités puissantes de Rust qui vous permettent de décrire une multitude
de scénarios que votre code peut rencontrer et de s'assurer que vous les gérez
toutes. Ces fonctionnalités seront expliquées plus en détail respectivement dans
le chapitre 6 et le chapitre 18.</p>
<!--
Let’s walk through an example of what would happen with the `match` expression
used here. Say that the user has guessed 50 and the randomly generated secret
number this time is 38. When the code compares 50 to 38, the `cmp` method will
return `Ordering::Greater`, because 50 is greater than 38. The `match`
expression gets the `Ordering::Greater` value and starts checking each arm’s
pattern. It looks at the first arm’s pattern, `Ordering::Less`, and sees that
the value `Ordering::Greater` does not match `Ordering::Less`, so it ignores
the code in that arm and moves to the next arm. The next arm’s pattern,
`Ordering::Greater`, *does* match `Ordering::Greater`! The associated code in
that arm will execute and print `Too big!` to the screen. The `match`
expression ends because it has no need to look at the last arm in this scenario.
-->
<p>Voyons un exemple de ce qui se passerait avec l'expression <code>match</code> utilisée
ici. Disons que l'utilisateur a saisi le nombre 50 et que le nombre secret
généré aléatoirement a cette fois-ci comme valeur 38. Quand le code compare 50 à
38, la méthode <code>cmp</code> va retourner <code>Ordering::Greater</code>, car 50 est plus grand
que 38. L'expression <code>match</code> obtient la valeur <code>Ordering::Greater</code> et commence à
vérifier le motif de chaque branche.
Elle consulte le motif de la première branche, <code>Ordering::Less</code> et remarque que
la valeur <code>Ordering::Greater</code> ne correspond pas au motif <code>Ordering::Less</code> ;
elle ignore donc le code de cette branche et passe à la suivante.
Le motif de la branche suivante, <code>Ordering::Greater</code>, correspond à
<code>Ordering::Greater</code> ! Le code associé à cette branche va être exécuté et va
afficher à l'écran <code>C'est moins !</code>. L'expression <code>match</code> se termine ensuite, car
elle n'a pas besoin de consulter les autres branches de ce scénario.</p>
<!--
However, the code in Listing 2-4 won’t compile yet. Let’s try it:
-->
<p>Cependant, notre code dans l'encart 2-4 ne compile pas encore. Essayons de le
faire :</p>
<!--
```text
$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  -- > src/main.rs:23:21
   |
23 |     match guess.cmp(&secret_number) {
   |                     ^^^^^^^^^^^^^^ expected struct `std::string::String`, found integral variable
   |
   = note: expected type `&std::string::String`
   = note:    found type `&{integer}`

error: aborting due to previous error
Could not compile `guessing_game`.
```
-->
<pre><code class="language-text">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  -- &gt; src/main.rs:23:21
   |
23 |     match supposition.cmp(&amp;nombre_secret) {
   |                           ^^^^^^^^^^^^^^ expected struct `std::string::String`, found integral variable
   |
   = note: expected type `&amp;std::string::String`
   = note:    found type `&amp;{integer}`

error: aborting due to previous error
Could not compile `guessing_game`.
</code></pre>
<!--
The core of the error states that there are *mismatched types*. Rust has a
strong, static type system. However, it also has type inference. When we wrote
`let mut guess = String::new()`, Rust was able to infer that `guess` should be
a `String` and didn’t make us write the type. The `secret_number`, on the other
hand, is a number type. A few number types can have a value between 1 and 100:
`i32`, a 32-bit number; `u32`, an unsigned 32-bit number; `i64`, a 64-bit
number; as well as others. Rust defaults to an `i32`, which is the type of
`secret_number` unless you add type information elsewhere that would cause Rust
to infer a different numerical type. The reason for the error is that Rust
cannot compare a string and a number type.
-->
<p>Le message d'erreur nous indique que nous sommes dans un cas de types non
compatibles <em>(mismatched types)</em>. Rust a un système de types fort et statique.
Cependant, il a aussi une fonctionnalité d'inférence de type. Quand nous avons
écrit <code>let mut supposition = String::new()</code>, Rust a pu en déduire que
<code>supposition</code> devait être une <code>String</code> et ne nous a pas demandé d'écrire le
type. D'autre part, <code>nombre_secret</code> est d'un type de nombre.
Quelques types de nombres peuvent avoir une valeur entre 1 et 100 : <code>i32</code>, un
nombre entier encodé sur 32 bits ; <code>u32</code>, un nombre entier de 32 bits non signé
(positif ou nul) ; <code>i64</code>, un nombre entier encodé sur 64 bits ; parmi
tant d'autres. Rust utilise par défaut un <code>i32</code>, qui est le type
de <code>nombre_secret</code>, à moins que vous précisiez quelque part une information de
type qui amènerait Rust à inférer un type de nombre différent. La raison de
cette erreur est que Rust ne peut pas comparer une chaîne de caractères à un
nombre.</p>
<!--
Ultimately, we want to convert the `String` the program reads as input into a
real number type so we can compare it numerically to the secret number. We can
do that by adding the following two lines to the `main` function body:
-->
<p>Au bout du compte, nous voulons convertir la <code>String</code> que le programme récupère
de la saisie utilisateur en un nombre, pour qu'on puisse la comparer
numériquement au nombre secret. Nous pouvons faire ceci en ajoutant les deux
lignes suivantes dans le corps de la fonction <code>main</code> :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
// --snip--

    let mut guess = String::new();

    io::stdin().read_line(&mut guess)
        .expect("Failed to read line");

    let guess: u32 = guess.trim().parse()
        .expect("Please type a number!");

    println!("You guessed: {}", guess);

    match guess.cmp(&secret_number) {
        Ordering::Less => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal => println!("You win!"),
    }
}
```
-->
<pre><code class="language-rust ignore">// -- code inchangé masqué ici --

    let mut supposition = String::new();

    io::stdin().read_line(&amp;mut supposition)
        .expect(&quot;Échec de la lecture de l'entrée utilisateur&quot;);

    let supposition: u32 = supposition.trim().parse()
        .expect(&quot;Veuillez entrer un nombre !&quot;);

    println!(&quot;Votre nombre : {}&quot;, supposition);

    match supposition.cmp(&amp;nombre_secret) {
        Ordering::Less =&gt; println!(&quot;C'est plus !&quot;),
        Ordering::Greater =&gt; println!(&quot;C'est moins !&quot;),
        Ordering::Equal =&gt; println!(&quot;Vous avez gagné !&quot;),
    }
}
</code></pre>
<!--
The two new lines are:
-->
<p>Les deux nouvelles lignes sont :</p>
<!--
```rust,ignore
let guess: u32 = guess.trim().parse()
    .expect("Please type a number!");
```
-->
<pre><code class="language-rust ignore">let supposition: u32 = supposition.trim().parse()
    .expect(&quot;Veuillez entrer un nombre !&quot;);
</code></pre>
<!--
We create a variable named `guess`. But wait, doesn’t the program already have
a variable named `guess`? It does, but Rust allows us to *shadow* the previous
value of `guess` with a new one. This feature is often used in situations in
which you want to convert a value from one type to another type. Shadowing lets
us reuse the `guess` variable name rather than forcing us to create two unique
variables, such as `guess_str` and `guess` for example. (Chapter 3 covers
shadowing in more detail.)
-->
<p>Nous créons une variable qui s'appelle <code>supposition</code>. Mais attendez, le
programme n'a-t-il pas déjà une variable qui s'appelle <code>supposition</code> ?
C'est le cas, mais Rust nous permet de <em>masquer</em> la valeur précédente de
<code>supposition</code> avec une nouvelle.
Cette fonctionnalité est souvent utilisée dans des
situations où on veut convertir une valeur d'un type à un autre.
Le masquage <em>(shadowing)</em> nous permet de réutiliser le nom de variable
<code>supposition</code>, plutôt que de nous forcer à créer deux variables distinctes,
telles que <code>supposition_str</code> et <code>supposition</code> par exemple.
(Le chapitre 3 expliquera plus en détail le masquage.)</p>
<!--
We bind `guess` to the expression `guess.trim().parse()`. The `guess` in the
expression refers to the original `guess` that was a `String` with the input in
it. The `trim` method on a `String` instance will eliminate any whitespace at
the beginning and end. Although `u32` can contain only numerical characters,
the user must press <span class="keystroke">enter</span> to satisfy
`read_line`. When the user presses <span class="keystroke">enter</span>, a
newline character is added to the string. For example, if the user types <span
class="keystroke">5</span> and presses <span class="keystroke">enter</span>,
`guess` looks like this: `5\n`. The `\n` represents “newline,” the result of
pressing <span class="keystroke">enter</span>. The `trim` method eliminates
`\n`, resulting in just `5`.
-->
<p>Nous lions <code>supposition</code> à l'expression <code>supposition.trim().parse()</code>. Le
<code>supposition</code> dans l'expression se réfère au <code>supposition</code> initial qui était une
<code>String</code> contenant la saisie utilisateur. La méthode <code>trim</code> sur une instance
de <code>String</code> va enlever les espaces et autres <em>whitespaces</em> au début et à la fin.
Même si <code>u32</code> ne peut contenir que des chiffres, l'utilisateur doit
appuyer sur <span class="keystroke">entrée</span> pour mettre fin à <code>read_line</code>.
Lorsque l'utilisateur appuie sur
<span class="keystroke">entrée</span>, un caractère de fin de ligne
est ajouté à la chaîne de caractères. Par exemple, si l'utilisateur écrit
<span class="keystroke">5</span> et appuie sur <span class="keystroke">
entrée</span>, <code>supposition</code> aura alors cette valeur : <code>5\n</code>.
Le <code>\n</code> représente une fin de ligne, qui résulte de l'appui sur
<span class="keystroke">entrée</span>. La méthode <code>trim</code> enlève <code>\n</code>, il ne
reste donc plus que <code>5</code>.</p>
<!--
The [`parse` method on strings][parse]<!-- ignore -- > parses a string into some
kind of number. Because this method can parse a variety of number types, we
need to tell Rust the exact number type we want by using `let guess: u32`. The
colon (`:`) after `guess` tells Rust we’ll annotate the variable’s type. Rust
has a few built-in number types; the `u32` seen here is an unsigned, 32-bit
integer. It’s a good default choice for a small positive number. You’ll learn
about other number types in Chapter 3. Additionally, the `u32` annotation in
this example program and the comparison with `secret_number` means that Rust
will infer that `secret_number` should be a `u32` as well. So now the
comparison will be between two values of the same type!
-->
<p>La <a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse">méthode <code>parse</code> des chaînes de caractères</a><!-- ignore --> interprète
une chaîne de caractères en une sorte de nombre. Comme cette méthode peut
interpréter plusieurs types de nombres, nous devons indiquer à Rust le type
exact de nombre que nous voulons en utilisant <code>let supposition: u32</code>.
Le deux-points (<code>:</code>) après <code>supposition</code> indique à Rust que nous voulons
préciser le type de la variable.
Rust embarque quelques types de nombres ; le <code>u32</code> utilisé ici est un
entier non signé sur 32 bits.
C'est un bon choix par défaut pour un petit nombre positif.
Vous découvrirez d'autres types de nombres dans le chapitre 3.
De plus, l'annotation <code>u32</code> dans ce programme d'exemple et la
comparaison avec <code>nombre_secret</code> permet à Rust d'en déduire que <code>nombre_secret</code>
doit être lui aussi un <code>u32</code>. Donc maintenant, la comparaison se fera
entre deux valeurs du même type !</p>
<!-- [parse]: ../std/primitive.str.html#method.parse -->
<!--
The call to `parse` could easily cause an error. If, for example, the string
contained `A👍%`, there would be no way to convert that to a number. Because it
might fail, the `parse` method returns a `Result` type, much as the `read_line`
method does (discussed earlier in [“Handling Potential Failure with the
`Result` Type”](#handling-potential-failure-with-the-result-type)<!-- ignore
-- >). We’ll treat this `Result` the same way by using the `expect` method
again. If `parse` returns an `Err` `Result` variant because it couldn’t create
a number from the string, the `expect` call will crash the game and print the
message we give it. If `parse` can successfully convert the string to a number,
it will return the `Ok` variant of `Result`, and `expect` will return the
number that we want from the `Ok` value.
-->
<p>L'utilisation de <code>parse</code> peut facilement mener à une erreur. Si par exemple,
le texte contient <code>A👍%</code>, il ne sera pas possible de le convertir en nombre.
Comme elle peut échouer, la méthode <code>parse</code> retourne un type <code>Result</code>, comme
celui que la méthode <code>read_line</code> retourne (comme nous l'avons vu plus tôt dans
<a href="ch02-00-guessing-game-tutorial.html#g%C3%A9rer-les-erreurs-potentielles-avec-le-type-result">“Gérer les erreurs potentielles avec le type <code>Result</code>”</a><!-- ignore-->).
Nous allons gérer ce <code>Result</code> de la même manière, avec à nouveau la méthode
<code>expect</code>. Si <code>parse</code> retourne une variante <code>Err</code> de <code>Result</code> car elle ne peut
pas créer un nombre à partir de la chaîne de caractères, l'appel à
<code>expect</code> va faire planter le jeu et va afficher le message que nous lui avons
passé en paramètre. Si <code>parse</code> arrive à convertir la chaîne de caractères en
nombre, alors elle retournera la variante <code>Ok</code> de <code>Result</code>, et <code>expect</code> va
retourner le nombre qu'il nous faut qui est stocké dans la variante <code>Ok</code>.</p>
<!--
Let’s run the program now!
-->
<p>Exécutons ce programme, maintenant !</p>
<!--
```text
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43 secs
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
```
-->
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43 secs
     Running `target/debug/guessing_game`
Devinez le nombre !
Le nombre secret est : 58
Veuillez entrer un nombre.
  76
Votre nombre : 76
C'est moins !
</code></pre>
<!--
Nice! Even though spaces were added before the guess, the program still figured
out that the user guessed 76. Run the program a few times to verify the
different behavior with different kinds of input: guess the number correctly,
guess a number that is too high, and guess a number that is too low.
-->
<p>Très bien !
Même si des espaces ont été ajoutées avant la supposition, le programme a quand
même compris que l'utilisateur a saisi 76. Lancez le programme plusieurs
fois pour vérifier qu'il se comporte correctement avec différentes saisies :
devinez le nombre correctement, saisissez un nombre qui est trop grand, et
saisissez un nombre qui est trop petit.</p>
<!--
We have most of the game working now, but the user can make only one guess.
Let’s change that by adding a loop!
-->
<p>La majeure partie du jeu fonctionne désormais, mais l'utilisateur ne peut faire
qu'une seule supposition. Corrigeons cela en ajoutant une boucle !</p>
<!--
## Allowing Multiple Guesses with Looping
-->
<h2><a class="header" href="#permettre-plusieurs-suppositions-avec-les-boucles" id="permettre-plusieurs-suppositions-avec-les-boucles">Permettre plusieurs suppositions avec les boucles</a></h2>
<!--
The `loop` keyword creates an infinite loop. We’ll add that now to give users
more chances at guessing the number:
-->
<p>Le mot-clé <code>loop</code> crée une boucle infinie. C'est ce que nous allons ajouter pour
donner aux utilisateurs plus de chances de deviner le nombre :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
// --snip--

    println!("The secret number is: {}", secret_number);

    loop {
        println!("Please input your guess.");

        // --snip--

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => println!("You win!"),
        }
    }
}
```
-->
<pre><code class="language-rust ignore">// -- code inchangé masqué ici --

    println!(&quot;Le nombre secret est : {}&quot;, nombre_secret);

    loop {
        println!(&quot;Veuillez entrer un nombre.&quot;);

        // -- code inchangé masqué ici --

        match supposition.cmp(&amp;nombre_secret) {
            Ordering::Less =&gt; println!(&quot;C'est plus !&quot;),
            Ordering::Greater =&gt; println!(&quot;C'est moins !&quot;),
            Ordering::Equal =&gt; println!(&quot;Vous avez gagné !&quot;),
        }
    }
}
</code></pre>
<!--
As you can see, we’ve moved everything into a loop from the guess input prompt
onward. Be sure to indent the lines inside the loop another four spaces each
and run the program again. Notice that there is a new problem because the
program is doing exactly what we told it to do: ask for another guess forever!
It doesn’t seem like the user can quit!
-->
<p>Comme vous pouvez le remarquer, nous avons déplacé dans une boucle tout le
code à partir de l'invite à entrer le nombre. Assurez-vous d'indenter
correctement les lignes dans la boucle avec quatre nouvelles espaces pour
chacune, et lancez à nouveau le programme. Notez bien qu'il y a un nouveau
problème, car le programme fait exactement ce que nous lui avons demandé de
faire : demander un nombre à l'infini ! Il n'est pas possible pour l'utilisateur
de l'arrêter !</p>
<!--
The user could always interrupt the program by using the keyboard shortcut <span
class="keystroke">ctrl-c</span>. But there’s another way to escape this
insatiable monster, as mentioned in the `parse` discussion in [“Comparing the
Guess to the Secret Number”](#comparing-the-guess-to-the-secret-number)<!--
ignore -- >: if the user enters a non-number answer, the program will crash. The
user can take advantage of that in order to quit, as shown here:
-->
<p>L'utilisateur pourrait quand même interrompre le programme en utilisant le
raccourci clavier <span class="keystroke">ctrl-c</span>.
Mais il y a une autre façon d'échapper à ce monstre insatiable, comme nous
l'avons abordé dans la partie
<a href="ch02-00-guessing-game-tutorial.html#comparer-le-nombre-saisi-au-nombre-secret">“Comparer le nombre saisi au nombre secret”</a><!-- ignore --> :
si l'utilisateur saisit quelque chose qui n'est pas un nombre, le programme va
planter. L'utilisateur peut procéder ainsi pour le quitter, comme ci-dessous :</p>
<!--
```text
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50 secs
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread 'main' panicked at 'Please type a number!: ParseIntError { kind: InvalidDigit }', src/libcore/result.rs:785
note: Run with `RUST_BACKTRACE=1` for a backtrace.
error: Process didn't exit successfully: `target/debug/guess` (exit code: 101)
```
-->
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50 secs
     Running `target/debug/guessing_game`
Devinez le nombre !
Le nombre secret est : 59
Veuillez entrer un nombre.
45
Votre nombre : 45
C'est plus !
Veuillez entrer un nombre.
60
Votre nombre : 60
C'est moins !
Veuillez entrer un nombre.
59
Votre nombre : 59
Vous avez gagné !
Veuillez entrer un nombre.
quitter
thread 'main' panicked at 'Veuillez entrer un nombre !: ParseIntError { kind: InvalidDigit }', src/libcore/result.rs:785
note: Run with `RUST_BACKTRACE=1` for a backtrace.
error: Process didn't exit successfully: `target/debug/supposition` (exit code: 101)
</code></pre>
<!--
Typing `quit` actually quits the game, but so will any other non-number input.
However, this is suboptimal to say the least. We want the game to automatically
stop when the correct number is guessed.
-->
<p>Taper <code>quitter</code> ferme bien le jeu, mais toute autre saisie qui n'est pas un
nombre le ferait aussi.
Cependant, ce mécanisme laisse franchement à désirer. Nous voudrions que le jeu
s'arrête automatiquement lorsque le bon nombre est deviné.</p>
<!--
### Quitting After a Correct Guess
-->
<h3><a class="header" href="#arrêter-le-programme-après-avoir-gagné" id="arrêter-le-programme-après-avoir-gagné">Arrêter le programme après avoir gagné</a></h3>
<!--
Let’s program the game to quit when the user wins by adding a `break` statement:
-->
<p>Faisons en sorte que le jeu s'arrête quand le joueur gagne en ajoutant
l'instruction <code>break</code> :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
// --snip--

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
}
```
-->
<pre><code class="language-rust ignore">// -- code inchangé masqué ici --

        match supposition.cmp(&amp;nombre_secret) {
            Ordering::Less =&gt; println!(&quot;C'est plus !&quot;),
            Ordering::Greater =&gt; println!(&quot;C'est moins !&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;Vous avez gagné !&quot;);
                break;
            }
        }
    }
}
</code></pre>
<!--
Adding the `break` line after `You win!` makes the program exit the loop when
the user guesses the secret number correctly. Exiting the loop also means
exiting the program, because the loop is the last part of `main`.
-->
<p>Ajouter la ligne <code>break</code> après <code>Vous avez gagné !</code> fait sortir le programme de
la boucle quand le joueur a correctement deviné le nombre secret. Et quitter la
boucle veut aussi dire terminer le programme, car ici la boucle est la dernière
partie de <code>main</code>.</p>
<!--
### Handling Invalid Input
-->
<h3><a class="header" href="#gérer-les-saisies-invalides" id="gérer-les-saisies-invalides">Gérer les saisies invalides</a></h3>
<!--
To further refine the game’s behavior, rather than crashing the program when
the user inputs a non-number, let’s make the game ignore a non-number so the
user can continue guessing. We can do that by altering the line where `guess`
is converted from a `String` to a `u32`, as shown in Listing 2-5.
-->
<p>Pour améliorer le comportement du jeu, plutôt que de faire planter le programme
quand l'utilisateur saisit quelque chose qui n'est pas un nombre, faisons en
sorte que le jeu ignore ce qui n'est pas un nombre afin que l'utilisateur puisse
continuer à essayer de deviner. Nous pouvons faire ceci en modifiant la ligne où
<code>supposition</code> est converti d'une <code>String</code> en un <code>u32</code>, comme dans l'encart 2-5 :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
// --snip--

io::stdin().read_line(&mut guess)
    .expect("Failed to read line");

let guess: u32 = match guess.trim().parse() {
    Ok(num) => num,
    Err(_) => continue,
};

println!("You guessed: {}", guess);

// --snip--
```
-->
<pre><code class="language-rust ignore">// -- code inchangé masqué ici --

io::stdin().read_line(&amp;mut supposition)
    .expect(&quot;Échec de la lecture de l'entrée utilisateur&quot;);

let supposition: u32 = match supposition.trim().parse() {
    Ok(nombre) =&gt; nombre,
    Err(_) =&gt; continue,
};

println!(&quot;Votre nombre : {}&quot;, supposition);

// -- code inchangé masqué ici --
</code></pre>
<!--
<span class="caption">Listing 2-5: Ignoring a non-number guess and asking for
another guess instead of crashing the program</span>
-->
<p><span class="caption">Encart 2-5 : Ignorer une saisie qui n'est pas un nombre
et demander un nouveau nombre plutôt que de faire planter le programme</span></p>
<!--
Switching from an `expect` call to a `match` expression is how you generally
move from crashing on an error to handling the error. Remember that `parse`
returns a `Result` type and `Result` is an enum that has the variants `Ok` or
`Err`. We’re using a `match` expression here, as we did with the `Ordering`
result of the `cmp` method.
-->
<p>Remplacer un appel à <code>expect</code> par une expression <code>match</code> est la technique qu'on
utilise en général pour passer d'une erreur qui fait planter le programme à une
erreur proprement gérée. N'oubliez pas que
<code>parse</code> retourne un type <code>Result</code> et que <code>Result</code> est une énumération qui a pour
variantes <code>Ok</code> ou <code>Err</code>. Nous utilisons ici une expression <code>match</code> comme nous
l'avons déjà fait avec le résultat de type <code>Ordering</code> de la méthode <code>cmp</code>.</p>
<!--
If `parse` is able to successfully turn the string into a number, it will
return an `Ok` value that contains the resulting number. That `Ok` value will
match the first arm’s pattern, and the `match` expression will just return the
`num` value that `parse` produced and put inside the `Ok` value. That number
will end up right where we want it in the new `guess` variable we’re creating.
-->
<p>Si <code>parse</code> arrive à convertir la chaîne de caractères en nombre, cela va
retourner la variante <code>Ok</code> qui contient le nombre qui en résulte. Cette variante
va correspondre au motif de la première branche, et l'expression <code>match</code> va
simplement retourner la valeur de <code>nombre</code> que <code>parse</code> a trouvée et qu'elle a
mise dans la variante <code>Ok</code>.
Ce nombre va se retrouver là où nous en avons besoin,
dans la variable <code>supposition</code> que nous sommes en train de créer.</p>
<!--
If `parse` is *not* able to turn the string into a number, it will return an
`Err` value that contains more information about the error. The `Err` value
does not match the `Ok(num)` pattern in the first `match` arm, but it does
match the `Err(_)` pattern in the second arm. The underscore, `_`, is a
catchall value; in this example, we’re saying we want to match all `Err`
values, no matter what information they have inside them. So the program will
execute the second arm’s code, `continue`, which tells the program to go to the
next iteration of the `loop` and ask for another guess. So, effectively, the
program ignores all errors that `parse` might encounter!
-->
<p>Si <code>parse</code> n'arrive <em>pas</em> à convertir la chaîne de caractères en nombre, elle
va retourner la variante <code>Err</code> qui contient plus d'informations sur l'erreur. La
variante <code>Err</code> ne correspond pas au motif <code>Ok(nombre)</code> de la première branche,
mais elle correspond au motif <code>Err(_)</code> de la seconde branche. Le tiret bas,
<code>_</code>, est une valeur passe-partout ; dans notre exemple, nous disons
que nous voulons correspondre à toutes les valeurs de <code>Err</code>, peu importe quelle
information elles ont à l'intérieur d'elles-mêmes. Donc le programme va exécuter
le code de la seconde branche, <code>continue</code>, qui indique au programme de se rendre
à la prochaine itération de <code>loop</code> et de demander un nouveau nombre. Ainsi, le
programme ignore toutes les erreurs que <code>parse</code> pourrait rencontrer !</p>
<!--
Now everything in the program should work as expected. Let’s try it:
-->
<p>Maintenant, le programme devrait fonctionner correctement. Essayons-le :</p>
<!--
```text
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
```
-->
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/debug/guessing_game`
Devinez le nombre !
Le nombre secret est : 61
Veuillez entrer un nombre.
10
Votre nombre : 10
C'est plus !
Veuillez entrer un nombre.
99
Votre nombre : 99
C'est moins !
Veuillez entrer un nombre.
foo
Veuillez entrer un nombre.
61
Votre nombre : 61
Vous avez gagné !
</code></pre>
<!--
Awesome! With one tiny final tweak, we will finish the guessing game. Recall
that the program is still printing the secret number. That worked well for
testing, but it ruins the game. Let’s delete the `println!` that outputs the
secret number. Listing 2-6 shows the final code.
-->
<p>Super ! Avec notre petite touche finale, nous avons fini notre jeu de
devinettes. Rappelez-vous que le programme affiche toujours le nombre secret.
C'était pratique pour les tests, mais cela gâche le jeu. Supprimons le
<code>println!</code> qui affiche le nombre secret. L'encart 2-6 représente le code final.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    loop {
        println!("Please input your guess.");

        let mut guess = String::new();

        io::stdin().read_line(&mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("You guessed: {}", guess);

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
}
```
-->
<pre><code class="language-rust ignore">use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Devinez le nombre !&quot;);

    let nombre_secret = rand::thread_rng().gen_range(1, 101);

    loop {
        println!(&quot;Veuillez entrer un nombre.&quot;);

        let mut supposition = String::new();

        io::stdin().read_line(&amp;mut supposition)
            .expect(&quot;Échec de la lecture de l'entrée utilisateur&quot;);

        let supposition: u32 = match supposition.trim().parse() {
            Ok(nombre) =&gt; nombre,
            Err(_) =&gt; continue,
        };

        println!(&quot;Votre nombre : {}&quot;, supposition);

        match supposition.cmp(&amp;nombre_secret) {
            Ordering::Less =&gt; println!(&quot;C'est plus !&quot;),
            Ordering::Greater =&gt; println!(&quot;C'est moins !&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;Vous avez gagné !&quot;);
                break;
            }
        }
    }
}
</code></pre>
<!--
<span class="caption">Listing 2-6: Complete guessing game code</span>
-->
<p><span class="caption">Encart 2-6 : Code complet du jeu de devinettes</span></p>
<!--
## Summary
-->
<h2><a class="header" href="#résumé-1" id="résumé-1">Résumé</a></h2>
<!--
At this point, you’ve successfully built the guessing game. Congratulations!
-->
<p>Si vous êtes arrivé jusqu'ici, c'est que vous avez construit avec succès le jeu
de devinettes. Félicitations !</p>
<!--
This project was a hands-on way to introduce you to many new Rust concepts:
`let`, `match`, methods, associated functions, the use of external crates, and
more. In the next few chapters, you’ll learn about these concepts in more
detail. Chapter 3 covers concepts that most programming languages have, such as
variables, data types, and functions, and shows how to use them in Rust.
Chapter 4 explores ownership, a feature that makes Rust different from other
languages. Chapter 5 discusses structs and method syntax, and Chapter 6
explains how enums work.
-->
<p>Ce projet était une mise en pratique pour vous initier à de nombreux concepts de
Rust : <code>let</code>, <code>match</code>, les méthodes, les fonctions associées, l'utilisation de
<em>crates</em> externes, et bien plus. Dans les prochains chapitres, vous allez en
apprendre plus sur ces concepts. Le chapitre 3 va traiter des concepts utilisés
par la plupart des langages de programmation, comme les variables, les types de
données, et les fonctions, et vous montrera comment les utiliser avec Rust. Le
chapitre 4 expliquera la possession <em>(ownership)</em>, qui est une fonctionnalité
qui distingue Rust des autres langages. Le chapitre 5 abordera les structures et
les syntaxes des méthodes, et le chapitre 6 expliquera comment les énumérations
fonctionnent.</p>
<!--
[variables-and-mutability]:
ch03-01-variables-and-mutability.html#variables-and-mutability
-->
<!--
# Common Programming Concepts
-->
<h1><a class="header" href="#les-concepts-courants-de-programmation" id="les-concepts-courants-de-programmation">Les concepts courants de programmation</a></h1>
<!--
This chapter covers concepts that appear in almost every programming language
and how they work in Rust. Many programming languages have much in common at
their core. None of the concepts presented in this chapter are unique to Rust,
but we’ll discuss them in the context of Rust and explain the conventions
around using these concepts.
-->
<p>Ce chapitre explique des concepts qui apparaissent dans presque tous les
langages de programmation, et la manière dont ils fonctionnent en Rust. De
nombreux langages sont basés sur des concepts communs. Les concepts présentés
dans ce chapitre ne sont pas spécifiques à Rust, mais nous les appliquerons
à Rust et nous expliquerons les conventions qui leur sont liées.</p>
<!--
Specifically, you’ll learn about variables, basic types, functions, comments,
and control flow. These foundations will be in every Rust program, and learning
them early will give you a strong core to start from.
-->
<p>Plus précisément, vous allez apprendre les concepts de variables, les types de
base, les fonctions, les commentaires, et les structures de contrôle. Ces
notions fondamentales seront présentes dans tous les programmes Rust, et les
apprendre dès le début vous procurera de solides bases pour débuter.</p>
<!--
> #### Keywords
>
> The Rust language has a set of *keywords* that are reserved for use by
> the language only, much as in other languages. Keep in mind that you cannot
> use these words as names of variables or functions. Most of the keywords have
> special meanings, and you’ll be using them to do various tasks in your Rust
> programs; a few have no current functionality associated with them but have
> been reserved for functionality that might be added to Rust in the future. You
> can find a list of the keywords in Appendix A.
-->
<blockquote>
<h4><a class="header" href="#mots-clés" id="mots-clés">Mots-clés</a></h4>
<p>Le langage Rust possède un ensemble de <em>mots-clés</em> qui ont été réservés pour
l'usage exclusif du langage, tout comme le font d'autres langages. Gardez à
l'esprit que vous ne pouvez pas utiliser ces mots pour des noms de variables
ou de fonctions. La plupart des mots-clés ont une signification spéciale, et
vous les utiliserez pour réaliser de différentes tâches dans vos programmes
Rust ; quelques-uns n'ont aucune fonctionnalité active pour le moment, mais
ont été réservés pour être ajoutés plus tard à Rust.
Vous pouvez trouver la liste de ces mots-clés dans l'annexe A.</p>
</blockquote>
<!--
## Variables and Mutability
-->
<h2><a class="header" href="#les-variables-et-la-mutabilité" id="les-variables-et-la-mutabilité">Les variables et la mutabilité</a></h2>
<!--
As mentioned in Chapter 2, by default variables are immutable. This is one of
many nudges Rust gives you to write your code in a way that takes advantage of
the safety and easy concurrency that Rust offers. However, you still have the
option to make your variables mutable. Let’s explore how and why Rust
encourages you to favor immutability and why sometimes you might want to opt
out.
-->
<p>Tel qu'abordé au chapitre 2, par défaut, les variables sont <em>immuables</em>. C'est
un des nombreux coups de pouce de Rust pour écrire votre code de façon à
garantir la sécurité et la concurrence sans problème. Cependant, vous avez quand
même la possibilité de rendre vos variables mutables <em>(modifiables)</em>. Explorons
comment et pourquoi Rust vous encourage à favoriser l'immuabilité, et pourquoi
parfois vous pourriez choisir d'y renoncer.</p>
<!--
When a variable is immutable, once a value is bound to a name, you can’t change
that value. To illustrate this, let’s generate a new project called *variables*
in your *projects* directory by using `cargo new variables`.
-->
<p>Lorsqu'une variable est immuable, cela signifie qu'une fois qu'une valeur est
liée à un nom, vous ne pouvez pas changer cette valeur. À titre d'illustration,
générons un nouveau projet appelé <em>variables</em> dans votre dossier <em>projects</em> en
utilisant <code>cargo new variables</code>.</p>
<!--
Then, in your new *variables* directory, open *src/main.rs* and replace its
code with the following code that won’t compile just yet:
-->
<p>Ensuite, dans votre nouveau dossier <em>variables</em>, ouvrez <em>src/main.rs</em> et
remplacez son code par le code suivant qui ne compile pas pour le moment :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    println!(&quot;La valeur de x est : {}&quot;, x);
    x = 6;
    println!(&quot;La valeur de x est : {}&quot;, x);
}
</code></pre>
<!--
Save and run the program using `cargo run`. You should receive an error
message, as shown in this output:
-->
<p>Sauvegardez et lancez le programme en utilisant <code>cargo run</code>. Vous devriez
avoir un message d'erreur comme celui-ci :</p>
<!--
```text
error[E0384]: cannot assign twice to immutable variable `x`
 -- > src/main.rs:4:5
  |
2 |     let x = 5;
  |         - first assignment to `x`
3 |     println!("The value of x is: {}", x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable
```
-->
<pre><code class="language-text">error[E0384]: cannot assign twice to immutable variable `x`
 --&gt; src/main.rs:4:5
  |
2 |     let x = 5;
  |         - first assignment to `x`
3 |     println!(&quot;La valeur de x est : {}&quot;, x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable
</code></pre>
<!--
This example shows how the compiler helps you find errors in your programs.
Even though compiler errors can be frustrating, they only mean your program
isn’t safely doing what you want it to do yet; they do *not* mean that you’re
not a good programmer! Experienced Rustaceans still get compiler errors.
-->
<p>Cet exemple montre comment le compilateur vous aide à trouver les erreurs dans
vos programmes. Même si les erreurs de compilation peuvent s'avérer frustrantes,
elles signifient uniquement que, pour le moment, votre programme n'est pas en
train de faire ce que vous voulez qu'il fasse en toute sécurité ; elles ne
signifient <em>pas</em> que vous êtes un mauvais développeur ! Même les Rustacés
expérimentés continuent d'avoir des erreurs de compilation.</p>
<!--
The error message indicates that the cause of the error is that you `cannot
assign twice to immutable variable x`, because you tried to assign a second
value to the immutable `x` variable.
-->
<p>Ce message d'erreur indique que la cause du problème est qu'il est <em>impossible
d'assigner à deux reprises la variable immuable <code>x</code></em> (<code>cannot assign twice to immutable variable x</code>).</p>
<!--
It’s important that we get compile-time errors when we attempt to change a
value that we previously designated as immutable because this very situation
can lead to bugs. If one part of our code operates on the assumption that a
value will never change and another part of our code changes that value, it’s
possible that the first part of the code won’t do what it was designed to do.
The cause of this kind of bug can be difficult to track down after the fact,
especially when the second piece of code changes the value only *sometimes*.
-->
<p>Il est important que nous obtenions des erreurs au moment de la compilation
lorsque nous essayons de changer une valeur qui a précédemment été déclarée
comme immuable, car cette situation particulière peut donner lieu à des bogues.
Si une partie de notre code part du principe qu'une valeur ne changera jamais et
qu'une autre partie de notre code modifie cette valeur, il est possible que la
première partie du code ne fasse pas ce pour quoi elle a été conçue. La cause de
ce genre de bogue peut être difficile à localiser après coup, en particulier
lorsque la seconde partie du code ne modifie que <em>parfois</em> cette valeur.</p>
<!--
In Rust, the compiler guarantees that when you state that a value won’t change,
it really won’t change. That means that when you’re reading and writing code,
you don’t have to keep track of how and where a value might change. Your code
is thus easier to reason through.
-->
<p>Avec Rust, le compilateur garantit que lorsque nous déclarons qu'une variable ne
changera pas, elle ne changera vraiment pas. Cela signifie que lorsque vous
lisez et écrivez du code, vous n'avez pas à vous soucier d'où et comment la
valeur pourrait changer. Votre code est ainsi plus facile à comprendre.</p>
<!--
But mutability can be very useful. Variables are immutable only by default; as
you did in Chapter 2, you can make them mutable by adding `mut` in front of the
variable name. In addition to allowing this value to change, `mut` conveys
intent to future readers of the code by indicating that other parts of the code
will be changing this variable value.
-->
<p>Mais la mutabilité peut s'avérer très utile. Les variables sont immuables par
défaut ; mais comme vous l'avez fait au chapitre 2, vous pouvez les rendre
mutables en ajoutant <code>mut</code> devant le nom de la variable. En plus de permettre à
cette valeur de changer, <code>mut</code> va signaler l'intention aux futurs lecteurs de ce
code que d'autres parties du code vont modifier la valeur de cette variable.</p>
<!--
For example, let’s change *src/main.rs* to the following:
-->
<p>Par exemple, modifions <em>src/main.rs</em> ainsi :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```
-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut x = 5;
    println!(&quot;La valeur de x est : {}&quot;, x);
    x = 6;
    println!(&quot;La valeur de x est : {}&quot;, x);
}
</code></pre></pre>
<!--
When we run the program now, we get this:
-->
<p>Lorsque nous exécutons le programme, nous obtenons :</p>
<!--
```text
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
```
-->
<pre><code class="language-text">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/variables`
La valeur de x est : 5
La valeur de x est : 6
</code></pre>
<!--
We’re allowed to change the value that `x` binds to from `5` to `6` when `mut`
is used. In some cases, you’ll want to make a variable mutable because it makes
the code more convenient to write than if it had only immutable variables.
-->
<p>En utilisant <code>mut</code>, nous avons permis à la valeur de <code>x</code> de passer de <code>5</code> à <code>6</code>.
Dans certains cas, on voudra rendre une variable mutable car cela
rendra le code plus pratique à écrire que s'il n'utilisait que des variables
immuables.</p>
<!--
There are multiple trade-offs to consider in addition to the prevention of
bugs. For example, in cases where you’re using large data structures, mutating
an instance in place may be faster than copying and returning newly allocated
instances. With smaller data structures, creating new instances and writing in
a more functional programming style may be easier to think through, so lower
performance might be a worthwhile penalty for gaining that clarity.
-->
<p>Il y a d'autres compromis à envisager, en plus de la prévention des bogues. Par
exemple, dans le cas où vous utiliseriez des grosses structures de données,
muter une instance déjà existante peut être plus rapide que copier et retourner
une instance nouvellement allouée. Avec des structures de données plus petites,
créer de nouvelles instances avec un style de programmation fonctionnelle peut
rendre le code plus facile à comprendre, donc il peut valoir le coup de
sacrifier un peu de performance pour que le code gagne en clarté.</p>
<!--
### Differences Between Variables and Constants
-->
<h3><a class="header" href="#différences-entre-les-variables-et-les-constantes" id="différences-entre-les-variables-et-les-constantes">Différences entre les variables et les constantes</a></h3>
<!--
Being unable to change the value of a variable might have reminded you of
another programming concept that most other languages have: *constants*. Like
immutable variables, constants are values that are bound to a name and are not
allowed to change, but there are a few differences between constants and
variables.
-->
<p>Rendre impossible de changer la valeur d'une variable peut vous avoir rappelé un
autre concept de programmation que de nombreux autres langages possèdent : les
<em>constantes</em>. Comme les variables immuables, les constantes sont des valeurs qui
sont liées à un nom et qui ne peuvent être modifiées, mais il y a quelques
différences entre les constantes et les variables.</p>
<!--
First, you aren’t allowed to use `mut` with constants. Constants aren’t just
immutable by default—they’re always immutable.
-->
<p>D'abord, vous ne pouvez pas utiliser <code>mut</code> avec les constantes. Les constantes
ne sont pas seulement immuables par défaut − elles sont toujours immuables.</p>
<!--
You declare constants using the `const` keyword instead of the `let` keyword,
and the type of the value *must* be annotated. We’re about to cover types and
type annotations in the next section, [“Data Types,”][data-types]<!-- ignore
-- > so don’t worry about the details right now. Just know that you must always
annotate the type.
-->
<p>On déclare les constantes en utilisant le mot-clé <code>const</code> à la place du
mot-clé <code>let</code>, et le type de la valeur <em>doit</em> être indiqué. Nous allons aborder
les types et les annotations de types dans la prochaine section,
<a href="ch03-02-data-types.html#les-types-de-donn%C3%A9es">“Les types de données”</a><!-- ignore -->, donc ne vous souciez pas
des détails pour le moment. Sachez seulement que vous devez toujours indiquer le
type.</p>
<!--
Constants can be declared in any scope, including the global scope, which makes
them useful for values that many parts of code need to know about.
-->
<p>Les constantes peuvent être déclarées à n'importe quel endroit du code, y
compris la portée globale, ce qui les rend très utiles pour des valeurs que de
nombreuses parties de votre code ont besoin de connaître.</p>
<!--
The last difference is that constants may be set only to a constant expression,
not the result of a function call or any other value that could only be
computed at runtime.
-->
<p>La dernière différence est que les constantes ne peuvent être définies que par
une expression constante, et non pas le résultat d'un appel de fonction ou toute
autre valeur qui ne pourrait être calculée qu'à l'exécution.</p>
<!--
Here’s an example of a constant declaration where the constant’s name is
`MAX_POINTS` and its value is set to 100,000. (Rust’s naming convention for
constants is to use all uppercase with underscores between words, and
underscores can be inserted in numeric literals to improve readability):
-->
<p>Voici un exemple d'une déclaration de constante où le nom de la constante est
<code>MAX_POINTS</code> et où sa valeur est définie à 100 000. (En Rust, la convention de
nommage des constantes est de les écrire tout en majuscule avec des tirets bas
entre les mots, et des tirets bas peuvent être ajoutés entre les nombres pour
améliorer la lisibilité) :</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
const MAX_POINTS: u32 = 100_000;
#}</code></pre></pre>
<!--
Constants are valid for the entire time a program runs, within the scope they
were declared in, making them a useful choice for values in your application
domain that multiple parts of the program might need to know about, such as the
maximum number of points any player of a game is allowed to earn or the speed
of light.
-->
<p>Les constantes sont valables pendant toute la durée d'exécution du programme
au sein de la portée dans laquelle elles sont déclarées, ce qui en fait de
très bons choix lorsque plusieurs parties du programme doivent connaître
certaines valeurs, comme par exemple le nombre maximum de points qu'un joueur
est autorisé à gagner ou encore la vitesse de la lumière.</p>
<!--
Naming hardcoded values used throughout your program as constants is useful in
conveying the meaning of that value to future maintainers of the code. It also
helps to have only one place in your code you would need to change if the
hardcoded value needed to be updated in the future.
-->
<p>Déclarer des valeurs codées en dur et utilisées tout le long de votre programme
en tant que constantes est utile pour faire comprendre la signification de ces
valeurs dans votre code aux futurs développeurs. Cela permet également de
n'avoir qu'un seul endroit de votre code à modifier si cette valeur codée en dur
doit être mise à jour à l'avenir.</p>
<!--
### Shadowing
-->
<h3><a class="header" href="#le-masquage" id="le-masquage">Le masquage</a></h3>
<!--
As you saw in the guessing game tutorial in the [“Comparing the Guess to the
Secret Number”][comparing-the-guess-to-the-secret-number]<!-- ignore -- >
section in Chapter 2, you can declare a new variable with the same name as a
previous variable, and the new variable shadows the previous variable.
Rustaceans say that the first variable is *shadowed* by the second, which means
that the second variable’s value is what appears when the variable is used. We
can shadow a variable by using the same variable’s name and repeating the use
of the `let` keyword as follows:
-->
<p>Comme nous l'avons vu dans la section
<a href="ch02-00-guessing-game-tutorial.html#comparer-le-nombre-saisi-au-nombre-secret">“Comparer le nombre saisi au nombre secret”</a><!-- ignore -->
du jeu de devinettes au chapitre 2, on peut déclarer une nouvelle variable
avec le même nom qu'une variable précédente, et la nouvelle variable
masquera la première. Les Rustacés disent que la première variable est <em>masquée</em>
par la seconde, ce qui signifie que la valeur de la seconde variable sera ce que
nous obtiendrons lorsque nous utiliserons cette variable. Nous pouvons créer un
masque d'une variable en utilisant le même nom de variable et en réutilisant le
mot-clé <code>let</code> comme ci-dessous :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!("The value of x is: {}", x);
}
```
-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!(&quot;La valeur de x est : {}&quot;, x);
}
</code></pre></pre>
<!--
This program first binds `x` to a value of `5`. Then it shadows `x` by
repeating `let x =`, taking the original value and adding `1` so the value of
`x` is then `6`. The third `let` statement also shadows `x`, multiplying the
previous value by `2` to give `x` a final value of `12`. When we run this
program, it will output the following:
-->
<p>Au début, ce programme lie <code>x</code> à la valeur <code>5</code>. Puis il crée un masque de <code>x</code>
en répétant <code>let x =</code>, en récupérant la valeur d'origine et lui ajoutant <code>1</code> :
la valeur de <code>x</code> est désormais <code>6</code>. La troisième instruction <code>let</code> crée un autre
masque de <code>x</code>, en récupérant la précédente valeur et en la multipliant par <code>2</code>
pour donner à <code>x</code> la valeur finale de <code>12</code>. Lorsque nous exécutons ce programme,
nous obtenons ceci :</p>
<!--
```text
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/variables`
The value of x is: 12
```
-->
<pre><code class="language-text">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/variables`
La valeur de x est : 12
</code></pre>
<!--
Shadowing is different from marking a variable as `mut`, because we’ll get a
compile-time error if we accidentally try to reassign to this variable without
using the `let` keyword. By using `let`, we can perform a few transformations
on a value but have the variable be immutable after those transformations have
been completed.
-->
<p>Créer un masque est différent que de marquer une variable comme étant <code>mut</code>,
car à moins d'utiliser une nouvelle fois le mot-clé <code>let</code>, nous obtiendrons une
erreur de compilation si nous essayons de réassigner cette variable par
accident. Nous pouvons effectuer quelques transformations sur une valeur en
utilisant <code>let</code>, mais faire en sorte que la variable soit immuable après que ces
transformations ont été appliquées.</p>
<!--
The other difference between `mut` and shadowing is that because we’re
effectively creating a new variable when we use the `let` keyword again, we can
change the type of the value but reuse the same name. For example, say our
program asks a user to show how many spaces they want between some text by
inputting space characters, but we really want to store that input as a number:
-->
<p>Comme nous créons une nouvelle variable lorsque nous utilisons le mot-clé <code>let</code>
une nouvelle fois, l'autre différence entre le <code>mut</code> et la création d'un masque
est que cela nous permet de changer le type de la valeur, mais en réutilisant
le même nom. Par exemple, imaginons un programme qui demande à l'utilisateur
le nombre d'espaces qu'il souhaite entre deux portions de texte en saisissant
des espaces, mais que nous voulons plutôt stocker cela sous forme de nombre :</p>
<!--
```rust
let spaces = "   ";
let spaces = spaces.len();
```
-->
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let espaces = &quot;   &quot;;
let espaces = espaces.len();
#}</code></pre></pre>
<!--
This construct is allowed because the first `spaces` variable is a string type
and the second `spaces` variable, which is a brand-new variable that happens to
have the same name as the first one, is a number type. Shadowing thus spares us
from having to come up with different names, such as `spaces_str` and
`spaces_num`; instead, we can reuse the simpler `spaces` name. However, if we
try to use `mut` for this, as shown here, we’ll get a compile-time error:
-->
<p>Cette solution est autorisée car la première variable <code>espaces</code> est du type
chaîne de caractères <em>(string)</em>, alors que la seconde variable <code>espaces</code>, qui
est une toute nouvelle variable qui se trouve avoir le même nom que la première,
est du type nombre. L'utilisation du masquage nous évite ainsi d'avoir à trouver
des noms différents, comme <code>espaces_str</code> et <code>espaces_num</code> ; nous pouvons plutôt
simplement réutiliser le nom <code>espaces</code>. Cependant, si nous essayons d'utiliser
<code>mut</code> pour faire ceci, comme ci-dessous, nous avons une erreur de compilation :</p>
<!--
```rust,ignore,does_not_compile
let mut spaces = "   ";
spaces = spaces.len();
```
-->
<pre><code class="language-rust ignore">let mut espaces = &quot;   &quot;;
espaces = espaces.len();
</code></pre>
<!--
The error says we’re not allowed to mutate a variable’s type:
-->
<p>L'erreur indique que nous ne pouvons pas muter le type d'une variable :</p>
<!--
```text
error[E0308]: mismatched types
 -- > src/main.rs:3:14
  |
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected &str, found usize
  |
  = note: expected type `&str`
             found type `usize`
```
-->
<pre><code class="language-text">error[E0308]: mismatched types
 -- &gt; src/main.rs:3:14
  |
3 |     espaces = espaces.len();
  |               ^^^^^^^^^^^^^ expected &amp;str, found usize
  |
  = note: expected type `&amp;str`
             found type `usize`
</code></pre>
<!--
Now that we’ve explored how variables work, let’s look at more data types they
can have.
-->
<p>Maintenant que nous avons découvert comment fonctionnent les variables, étudions
les types de données qu'elles peuvent prendre.</p>
<!--
[comparing-the-guess-to-the-secret-number]:
ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number
[data-types]: ch03-02-data-types.html#data-types
-->
<!--
## Data Types
-->
<h2><a class="header" href="#les-types-de-données" id="les-types-de-données">Les types de données</a></h2>
<!--
Every value in Rust is of a certain *data type*, which tells Rust what kind of
data is being specified so it knows how to work with that data. We’ll look at
two data type subsets: scalar and compound.
-->
<p>Chaque valeur en Rust est d'un <em>type</em> bien déterminé, qui indique à Rust quel
genre de données il manipule pour qu'il sache comment traiter ces données.
Nous allons nous intéresser à deux catégories de types de données : les
scalaires et les composés.</p>
<!--
Keep in mind that Rust is a *statically typed* language, which means that it
must know the types of all variables at compile time. The compiler can usually
infer what type we want to use based on the value and how we use it. In cases
when many types are possible, such as when we converted a `String` to a numeric
type using `parse` in the [“Comparing the Guess to the Secret
Number”][comparing-the-guess-to-the-secret-number]<!-- ignore -- > section in
Chapter 2, we must add a type annotation, like this:
-->
<p>Gardez à l'esprit que Rust est langage <em>statiquement typé</em>, ce qui signifie
qu'il doit connaître les types de toutes les variables au moment de la
compilation. Le compilateur peut souvent déduire quel type utiliser en se basant
sur la valeur et sur la façon dont elle est utilisée. Dans les cas où plusieurs
types sont envisageables, comme lorsque nous avons converti une chaîne de
caractères en un type numérique en utilisant <code>parse</code> dans la section
<a href="ch02-00-guessing-game-tutorial.html#comparer-le-nombre-saisi-au-nombre-secret">“Comparer le nombre saisi au nombre secret”</a><!-- ignore -->
du chapitre 2, nous devons ajouter une annotation de type, comme ceci :</p>
<!--
```rust
let guess: u32 = "42".parse().expect("Not a number!");
```
-->
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let supposition: u32 = &quot;42&quot;.parse().expect(&quot;Ce n'est pas un nombre !&quot;);
#}</code></pre></pre>
<!--
If we don’t add the type annotation here, Rust will display the following
error, which means the compiler needs more information from us to know which
type we want to use:
-->
<p>Si nous n'ajoutons pas l'annotation de type ici, Rust affichera l'erreur
suivante, signifiant que le compilateur a besoin de plus d'informations pour
déterminer quel type nous souhaitons utiliser :</p>
<!--
```text
error[E0282]: type annotations needed
 -- > src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^
  |         |
  |         cannot infer type for `_`
  |         consider giving `guess` a type
```
-->
<pre><code class="language-text">error[E0282]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let supposition = &quot;42&quot;.parse().expect(&quot;Ce n'est pas un nombre !&quot;);
  |         ^^^^^^^^^^^
  |         |
  |         cannot infer type for `_`
  |         consider giving `supposition` a type
</code></pre>
<!--
You’ll see different type annotations for other data types.
-->
<p>Vous découvrirez différentes annotations de type au fur et à mesure que nous
aborderons les autres types de données.</p>
<!--
### Scalar Types
-->
<h3><a class="header" href="#types-scalaires" id="types-scalaires">Types scalaires</a></h3>
<!--
A *scalar* type represents a single value. Rust has four primary scalar types:
integers, floating-point numbers, Booleans, and characters. You may recognize
these from other programming languages. Let’s jump into how they work in Rust.
-->
<p>Un type <em>scalaire</em> représente une seule valeur. Rust possède quatre types
principaux de scalaires : les entiers, les nombres à virgule flottante, les
booléens et les caractères. Vous les connaissez sûrement d'autres langages de
programmation. Regardons comment ils fonctionnent avec Rust.</p>
<!--
#### Integer Types
-->
<h4><a class="header" href="#types-de-nombres-entiers" id="types-de-nombres-entiers">Types de nombres entiers</a></h4>
<!--
An *integer* is a number without a fractional component. We used one integer
type in Chapter 2, the `u32` type. This type declaration indicates that the
value it’s associated with should be an unsigned integer (signed integer types
start with `i`, instead of `u`) that takes up 32 bits of space. Table 3-1 shows
the built-in integer types in Rust. Each variant in the Signed and Unsigned
columns (for example, `i16`) can be used to declare the type of an integer
value.
-->
<p>Un <em>entier</em> est un nombre sans partie décimale. Nous avons utilisé un entier
précédemment dans le chapitre 2, le type <code>u32</code>. Cette déclaration de type
indique que la valeur à laquelle elle est associée doit être un entier non signé
encodé sur 32 bits dans la mémoire (les entiers pouvant prendre des valeurs
négatives commencent par un <code>i</code> (comme <em>integer</em> : “entier”), plutôt que par un
<code>u</code> comme <em>unsigned</em> : “non signé”). Le tableau 3-1 montre les types
d'entiers intégrés au langage. Chaque variante dans les colonnes “Signé” et
“Non signé” (par exemple <code>i16</code>) peut être utilisée pour déclarer le type d'une
valeur entière.</p>
<!--
<span class="caption">Table 3-1: Integer Types in Rust</span>
-->
<p><span class="caption">Tableau 3-1 : les types d'entiers en Rust</span></p>
<!--
| Length  | Signed  | Unsigned |
|---------|---------|----------|
| 8-bit   | `i8`    | `u8`     |
| 16-bit  | `i16`   | `u16`    |
| 32-bit  | `i32`   | `u32`    |
| 64-bit  | `i64`   | `u64`    |
| 128-bit | `i128`  | `u128`   |
| arch    | `isize` | `usize`  |
-->
<table><thead><tr><th>Taille</th><th>Signé</th><th>Non signé</th></tr></thead><tbody>
<tr><td>8 bits</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16 bits</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32 bits</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64 bits</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128 bits</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td>archi</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
<!--
Each variant can be either signed or unsigned and has an explicit size.
*Signed* and *unsigned* refer to whether it’s possible for the number to be
negative or positive—in other words, whether the number needs to have a sign
with it (signed) or whether it will only ever be positive and can therefore be
represented without a sign (unsigned). It’s like writing numbers on paper: when
the sign matters, a number is shown with a plus sign or a minus sign; however,
when it’s safe to assume the number is positive, it’s shown with no sign.
Signed numbers are stored using [two’s complement](https://en.wikipedia.org/wiki/Two%27s_complement) representation.
-->
<p>Chaque variante peut-être signée ou non signée et possède une taille explicite.
<em>Signé</em> et <em>non signé</em> veut dire respectivement que le nombre peut prendre ou
non des valeurs négatives ou positives — en d'autres termes, si l'on peut lui
attribuer un signe (signé) ou s'il sera toujours positif et que l'on peut donc
le représenter sans signe (non signé). C'est comme écrire des nombres sur du
papier : quand le signe est important, le nombre est écrit avec un signe plus
ou un signe moins ; en revanche, quand le nombre est forcément positif, on peut
l'écrire sans son signe. Les nombres signés sont stockés en utilisant le
<a href="https://fr.wikipedia.org/wiki/Compl%C3%A9ment_%C3%A0_deux">complément à deux</a>.</p>
<!--
Each signed variant can store numbers from -(2<sup>n - 1</sup>) to 2<sup>n -
1</sup> - 1 inclusive, where *n* is the number of bits that variant uses. So an
`i8` can store numbers from -(2<sup>7</sup>) to 2<sup>7</sup> - 1, which equals
-128 to 127. Unsigned variants can store numbers from 0 to 2<sup>n</sup> - 1,
so a `u8` can store numbers from 0 to 2<sup>8</sup> - 1, which equals 0 to 255.
-->
<p>Chaque variante signée peut stocker des nombres allant de −(2<sup><em>n</em> − 1</sup>)
à 2<sup><em>n</em> − 1</sup> − 1 inclus, où <em>n</em> est le nombre de bits que cette
variante utilise.
Un <code>i8</code> peut donc stocker des nombres allant de −(2<sup>7</sup>) à
2<sup>7</sup> − 1, c'est-à-dire de −128 à 127. Les variantes non signées peuvent
stocker des nombres de 0 à 2<sup><em>n</em></sup> − 1, donc un <code>u8</code> peut stocker
des nombres allant de 0 à 2<sup>8</sup> − 1, c'est-à-dire de 0 à 255.</p>
<!--
Additionally, the `isize` and `usize` types depend on the kind of computer your
program is running on: 64 bits if you’re on a 64-bit architecture and 32 bits
if you’re on a 32-bit architecture.
-->
<p>De plus, les types <code>isize</code> et <code>usize</code> dépendent du type d'ordinateur sur lequel
votre programme va s'exécuter : 64 bits si vous utilisez une architecture
64 bits ou 32 bits si vous utilisez une architecture 32 bits.</p>
<!--
You can write integer literals in any of the forms shown in Table 3-2. Note
that all number literals except the byte literal allow a type suffix, such as
`57u8`, and `_` as a visual separator, such as `1_000`.
-->
<p>Vous pouvez écrire des littéraux d'entiers dans chacune des formes décrites dans
le tableau 3-2. Notez que chaque littéral numérique excepté l'octet accepte un
suffixe de type, comme <code>57u8</code>, et <code>_</code> comme séparateur visuel, comme par exemple
<code>1_000</code>.</p>
<!--
<span class="caption">Table 3-2: Integer Literals in Rust</span>
-->
<p><span class="caption">Tableau 3-2 : Les littéraux d'entiers en Rust</span></p>
<!--
| Number literals  | Example       |
|------------------|---------------|
| Decimal          | `98_222`      |
| Hex              | `0xff`        |
| Octal            | `0o77`        |
| Binary           | `0b1111_0000` |
| Byte (`u8` only) | `b'A'`        |
-->
<table><thead><tr><th>Littéral numérique</th><th>Exemple</th></tr></thead><tbody>
<tr><td>Décimal</td><td><code>98_222</code></td></tr>
<tr><td>Hexadécimal</td><td><code>0xff</code></td></tr>
<tr><td>Octal</td><td><code>0o77</code></td></tr>
<tr><td>Binaire</td><td><code>0b1111_0000</code></td></tr>
<tr><td>Octet (<code>u8</code> seulement)</td><td><code>b'A'</code></td></tr>
</tbody></table>
<!--
So how do you know which type of integer to use? If you’re unsure, Rust’s
defaults are generally good choices, and integer types default to `i32`: this
type is generally the fastest, even on 64-bit systems. The primary situation in
which you’d use `isize` or `usize` is when indexing some sort of collection.
-->
<p>Comment pouvez-vous déterminer le type d'entier à utiliser ? Si vous n'êtes pas
sûr, les choix par défaut de Rust sont généralement de bons choix, et le type
d'entier par défaut est le <code>i32</code> : c'est souvent le plus rapide, même sur les
systèmes 64 bits. La principale utilisation d'un <code>isize</code> ou d'un <code>usize</code> est
lorsque l'on indexe une quelconque collection.</p>
<!--
> ##### Integer Overflow
>
> Let’s say you have a variable of type `u8` that can hold values between 0 and 255.
> If you try to change the variable to a value outside of that range, such
> as 256, *integer overflow* will occur. Rust has some interesting rules
> involving this behavior. When you’re compiling in debug mode, Rust includes
> checks for integer overflow that cause your program to *panic* at runtime if
> this behavior occurs. Rust uses the term panicking when a program exits with
> an error; we’ll discuss panics in more depth in the [“Unrecoverable Errors
> with `panic!`”][unrecoverable-errors-with-panic]<!-- ignore -- > section in
> Chapter 9.
>
> When you’re compiling in release mode with the `--release` flag, Rust does
> *not* include checks for integer overflow that cause panics. Instead, if
> overflow occurs, Rust performs *two’s complement wrapping*. In short, values
> greater than the maximum value the type can hold “wrap around” to the minimum
> of the values the type can hold. In the case of a `u8`, 256 becomes 0, 257
> becomes 1, and so on. The program won’t panic, but the variable will have a
> value that probably isn’t what you were expecting it to have. Relying on
> integer overflow’s wrapping behavior is considered an error. If you want to
> wrap explicitly, you can use the standard library type [`Wrapping`][wrapping].
-->
<blockquote>
<h5><a class="header" href="#dépassement-dentier" id="dépassement-dentier">Dépassement d'entier</a></h5>
<p>Imaginons que vous avez une variable de type <code>u8</code> qui peut stocker des
valeurs entre 0 et 255. Si vous essayez de changer la variable pour une valeur
en dehors de cet intervalle, comme 256, vous aurez un dépassement
d'entier <em>(integer overflow)</em>. Rust possède quelques règles intéressantes
concernant ce comportement. Quand vous compilez en mode débogage, Rust
embarque des vérifications pour détecter les cas de dépassements d'entiers qui
pourraient faire <em>paniquer</em> votre programme à l'exécution si ce phénomène se
produit. Rust utilise le terme <em>paniquer</em> quand un programme se termine
avec une erreur ; nous verrons plus en détail les <em>paniques</em> dans une section
du <a href="ch09-01-unrecoverable-errors-with-panic.html">chapitre 9</a>.</p>
<p>Lorsque vous compilez en mode publication <em>(release)</em> avec le drapeau
<code>--release</code>, Rust ne va <em>pas</em> vérifier les potentiels dépassements d'entiers
qui peuvent faire paniquer le programme. En revanche, en cas de dépassement,
Rust va effectuer un <em>rebouclage du complément à deux</em>. Pour faire simple, les
valeurs supérieures à la valeur maximale du type seront “rebouclées” depuis la
valeur minimale que le type peut stocker. Dans cas d'un <code>u8</code>, 256 devient 0,
257 devient 1, et ainsi de suite. Le programme ne va paniquer, mais
la variable va avoir une valeur qui n'est probablement pas ce que vous
attendez à avoir. Se fier au comportement du rebouclage lors du
dépassement d'entier est considéré comme une faute. Si vous voulez reboucler
explicitement, vous pouvez utiliser le type <a href="https://doc.rust-lang.org/std/num/struct.Wrapping.html"><code>Wrapping</code></a> de la
bibliothèque standard.</p>
</blockquote>
<!--
#### Floating-Point Types
-->
<h4><a class="header" href="#types-de-nombres-à-virgule-flottante" id="types-de-nombres-à-virgule-flottante">Types de nombres à virgule flottante</a></h4>
<!--
Rust also has two primitive types for *floating-point numbers*, which are
numbers with decimal points. Rust’s floating-point types are `f32` and `f64`,
which are 32 bits and 64 bits in size, respectively. The default type is `f64`
because on modern CPUs it’s roughly the same speed as `f32` but is capable of
more precision.
-->
<p>Rust possède également deux types primitifs pour les <em>nombres à virgule
flottante</em> (ou <em>flottants</em>), qui sont des nombres avec des décimales. Les types
de flottants en Rust sont les <code>f32</code> et les <code>f64</code>, qui ont respectivement une
taille en mémoire de 32 bits et 64 bits. Le type par défaut est le <code>f64</code> car sur
les processeurs récents ce type est quasiment aussi rapide qu'un <code>f32</code> mais est
plus précis.</p>
<!--
Here’s an example that shows floating-point numbers in action:
-->
<p>Voici un exemple montrant l'utilisation de nombres à virgule flottante :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Nom du ficher: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
</code></pre></pre>
<!--
Floating-point numbers are represented according to the IEEE-754 standard. The
`f32` type is a single-precision float, and `f64` has double precision.
-->
<p>Les nombres à virgule flottante sont représentés selon la norme IEEE-754. Le
type <code>f32</code> est un flottant à simple précision, et le <code>f64</code> est à double
précision.</p>
<!--
#### Numeric Operations
-->
<h4><a class="header" href="#les-opérations-numériques" id="les-opérations-numériques">Les opérations numériques</a></h4>
<!--
Rust supports the basic mathematical operations you’d expect for all of the
number types: addition, subtraction, multiplication, division, and remainder.
The following code shows how you’d use each one in a `let` statement:
-->
<p>Rust offre les opérations mathématiques de base dont vous auriez besoin pour
tous les types de nombres : addition, soustraction, multiplication, division et
modulo. Le code suivant montre comment utiliser chacune d'elles avec une
instruction <code>let</code> :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;

    // remainder
    let remainder = 43 % 5;
}
```
-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // addition
    let somme = 5 + 10;

    // soustraction
    let difference = 95.5 - 4.3;

    // multiplication
    let produit = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;

    // modulo
    let reste = 43 % 5;
}
</code></pre></pre>
<!--
Each expression in these statements uses a mathematical operator and evaluates
to a single value, which is then bound to a variable. Appendix B contains a
list of all operators that Rust provides.
-->
<p>Chaque expression de ces instructions utilise un opérateur mathématique et
calcule une valeur unique, qui est ensuite attribuée à une variable. L'annexe B
présente une liste de tous les opérateurs que Rust fournit.</p>
<!--
#### The Boolean Type
-->
<h4><a class="header" href="#le-type-booléen" id="le-type-booléen">Le type booléen</a></h4>
<!--
As in most other programming languages, a Boolean type in Rust has two possible
values: `true` and `false`. Booleans are one byte in size. The Boolean type in
Rust is specified using `bool`. For example:
-->
<p>Comme dans la plupart des langages de programmation, un type booléen a deux
valeurs possibles en Rust : <code>true</code> (vrai) et <code>false</code> (faux). Les booléens
prennent un octet en mémoire. Le type booléen est désigné en utilisant <code>bool</code>.
Par exemple :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
```
-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let t = true;

    let f: bool = false; // avec une annotation de type explicite
}
</code></pre></pre>
<!--
The main way to use Boolean values is through conditionals, such as an `if`
expression. We’ll cover how `if` expressions work in Rust in the [“Control
Flow”][control-flow]<!-- ignore -- > section.
-->
<p>Les valeurs booléennes sont principalement utilisées par les structures
conditionnelles, comme l'expression <code>if</code>. Nous aborderons le fonctionnement
de <code>if</code> en Rust dans la section
<a href="ch03-05-control-flow.html#les-structures-de-contr%C3%B4le">“Les structures de contrôle”</a><!-- ignore -->.</p>
<!--
#### The Character Type
-->
<h4><a class="header" href="#le-type-caractère" id="le-type-caractère">Le type caractère</a></h4>
<!--
So far we’ve worked only with numbers, but Rust supports letters too. Rust’s
`char` type is the language’s most primitive alphabetic type, and the following
code shows one way to use it. (Note that `char` literals are specified with
single quotes, as opposed to string literals, which use double quotes.)
-->
<p>Jusqu'à présent, nous avons utilisé uniquement des nombres, mais Rust peut aussi
travailler avec des lettres. Le type <code>char</code> (comme <em>character</em>) est le type de
caractère le plus rudimentaire, et le code suivant va vous montrer une façon de
l'utiliser. (A noter que les <code>char</code> sont écrits avec des guillemets simples,
contrairement aux chaînes, qui utilisent des guillemets doubles.)</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let c = 'z';
    let z = 'ℤ';
    let heart_eyed_cat = '😻';
}
```
-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let c = 'z';
    let z = 'ℤ';
    let chat_aux_yeux_de_coeur = '😻';
}
</code></pre></pre>
<!--
Rust’s `char` type is four bytes in size and represents a Unicode Scalar Value,
which means it can represent a lot more than just ASCII. Accented letters;
Chinese, Japanese, and Korean characters; emoji; and zero-width spaces are all
valid `char` values in Rust. Unicode Scalar Values range from `U+0000` to
`U+D7FF` and `U+E000` to `U+10FFFF` inclusive. However, a “character” isn’t
really a concept in Unicode, so your human intuition for what a “character” is
may not match up with what a `char` is in Rust. We’ll discuss this topic in
detail in [“Storing UTF-8 Encoded Text with Strings”][strings]<!-- ignore -- >
in Chapter 8.
-->
<p>Le type <code>char</code> de Rust prend quatre octets en mémoire et représente une valeur
scalaire Unicode, ce qui veut dire que cela représente plus de caractères que
l'ASCII. Les lettres accentuées ; les caractères chinois, japonais et coréens ;
les emoji ; les espaces de largeur nulle ont tous une valeur pour <code>char</code> avec
Rust. Les valeurs scalaires Unicode vont de <code>U+0000</code> à <code>U+D7FF</code> et de <code>U+E000</code> à
<code>U+10FFFF</code> inclus. Cependant, le concept de “caractère” n'est pas clairement
défini par Unicode, donc votre notion de “caractère” peut ne pas correspondre
à ce qu'est un <code>char</code> en Rust. Nous aborderons ce sujet plus en détail au
<a href="ch08-02-strings.html">chapitre 8</a>.</p>
<!--
### Compound Types
-->
<h3><a class="header" href="#les-types-composés" id="les-types-composés">Les types composés</a></h3>
<!--
*Compound types* can group multiple values into one type. Rust has two
primitive compound types: tuples and arrays.
-->
<p>Les <em>types composés</em> peuvent regrouper plusieurs valeurs dans un seul type. Rust
a deux types composés de base : les <em>tuples</em> et les tableaux <em>(arrays)</em>.</p>
<!--
#### The Tuple Type
-->
<h4><a class="header" href="#le-type-tuple" id="le-type-tuple">Le type <em>tuple</em></a></h4>
<!--
A tuple is a general way of grouping together some number of other values
with a variety of types into one compound type. Tuples have a fixed length:
once declared, they cannot grow or shrink in size.
-->
<p>Un <em>tuple</em> est une manière générale de regrouper plusieurs valeurs
de types différents en un seul type composé. Les tuples ont une taille fixée :
à partir du moment où ils ont été déclarés, on ne peut pas y ajouter ou enlever
des valeurs.</p>
<!--
We create a tuple by writing a comma-separated list of values inside
parentheses. Each position in the tuple has a type, and the types of the
different values in the tuple don’t have to be the same. We’ve added optional
type annotations in this example:
-->
<p>Nous créons un <em>tuple</em> en écrivant une liste séparée par des virgules entre des
parenthèses. Chaque emplacement dans le tuple a un type, et les types de chacune
des valeurs dans le tuple n'ont pas forcément besoin d'être les mêmes.
Nous avons ajouté des annotations de type dans cet exemple, mais c'est
optionnel :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
</code></pre></pre>
<!--
The variable `tup` binds to the entire tuple, because a tuple is considered a
single compound element. To get the individual values out of a tuple, we can
use pattern matching to destructure a tuple value, like this:
-->
<p>La variable <code>tup</code> est liée à tout le tuple, car un tuple est considéré
comme étant un unique élément composé. Pour obtenir un élément précis de ce
tuple, nous pouvons utiliser un filtrage par motif <em>(pattern matching)</em> pour
déstructurer ce tuple, comme ceci :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
```
-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!(&quot;La valeur de y est : {}&quot;, y);
}
</code></pre></pre>
<!--
This program first creates a tuple and binds it to the variable `tup`. It then
uses a pattern with `let` to take `tup` and turn it into three separate
variables, `x`, `y`, and `z`. This is called *destructuring*, because it breaks
the single tuple into three parts. Finally, the program prints the value of
`y`, which is `6.4`.
-->
<p>Le programme commence par créer un tuple et il l'assigne à la variable <code>tup</code>.
Il utilise ensuite un motif avec <code>let</code> pour prendre <code>tup</code> et le scinder en
trois variables distinctes : <code>x</code>, <code>y</code>, et <code>z</code>.
On appelle cela <em>déstructurer</em>, car il divise le tuple en trois parties.
Puis finalement, le programme affiche la valeur de <code>y</code>, qui est <code>6.4</code>.</p>
<!--
In addition to destructuring through pattern matching, we can access a tuple
element directly by using a period (`.`) followed by the index of the value we
want to access. For example:
-->
<p>En plus de pouvoir déstructurer avec un filtrage par motif, nous pouvons accéder
directement à chaque élément du tuple en utilisant un point (<code>.</code>) suivi de
l'indice de la valeur que nous souhaitons obtenir. Par exemple :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
```
-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let cinq_cents = x.0;

    let six_virgule_quatre = x.1;

    let un = x.2;
}
</code></pre></pre>
<!--
This program creates a tuple, `x`, and then makes new variables for each
element by using their index. As with most programming languages, the first
index in a tuple is 0.
-->
<p>Ce programme crée un tuple, <code>x</code>, puis crée une nouvelle variable pour
chaque élément en utilisant leur indice. Comme dans de nombreux langages de
programmation, le premier indice d'un tuple est 0.</p>
<!--
#### The Array Type
-->
<h4><a class="header" href="#le-type-tableau" id="le-type-tableau">Le type tableau</a></h4>
<!--
Another way to have a collection of multiple values is with an *array*. Unlike
a tuple, every element of an array must have the same type. Arrays in Rust are
different from arrays in some other languages because arrays in Rust have a
fixed length, like tuples.
-->
<p>Un autre moyen d'avoir une collection de plusieurs valeurs est d'utiliser
un <em>tableau</em>. Contrairement aux tuples, chaque élément d'un tableau doit être du
même type. Les tableaux de Rust diffèrent de ceux de certains autres langages
car les tableaux de Rust ont une taille fixe, comme les tuples.</p>
<!--
In Rust, the values going into an array are written as a comma-separated list
inside square brackets:
-->
<p>Avec Rust, les valeurs stockées dans un tableau sont écrites dans une
liste séparée par des virgules entre des crochets :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];
}
</code></pre></pre>
<!--
Arrays are useful when you want your data allocated on the stack rather than
the heap (we will discuss the stack and the heap more in Chapter 4) or when
you want to ensure you always have a fixed number of elements. An array isn’t
as flexible as the vector type, though. A vector is a similar collection type
provided by the standard library that *is* allowed to grow or shrink in size.
If you’re unsure whether to use an array or a vector, you should probably use a
vector. Chapter 8 discusses vectors in more detail.
-->
<p>Les tableaux sont utiles quand vous voulez que vos données soient allouées sur
la pile <em>(stack)</em> plutôt que sur le tas <em>(heap)</em> (nous expliquerons la pile et
le tas au chapitre 4) ou lorsque vous voulez vous assurer que vous avez toujours
un nombre fixe d'éléments. Cependant, un tableau n'est pas aussi flexible qu'un
vecteur <em>(vector)</em>. Un vecteur est un type de collection de données
similaire qui est fourni par la bibliothèque standard qui, lui, peut
grandir ou rétrécir en taille. Si vous ne savez pas si vous devez utiliser un
tableau ou un vecteur, vous devriez probablement utiliser un vecteur. Le
chapitre 8 expliquera les vecteurs.</p>
<!--
An example of when you might want to use an array rather than a vector is in a
program that needs to know the names of the months of the year. It’s very
unlikely that such a program will need to add or remove months, so you can use
an array because you know it will always contain 12 items:
-->
<p>Un exemple de cas où vous pourriez avoir recours à un tableau plutôt qu'à un
vecteur est un programme qui nécessite de connaître les noms des mois de
l'année.
Il est très improbable qu'un tel programme ait besoin d'ajouter ou de supprimer
des mois, donc vous pouvez utiliser un tableau car vous savez qu'il contiendra
toujours 12 éléments :</p>
<!--
```rust
let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
```
-->
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mois = [&quot;Janvier&quot;, &quot;Février&quot;, &quot;Mars&quot;, &quot;Avril&quot;, &quot;Mai&quot;, &quot;Juin&quot;, &quot;Juillet&quot;,
            &quot;Août&quot;, &quot;Septembre&quot;, &quot;Octobre&quot;, &quot;Novembre&quot;, &quot;Décembre&quot;];
#}</code></pre></pre>
<!--
You would write an array’s type by using square brackets, and within the
brackets include the type of each element, a semicolon, and then the number of
elements in the array, like so:
-->
<p>Vous pouvez écrire le type d'un tableau en utilisant des crochets, et entre ces
crochets y ajouter le type de chaque élément, un point-virgule, et ensuite le
nombre d'éléments dans le tableau, comme ceci :</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a: [i32; 5] = [1, 2, 3, 4, 5];
#}</code></pre></pre>
<!--
Here, `i32` is the type of each element. After the semicolon, the number `5`
indicates the element contains five items.
-->
<p>Ici, <code>i32</code> est le type de chaque élément. Après le point-virgule, le nombre <code>5</code>
indique que le tableau contient cinq éléments.</p>
<!--
Writing an array’s type this way looks similar to an alternative syntax for
initializing an array: if you want to create an array that contains the same
value for each element, you can specify the initial value, followed by a
semicolon, and then the length of the array in square brackets, as shown here:
-->
<p>L'écriture d'un type de tableau de cette manière ressemble à une autre syntaxe
pour initialiser un tableau : si vous voulez créer un tableau qui contient la
même valeur pour chaque élément, vous pouvez préciser la valeur initiale, suivie
par un point-virgule, et ensuite la taille du tableau, le tout entre crochets,
comme ci-dessous :</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a = [3; 5];
#}</code></pre></pre>
<!--
The array named `a` will contain `5` elements that will all be set to the value
`3` initially. This is the same as writing `let a = [3, 3, 3, 3, 3];` but in a
more concise way.
-->
<p>Le tableau <code>a</code> va contenir <code>5</code> éléments qui auront tous la valeur
initiale <code>3</code>. C'est la même chose que d'écrire <code>let a = [3, 3, 3, 3, 3];</code> mais
de manière plus concise.</p>
<!--
##### Accessing Array Elements
-->
<h5><a class="header" href="#accéder-aux-éléments-dun-tableau" id="accéder-aux-éléments-dun-tableau">Accéder aux éléments d'un tableau</a></h5>
<!--
An array is a single chunk of memory allocated on the stack. You can access
elements of an array using indexing, like this:
-->
<p>Un tableau est un simple bloc de mémoire alloué sur la pile. Vous pouvez accéder
aux éléments d'un tableau en utilisant l'indexation, comme ceci :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
```
-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];

    let premier = a[0];
    let second = a[1];
}
</code></pre></pre>
<!--
In this example, the variable named `first` will get the value `1`, because
that is the value at index `[0]` in the array. The variable named `second` will
get the value `2` from index `[1]` in the array.
-->
<p>Dans cet exemple, la variable qui s'appelle <code>premier</code> aura la valeur <code>1</code>, car
c'est la valeur à l'indice <code>[0]</code> dans le tableau. La variable <code>second</code>
récupèrera la valeur <code>2</code> depuis l'indice <code>[1]</code> du tableau.</p>
<!--
##### Invalid Array Element Access
-->
<h5><a class="header" href="#accès-incorrect-à-un-élément-dun-tableau" id="accès-incorrect-à-un-élément-dun-tableau">Accès incorrect à un élément d'un tableau</a></h5>
<!--
What happens if you try to access an element of an array that is past the end
of the array? Say you change the example to the following code, which will
compile but exit with an error when it runs:
-->
<p>Que se passe-t-il quand vous essayez d'accéder à un élément d'un tableau qui se
trouve après la fin du tableau ? Imaginons que vous changiez l'exemple par le
code suivant, qui va compiler mais qui va quitter avec une erreur quand il sera
exécuté :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,panics
fn main() {
    let a = [1, 2, 3, 4, 5];
    let index = 10;

    let element = a[index];

    println!("The value of element is: {}", element);
}
```
-->
<pre><code class="language-rust ignore panics">fn main() {
    let a = [1, 2, 3, 4, 5];
    let indice = 10;

    let element = a[indice];

    println!(&quot;La valeur de l'élément est : {}&quot;, element);
}
</code></pre>
<!--
Running this code using `cargo run` produces the following result:
-->
<p>Exécuter ce code en utilisant <code>cargo run</code> va donner le résultat suivant :</p>
<pre><code class="language-text">$ cargo run
   Compiling arrays v0.1.0 (file:///projects/arrays)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/arrays`
thread 'main' panicked at 'index out of bounds: the len is 5 but the index is
 10', src/main.rs:5:19
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<!--
The compilation didn’t produce any errors, but the program resulted in a
*runtime* error and didn’t exit successfully. When you attempt to access an
element using indexing, Rust will check that the index you’ve specified is less
than the array length. If the index is greater than or equal to the array
length, Rust will panic.
-->
<p>La compilation n'a pas produit d'erreur, mais le programme a rencontré une
erreur <em>à l'exécution</em> et ne s'est pas terminé avec succès. Quand vous essayez
d'accéder à un élément en utilisant l'indexation, Rust va vérifier que l'indice
que vous avez demandé est plus petit que la taille du tableau. Si l'indice est
supérieur ou égal à la taille du tableau, Rust va <em>paniquer</em>.</p>
<!--
This is the first example of Rust’s safety principles in action. In many
low-level languages, this kind of check is not done, and when you provide an
incorrect index, invalid memory can be accessed. Rust protects you against this
kind of error by immediately exiting instead of allowing the memory access and
continuing. Chapter 9 discusses more of Rust’s error handling.
-->
<p>C'est un premier exemple pratique des principes de sécurité de Rust. Dans de
nombreux langages de bas niveau, ce genre de vérification n'est pas effectuée,
et quand vous utilisez un indice incorrect, de la mémoire invalide peut être
récupérée. Rust vous protège de ce genre d'erreur en quittant immédiatement
l'exécution au lieu de permettre l'accès en mémoire et
continuer son déroulement. Le chapitre 9 expliquera la gestion d'erreurs de
Rust.</p>
<!--
[comparing-the-guess-to-the-secret-number]:
ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number
[control-flow]: ch03-05-control-flow.html#control-flow
[unrecoverable-errors-with-panic]: ch09-01-unrecoverable-errors-with-panic.html
[strings]: ch08-02-strings.html#storing-utf-8-encoded-text-with-strings
[wrapping]: ../std/num/struct.Wrapping.html
-->
<h1><a class="header" href="#understanding-ownership" id="understanding-ownership">Understanding Ownership</a></h1>
<!-- # Using Structs to Structure Related Data -->
<h1><a class="header" href="#utiliser-les-structures-pour-structurer-des-données-apparentées" id="utiliser-les-structures-pour-structurer-des-données-apparentées">Utiliser les structures pour structurer des données apparentées</a></h1>
<!--
A *struct*, or *structure*, is a custom data type that lets you name and
package together multiple related values that make up a meaningful group. If
you’re familiar with an object-oriented language, a *struct* is like an
object’s data attributes. In this chapter, we’ll compare and contrast tuples
with structs, demonstrate how to use structs, and discuss how to define methods
and associated functions to specify behavior associated with a struct’s data.
Structs and enums (discussed in Chapter 6) are the building blocks for creating
new types in your program’s domain to take full advantage of Rust’s compile
time type checking.
-->
<p>Une <em>struct</em>, ou <em>structure</em>, est un type de données personnalisé qui vous
permet de nommer et de rassembler plusieurs valeurs associées qui forment
un groupe cohérent.
Si vous êtes familier avec un langage orienté objet, une structure est en
quelque sorte l'ensemble des attributs d'un objet.
Dans ce chapitre, nous comparerons les tuples avec les structures, nous
montrerons comment utiliser les structures et nous aborderons la définition des
méthodes et des fonctions associées pour spécifier le comportement associé aux
données d'une structure.
Les structures et les énumérations (traitées au chapitre 6) sont les fondements
de la création de nouveaux types au sein de votre programme pour tirer
pleinement parti des vérifications de types effectuées par Rust à la
compilation.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../ferris.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
